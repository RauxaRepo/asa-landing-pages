/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../assets/src/js/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../assets/src/js/components/form.test.js":
/*!************************************************!*\
  !*** ../assets/src/js/components/form.test.js ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
var config = __webpack_require__(/*! ../../../../.gb/config */ "./config.js");

var base64 = __webpack_require__(/*! base-64 */ "../node_modules/base-64/base64.js");

/* harmony default export */ __webpack_exports__["default"] = (function () {
  var respSubmitBtn = document.querySelector('.submit-btn');
  var respSubmitted = document.querySelector('.submitted-params');
  var landingUrl = window.location.href;
  var customerId = document.querySelector('input[name="id"]');
  var offerCode = document.querySelector('input[name="offer"]');
  var offerAuth = document.querySelector('input[name="auth"]');
  var campaignName = 'Offercode_Email';
  var emailName = 'email';
  var getToken;
  var getEndpoint;
  var getTokenUrl = "https://cors-anywhere.herokuapp.com/https://login5.responsys.net/rest/api/v1.3/auth/token?user_name=".concat(config.creds.user, "&password=").concat(config.creds.pass, "&auth_type=password"); //
  // function to grab params from url

  var urlVars = function urlVars() {
    var vars = {};
    var parts = landingUrl.replace(/[?&]+([^=&]+)=([^&]*)/gi, function (m, key, value) {
      vars[key] = value;
    });
    return vars;
  }; // setting inputs based on url params


  customerId.value = urlVars()['CUSTOMER_ID_'] != undefined ? urlVars()['CUSTOMER_ID_'] : '';
  offerCode.value = urlVars()['OFFER_CODE'] != undefined ? urlVars()['OFFER_CODE'] : '';
  offerAuth.value = urlVars()['OFFER_AUTHORIZATION'] != undefined ? urlVars()['OFFER_AUTHORIZATION'] : ''; //offerTracking.value = urlVars()['UTM'] != undefined ? urlVars()['UTM'] : '';
  /// need to add UTM 

  var respTriggerEmail = function respTriggerEmail(authToken, endPoint) {
    var url = "https://cors-anywhere.herokuapp.com/".concat(endPoint, "/rest/api/v1.3/campaigns/").concat(campaignName, "/").concat(emailName);
    fetch(url, {
      method: "POST",
      mode: 'cors',
      // no-cors, *cors, same-origin
      headers: {
        'Authorization': authToken,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: JSON.stringify(respParms)
    }).then(function (response) {
      return response.json();
    }).then(function (json) {
      return console.log(json);
    });
  }; // getting Token


  respSubmitBtn.addEventListener('click', function (e) {
    e.preventDefault();
    var respParms = {
      CUSTOMER_ID_: customerId.value,
      OFFER_CODE: offerCode.value,
      OFFER_AUTHORIZATION: offerAuth.value
    };
    console.log(respParms);
    console.log(getToken);
    console.log(getEndpoint);
    var url = "https://cors-anywhere.herokuapp.com/".concat(getEndpoint, "/rest/api/v1.3/campaigns/").concat(campaignName, "/").concat(emailName);
    fetch(url, {
      method: "POST",
      mode: 'cors',
      // no-cors, *cors, same-origin
      headers: {
        'Authorization': getToken,
        'Content-Type': 'application/x-www-form-urlencoded'
      },
      body: JSON.stringify(respParms)
    }).then(function (response) {
      return response.json();
    }).then(function (json) {
      return console.log(json);
    });
  });
  fetch(getTokenUrl, {
    method: "POST",
    mode: 'cors',
    // no-cors, *cors, same-origin
    headers: {
      'Accept': 'application/json',
      'Content-Type': 'application/x-www-form-urlencoded'
    }
  }).then(function (response) {
    return response.json();
  }).then(function (json) {
    console.log(json); //respTriggerEmail(json.authToken,json.endPoint);

    getToken = json.authToken;
    getEndpoint = json.endPoint;
  });
});

/***/ }),

/***/ "../assets/src/js/components/intro-animation.js":
/*!******************************************************!*\
  !*** ../assets/src/js/components/intro-animation.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var gsap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! gsap */ "../node_modules/gsap/index.js");
/* harmony import */ var terser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! terser */ "../node_modules/terser/dist/bundle.min.js");
/* harmony import */ var terser__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(terser__WEBPACK_IMPORTED_MODULE_1__);
function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }



/* harmony default export */ __webpack_exports__["default"] = (function () {
  //Vars
  //*Randomize Array and place all Cards in the Array*//
  //Math.random() - 0.5 is a random number that may be positive or negative, so the sorting function reorders elements randomly.
  var allCardsshuffle = function allCardsshuffle(array) {
    return array.sort(function () {
      return Math.random() - 0.5;
    });
  }; //*Place all Cards except Title card in the Array*//


  var allCards = allCardsshuffle(_toConsumableArray(document.querySelectorAll('.main-page-card:not(.main-page-card-title)')));
  var time = 1,
      //Title Cards
  titleCard = document.querySelector('.card-one-title'),
      //Left Cards
  cardLeftOne = document.querySelector('.card-left-one'),
      cardLeftTwo = document.querySelector('.card-left-two'),
      //Right Cards
  cardrRightOne = document.querySelector('.card-right-one'),
      cardrRightTwo = document.querySelector('.card-right-two'),
      //
  tl = gsap__WEBPACK_IMPORTED_MODULE_0__["gsap"].timeline({
    repeat: 0,
    repeatDelay: 0
  }),
      tlScroll = gsap__WEBPACK_IMPORTED_MODULE_0__["gsap"].timeline({
    repeat: -1,
    repeatDelay: 0
  }),
      tlScrollTwo = gsap__WEBPACK_IMPORTED_MODULE_0__["gsap"].timeline({
    repeat: -1,
    repeatDelay: 0
  }),
      tlScrollThree = gsap__WEBPACK_IMPORTED_MODULE_0__["gsap"].timeline({
    repeat: -1,
    repeatDelay: 0
  }),
      tlScrollFour = gsap__WEBPACK_IMPORTED_MODULE_0__["gsap"].timeline({
    repeat: -1,
    repeatDelay: 0
  }); //Fade in Title-Card and other Cards

  tl.to(titleCard, time, {
    opacity: 1,
    delay: time - 0.5,
    ease: gsap__WEBPACK_IMPORTED_MODULE_0__["Linear"]
  }) //.05, = stagger amount//'0.25' time between animation for cards
  .staggerTo(allCards, time, {
    opacity: 1,
    delay: Math.random() * time,
    ease: gsap__WEBPACK_IMPORTED_MODULE_0__["Linear"],
    onComplete: function onComplete() {}
  }, .05, '0.25'); //Slider the Cards	

  tlScroll.to('.main-page-card-wrapper', 10, {
    top: '90.25%',
    ease: 'none'
  });
  tlScrollTwo.to('.main-page-card-wrapper-two', 15, {
    top: '80.25%',
    ease: 'none'
  });
  tlScrollThree.to('.main-page-card-wrapper-three', 10, {
    top: '70.25%',
    ease: 'none'
  });
  tlScrollFour.to('.main-page-card-wrapper-four', 17, {
    top: '60.25%',
    ease: 'none'
  }); //console.log(allCards);
});

/***/ }),

/***/ "../assets/src/js/main.js":
/*!********************************!*\
  !*** ../assets/src/js/main.js ***!
  \********************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _babel_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/polyfill */ "../node_modules/@babel/polyfill/lib/index.js");
/* harmony import */ var _babel_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_babel_polyfill__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var whatwg_fetch__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! whatwg-fetch */ "../node_modules/whatwg-fetch/fetch.js");
/* harmony import */ var _components_form_test__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/form.test */ "../assets/src/js/components/form.test.js");
/* harmony import */ var _components_intro_animation__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/intro-animation */ "../assets/src/js/components/intro-animation.js");

 //import sampleJs from './components/sample.component';




function documentReady(fn) {
  if (document.readyState != 'loading') {
    fn();
  } else if (document.addEventListener) {
    document.addEventListener('DOMContentLoaded', fn);
  } else {
    document.attachEvent('onreadystatechange', function () {
      if (document.readyState != 'loading') fn();
    });
  }
}

documentReady(function () {
  //responsysTest();
  Object(_components_intro_animation__WEBPACK_IMPORTED_MODULE_3__["default"])();
});

/***/ }),

/***/ "../node_modules/@babel/polyfill/lib/index.js":
/*!****************************************************!*\
  !*** ../node_modules/@babel/polyfill/lib/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./noConflict */ "../node_modules/@babel/polyfill/lib/noConflict.js");

var _global = _interopRequireDefault(__webpack_require__(/*! core-js/library/fn/global */ "../node_modules/core-js/library/fn/global.js"));

function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : {
    "default": obj
  };
}

if (_global["default"]._babelPolyfill && typeof console !== "undefined" && console.warn) {
  console.warn("@babel/polyfill is loaded more than once on this page. This is probably not desirable/intended " + "and may have consequences if different versions of the polyfills are applied sequentially. " + "If you do need to load the polyfill more than once, use @babel/polyfill/noConflict " + "instead to bypass the warning.");
}

_global["default"]._babelPolyfill = true;

/***/ }),

/***/ "../node_modules/@babel/polyfill/lib/noConflict.js":
/*!*********************************************************!*\
  !*** ../node_modules/@babel/polyfill/lib/noConflict.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! core-js/es6 */ "../node_modules/core-js/es6/index.js");

__webpack_require__(/*! core-js/fn/array/includes */ "../node_modules/core-js/fn/array/includes.js");

__webpack_require__(/*! core-js/fn/array/flat-map */ "../node_modules/core-js/fn/array/flat-map.js");

__webpack_require__(/*! core-js/fn/string/pad-start */ "../node_modules/core-js/fn/string/pad-start.js");

__webpack_require__(/*! core-js/fn/string/pad-end */ "../node_modules/core-js/fn/string/pad-end.js");

__webpack_require__(/*! core-js/fn/string/trim-start */ "../node_modules/core-js/fn/string/trim-start.js");

__webpack_require__(/*! core-js/fn/string/trim-end */ "../node_modules/core-js/fn/string/trim-end.js");

__webpack_require__(/*! core-js/fn/symbol/async-iterator */ "../node_modules/core-js/fn/symbol/async-iterator.js");

__webpack_require__(/*! core-js/fn/object/get-own-property-descriptors */ "../node_modules/core-js/fn/object/get-own-property-descriptors.js");

__webpack_require__(/*! core-js/fn/object/values */ "../node_modules/core-js/fn/object/values.js");

__webpack_require__(/*! core-js/fn/object/entries */ "../node_modules/core-js/fn/object/entries.js");

__webpack_require__(/*! core-js/fn/promise/finally */ "../node_modules/core-js/fn/promise/finally.js");

__webpack_require__(/*! core-js/web */ "../node_modules/core-js/web/index.js");

__webpack_require__(/*! regenerator-runtime/runtime */ "../node_modules/regenerator-runtime/runtime.js");

/***/ }),

/***/ "../node_modules/base-64/base64.js":
/*!*****************************************!*\
  !*** ../node_modules/base-64/base64.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*! http://mths.be/base64 v0.1.0 by @mathias | MIT license */
;

(function (root) {
  // Detect free variables `exports`.
  var freeExports = ( false ? undefined : _typeof(exports)) == 'object' && exports; // Detect free variable `module`.

  var freeModule = ( false ? undefined : _typeof(module)) == 'object' && module && module.exports == freeExports && module; // Detect free variable `global`, from Node.js or Browserified code, and use
  // it as `root`.

  var freeGlobal = (typeof global === "undefined" ? "undefined" : _typeof(global)) == 'object' && global;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {
    root = freeGlobal;
  }
  /*--------------------------------------------------------------------------*/


  var InvalidCharacterError = function InvalidCharacterError(message) {
    this.message = message;
  };

  InvalidCharacterError.prototype = new Error();
  InvalidCharacterError.prototype.name = 'InvalidCharacterError';

  var error = function error(message) {
    // Note: the error messages used throughout this file match those used by
    // the native `atob`/`btoa` implementation in Chromium.
    throw new InvalidCharacterError(message);
  };

  var TABLE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // http://whatwg.org/html/common-microsyntaxes.html#space-character

  var REGEX_SPACE_CHARACTERS = /[\t\n\f\r ]/g; // `decode` is designed to be fully compatible with `atob` as described in the
  // HTML Standard. http://whatwg.org/html/webappapis.html#dom-windowbase64-atob
  // The optimized base64-decoding algorithm used is based on @atk’s excellent
  // implementation. https://gist.github.com/atk/1020396

  var decode = function decode(input) {
    input = String(input).replace(REGEX_SPACE_CHARACTERS, '');
    var length = input.length;

    if (length % 4 == 0) {
      input = input.replace(/==?$/, '');
      length = input.length;
    }

    if (length % 4 == 1 || // http://whatwg.org/C#alphanumeric-ascii-characters
    /[^+a-zA-Z0-9/]/.test(input)) {
      error('Invalid character: the string to be decoded is not correctly encoded.');
    }

    var bitCounter = 0;
    var bitStorage;
    var buffer;
    var output = '';
    var position = -1;

    while (++position < length) {
      buffer = TABLE.indexOf(input.charAt(position));
      bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer; // Unless this is the first of a group of 4 characters…

      if (bitCounter++ % 4) {
        // …convert the first 8 bits to a single ASCII character.
        output += String.fromCharCode(0xFF & bitStorage >> (-2 * bitCounter & 6));
      }
    }

    return output;
  }; // `encode` is designed to be fully compatible with `btoa` as described in the
  // HTML Standard: http://whatwg.org/html/webappapis.html#dom-windowbase64-btoa


  var encode = function encode(input) {
    input = String(input);

    if (/[^\0-\xFF]/.test(input)) {
      // Note: no need to special-case astral symbols here, as surrogates are
      // matched, and the input is supposed to only contain ASCII anyway.
      error('The string to be encoded contains characters outside of the ' + 'Latin1 range.');
    }

    var padding = input.length % 3;
    var output = '';
    var position = -1;
    var a;
    var b;
    var c;
    var d;
    var buffer; // Make sure any padding is handled outside of the loop.

    var length = input.length - padding;

    while (++position < length) {
      // Read three bytes, i.e. 24 bits.
      a = input.charCodeAt(position) << 16;
      b = input.charCodeAt(++position) << 8;
      c = input.charCodeAt(++position);
      buffer = a + b + c; // Turn the 24 bits into four chunks of 6 bits each, and append the
      // matching character for each of them to the output.

      output += TABLE.charAt(buffer >> 18 & 0x3F) + TABLE.charAt(buffer >> 12 & 0x3F) + TABLE.charAt(buffer >> 6 & 0x3F) + TABLE.charAt(buffer & 0x3F);
    }

    if (padding == 2) {
      a = input.charCodeAt(position) << 8;
      b = input.charCodeAt(++position);
      buffer = a + b;
      output += TABLE.charAt(buffer >> 10) + TABLE.charAt(buffer >> 4 & 0x3F) + TABLE.charAt(buffer << 2 & 0x3F) + '=';
    } else if (padding == 1) {
      buffer = input.charCodeAt(position);
      output += TABLE.charAt(buffer >> 2) + TABLE.charAt(buffer << 4 & 0x3F) + '==';
    }

    return output;
  };

  var base64 = {
    'encode': encode,
    'decode': decode,
    'version': '0.1.0'
  }; // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if ( true && _typeof(__webpack_require__(/*! !webpack amd options */ "../node_modules/webpack/buildin/amd-options.js")) == 'object' && __webpack_require__(/*! !webpack amd options */ "../node_modules/webpack/buildin/amd-options.js")) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return base64;
    }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (freeExports && !freeExports.nodeType) {
    if (freeModule) {
      // in Node.js or RingoJS v0.8.0+
      freeModule.exports = base64;
    } else {
      // in Narwhal or RingoJS v0.7.0-
      for (var key in base64) {
        base64.hasOwnProperty(key) && (freeExports[key] = base64[key]);
      }
    }
  } else {
    // in Rhino or a web browser
    root.base64 = base64;
  }
})(this);
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/base64-js/index.js":
/*!******************************************!*\
  !*** ../node_modules/base64-js/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "../node_modules/buffer/index.js":
/*!***************************************!*\
  !*** ../node_modules/buffer/index.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


var base64 = __webpack_require__(/*! base64-js */ "../node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "../node_modules/ieee754/index.js");

var isArray = __webpack_require__(/*! isarray */ "../node_modules/buffer/node_modules/isarray/index.js");

exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */

Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
/*
 * Export kMaxLength after typed array support is determined.
 */

exports.kMaxLength = kMaxLength();

function typedArraySupport() {
  try {
    var arr = new Uint8Array(1);
    arr.__proto__ = {
      __proto__: Uint8Array.prototype,
      foo: function foo() {
        return 42;
      }
    };
    return arr.foo() === 42 && // typed array instances can be augmented
    typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
    arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
  } catch (e) {
    return false;
  }
}

function kMaxLength() {
  return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
}

function createBuffer(that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length');
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length);
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length);
    }

    that.length = length;
  }

  return that;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length);
  } // Common case.


  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error('If encoding is specified then the first argument must be a string');
    }

    return allocUnsafe(this, arg);
  }

  return from(this, arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation
// TODO: Legacy, not needed anymore. Remove in next major version.

Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype;
  return arr;
};

function from(that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number');
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length);
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset);
  }

  return fromObject(that, value);
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length);
};

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype;
  Buffer.__proto__ = Uint8Array;

  if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    });
  }
}

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number');
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative');
  }
}

function alloc(that, size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(that, size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
  }

  return createBuffer(that, size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding);
};

function allocUnsafe(that, size) {
  assertSize(size);
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0;
    }
  }

  return that;
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size);
};

function fromString(that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding');
  }

  var length = byteLength(string, encoding) | 0;
  that = createBuffer(that, length);
  var actual = that.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual);
  }

  return that;
}

function fromArrayLike(that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  that = createBuffer(that, length);

  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255;
  }

  return that;
}

function fromArrayBuffer(that, array, byteOffset, length) {
  array.byteLength; // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds');
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array);
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset);
  } else {
    array = new Uint8Array(array, byteOffset, length);
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array;
    that.__proto__ = Buffer.prototype;
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array);
  }

  return that;
}

function fromObject(that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    that = createBuffer(that, len);

    if (that.length === 0) {
      return that;
    }

    obj.copy(that, 0, 0, len);
    return that;
  }

  if (obj) {
    if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0);
      }

      return fromArrayLike(that, obj);
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data);
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
}

function checked(length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return !!(b != null && b._isBuffer);
};

Buffer.compare = function compare(a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    buf.copy(buffer, pos);
    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    string = '' + string;
  }

  var len = string.length;
  if (len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) return utf8ToBytes(string).length; // assume utf8

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length | 0;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;

  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
    if (this.length > max) str += ' ... ';
  }

  return '<Buffer ' + str + '>';
};

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer');
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  } // must be an even number of digits


  var strLen = string.length;
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (isNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function latin1Write(buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0;

    if (isFinite(length)) {
      length = length | 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    } // legacy write(string, encoding, offset, length) - remove in v0.13

  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
        return asciiWrite(this, string, offset, length);

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += toHex(buf[i]);
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = '';

  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end);
    newBuf.__proto__ = Buffer.prototype;
  } else {
    var sliceLen = end - start;
    newBuf = new Buffer(sliceLen, undefined);

    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start];
    }
  }

  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset | 0;
  byteLength = byteLength | 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;
  byteLength = byteLength | 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  this[offset] = value & 0xff;
  return offset + 1;
};

function objectWriteUInt16(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

function objectWriteUInt32(buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1;

  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset | 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
  } else {
    objectWriteUInt16(this, value, offset, true);
  }

  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 8;
    this[offset + 1] = value & 0xff;
  } else {
    objectWriteUInt16(this, value, offset, false);
  }

  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value & 0xff;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
  } else {
    objectWriteUInt32(this, value, offset, true);
  }

  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset | 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 0xff;
  } else {
    objectWriteUInt32(this, value, offset, false);
  }

  return offset + 4;
};

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;
  var i;

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start];
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start];
    }
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (code < 256) {
        val = code;
      }
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
    var len = bytes.length;

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function stringtrim(str) {
  if (str.trim) return str.trim();
  return str.replace(/^\s+|\s+$/g, '');
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
}

function isnan(val) {
  return val !== val; // eslint-disable-line no-self-compare
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../node_modules/buffer/node_modules/isarray/index.js":
/*!************************************************************!*\
  !*** ../node_modules/buffer/node_modules/isarray/index.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

/***/ }),

/***/ "../node_modules/core-js/es6/index.js":
/*!********************************************!*\
  !*** ../node_modules/core-js/es6/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es6.symbol */ "../node_modules/core-js/modules/es6.symbol.js");

__webpack_require__(/*! ../modules/es6.object.create */ "../node_modules/core-js/modules/es6.object.create.js");

__webpack_require__(/*! ../modules/es6.object.define-property */ "../node_modules/core-js/modules/es6.object.define-property.js");

__webpack_require__(/*! ../modules/es6.object.define-properties */ "../node_modules/core-js/modules/es6.object.define-properties.js");

__webpack_require__(/*! ../modules/es6.object.get-own-property-descriptor */ "../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js");

__webpack_require__(/*! ../modules/es6.object.get-prototype-of */ "../node_modules/core-js/modules/es6.object.get-prototype-of.js");

__webpack_require__(/*! ../modules/es6.object.keys */ "../node_modules/core-js/modules/es6.object.keys.js");

__webpack_require__(/*! ../modules/es6.object.get-own-property-names */ "../node_modules/core-js/modules/es6.object.get-own-property-names.js");

__webpack_require__(/*! ../modules/es6.object.freeze */ "../node_modules/core-js/modules/es6.object.freeze.js");

__webpack_require__(/*! ../modules/es6.object.seal */ "../node_modules/core-js/modules/es6.object.seal.js");

__webpack_require__(/*! ../modules/es6.object.prevent-extensions */ "../node_modules/core-js/modules/es6.object.prevent-extensions.js");

__webpack_require__(/*! ../modules/es6.object.is-frozen */ "../node_modules/core-js/modules/es6.object.is-frozen.js");

__webpack_require__(/*! ../modules/es6.object.is-sealed */ "../node_modules/core-js/modules/es6.object.is-sealed.js");

__webpack_require__(/*! ../modules/es6.object.is-extensible */ "../node_modules/core-js/modules/es6.object.is-extensible.js");

__webpack_require__(/*! ../modules/es6.object.assign */ "../node_modules/core-js/modules/es6.object.assign.js");

__webpack_require__(/*! ../modules/es6.object.is */ "../node_modules/core-js/modules/es6.object.is.js");

__webpack_require__(/*! ../modules/es6.object.set-prototype-of */ "../node_modules/core-js/modules/es6.object.set-prototype-of.js");

__webpack_require__(/*! ../modules/es6.object.to-string */ "../node_modules/core-js/modules/es6.object.to-string.js");

__webpack_require__(/*! ../modules/es6.function.bind */ "../node_modules/core-js/modules/es6.function.bind.js");

__webpack_require__(/*! ../modules/es6.function.name */ "../node_modules/core-js/modules/es6.function.name.js");

__webpack_require__(/*! ../modules/es6.function.has-instance */ "../node_modules/core-js/modules/es6.function.has-instance.js");

__webpack_require__(/*! ../modules/es6.parse-int */ "../node_modules/core-js/modules/es6.parse-int.js");

__webpack_require__(/*! ../modules/es6.parse-float */ "../node_modules/core-js/modules/es6.parse-float.js");

__webpack_require__(/*! ../modules/es6.number.constructor */ "../node_modules/core-js/modules/es6.number.constructor.js");

__webpack_require__(/*! ../modules/es6.number.to-fixed */ "../node_modules/core-js/modules/es6.number.to-fixed.js");

__webpack_require__(/*! ../modules/es6.number.to-precision */ "../node_modules/core-js/modules/es6.number.to-precision.js");

__webpack_require__(/*! ../modules/es6.number.epsilon */ "../node_modules/core-js/modules/es6.number.epsilon.js");

__webpack_require__(/*! ../modules/es6.number.is-finite */ "../node_modules/core-js/modules/es6.number.is-finite.js");

__webpack_require__(/*! ../modules/es6.number.is-integer */ "../node_modules/core-js/modules/es6.number.is-integer.js");

__webpack_require__(/*! ../modules/es6.number.is-nan */ "../node_modules/core-js/modules/es6.number.is-nan.js");

__webpack_require__(/*! ../modules/es6.number.is-safe-integer */ "../node_modules/core-js/modules/es6.number.is-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.max-safe-integer */ "../node_modules/core-js/modules/es6.number.max-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.min-safe-integer */ "../node_modules/core-js/modules/es6.number.min-safe-integer.js");

__webpack_require__(/*! ../modules/es6.number.parse-float */ "../node_modules/core-js/modules/es6.number.parse-float.js");

__webpack_require__(/*! ../modules/es6.number.parse-int */ "../node_modules/core-js/modules/es6.number.parse-int.js");

__webpack_require__(/*! ../modules/es6.math.acosh */ "../node_modules/core-js/modules/es6.math.acosh.js");

__webpack_require__(/*! ../modules/es6.math.asinh */ "../node_modules/core-js/modules/es6.math.asinh.js");

__webpack_require__(/*! ../modules/es6.math.atanh */ "../node_modules/core-js/modules/es6.math.atanh.js");

__webpack_require__(/*! ../modules/es6.math.cbrt */ "../node_modules/core-js/modules/es6.math.cbrt.js");

__webpack_require__(/*! ../modules/es6.math.clz32 */ "../node_modules/core-js/modules/es6.math.clz32.js");

__webpack_require__(/*! ../modules/es6.math.cosh */ "../node_modules/core-js/modules/es6.math.cosh.js");

__webpack_require__(/*! ../modules/es6.math.expm1 */ "../node_modules/core-js/modules/es6.math.expm1.js");

__webpack_require__(/*! ../modules/es6.math.fround */ "../node_modules/core-js/modules/es6.math.fround.js");

__webpack_require__(/*! ../modules/es6.math.hypot */ "../node_modules/core-js/modules/es6.math.hypot.js");

__webpack_require__(/*! ../modules/es6.math.imul */ "../node_modules/core-js/modules/es6.math.imul.js");

__webpack_require__(/*! ../modules/es6.math.log10 */ "../node_modules/core-js/modules/es6.math.log10.js");

__webpack_require__(/*! ../modules/es6.math.log1p */ "../node_modules/core-js/modules/es6.math.log1p.js");

__webpack_require__(/*! ../modules/es6.math.log2 */ "../node_modules/core-js/modules/es6.math.log2.js");

__webpack_require__(/*! ../modules/es6.math.sign */ "../node_modules/core-js/modules/es6.math.sign.js");

__webpack_require__(/*! ../modules/es6.math.sinh */ "../node_modules/core-js/modules/es6.math.sinh.js");

__webpack_require__(/*! ../modules/es6.math.tanh */ "../node_modules/core-js/modules/es6.math.tanh.js");

__webpack_require__(/*! ../modules/es6.math.trunc */ "../node_modules/core-js/modules/es6.math.trunc.js");

__webpack_require__(/*! ../modules/es6.string.from-code-point */ "../node_modules/core-js/modules/es6.string.from-code-point.js");

__webpack_require__(/*! ../modules/es6.string.raw */ "../node_modules/core-js/modules/es6.string.raw.js");

__webpack_require__(/*! ../modules/es6.string.trim */ "../node_modules/core-js/modules/es6.string.trim.js");

__webpack_require__(/*! ../modules/es6.string.iterator */ "../node_modules/core-js/modules/es6.string.iterator.js");

__webpack_require__(/*! ../modules/es6.string.code-point-at */ "../node_modules/core-js/modules/es6.string.code-point-at.js");

__webpack_require__(/*! ../modules/es6.string.ends-with */ "../node_modules/core-js/modules/es6.string.ends-with.js");

__webpack_require__(/*! ../modules/es6.string.includes */ "../node_modules/core-js/modules/es6.string.includes.js");

__webpack_require__(/*! ../modules/es6.string.repeat */ "../node_modules/core-js/modules/es6.string.repeat.js");

__webpack_require__(/*! ../modules/es6.string.starts-with */ "../node_modules/core-js/modules/es6.string.starts-with.js");

__webpack_require__(/*! ../modules/es6.string.anchor */ "../node_modules/core-js/modules/es6.string.anchor.js");

__webpack_require__(/*! ../modules/es6.string.big */ "../node_modules/core-js/modules/es6.string.big.js");

__webpack_require__(/*! ../modules/es6.string.blink */ "../node_modules/core-js/modules/es6.string.blink.js");

__webpack_require__(/*! ../modules/es6.string.bold */ "../node_modules/core-js/modules/es6.string.bold.js");

__webpack_require__(/*! ../modules/es6.string.fixed */ "../node_modules/core-js/modules/es6.string.fixed.js");

__webpack_require__(/*! ../modules/es6.string.fontcolor */ "../node_modules/core-js/modules/es6.string.fontcolor.js");

__webpack_require__(/*! ../modules/es6.string.fontsize */ "../node_modules/core-js/modules/es6.string.fontsize.js");

__webpack_require__(/*! ../modules/es6.string.italics */ "../node_modules/core-js/modules/es6.string.italics.js");

__webpack_require__(/*! ../modules/es6.string.link */ "../node_modules/core-js/modules/es6.string.link.js");

__webpack_require__(/*! ../modules/es6.string.small */ "../node_modules/core-js/modules/es6.string.small.js");

__webpack_require__(/*! ../modules/es6.string.strike */ "../node_modules/core-js/modules/es6.string.strike.js");

__webpack_require__(/*! ../modules/es6.string.sub */ "../node_modules/core-js/modules/es6.string.sub.js");

__webpack_require__(/*! ../modules/es6.string.sup */ "../node_modules/core-js/modules/es6.string.sup.js");

__webpack_require__(/*! ../modules/es6.date.now */ "../node_modules/core-js/modules/es6.date.now.js");

__webpack_require__(/*! ../modules/es6.date.to-json */ "../node_modules/core-js/modules/es6.date.to-json.js");

__webpack_require__(/*! ../modules/es6.date.to-iso-string */ "../node_modules/core-js/modules/es6.date.to-iso-string.js");

__webpack_require__(/*! ../modules/es6.date.to-string */ "../node_modules/core-js/modules/es6.date.to-string.js");

__webpack_require__(/*! ../modules/es6.date.to-primitive */ "../node_modules/core-js/modules/es6.date.to-primitive.js");

__webpack_require__(/*! ../modules/es6.array.is-array */ "../node_modules/core-js/modules/es6.array.is-array.js");

__webpack_require__(/*! ../modules/es6.array.from */ "../node_modules/core-js/modules/es6.array.from.js");

__webpack_require__(/*! ../modules/es6.array.of */ "../node_modules/core-js/modules/es6.array.of.js");

__webpack_require__(/*! ../modules/es6.array.join */ "../node_modules/core-js/modules/es6.array.join.js");

__webpack_require__(/*! ../modules/es6.array.slice */ "../node_modules/core-js/modules/es6.array.slice.js");

__webpack_require__(/*! ../modules/es6.array.sort */ "../node_modules/core-js/modules/es6.array.sort.js");

__webpack_require__(/*! ../modules/es6.array.for-each */ "../node_modules/core-js/modules/es6.array.for-each.js");

__webpack_require__(/*! ../modules/es6.array.map */ "../node_modules/core-js/modules/es6.array.map.js");

__webpack_require__(/*! ../modules/es6.array.filter */ "../node_modules/core-js/modules/es6.array.filter.js");

__webpack_require__(/*! ../modules/es6.array.some */ "../node_modules/core-js/modules/es6.array.some.js");

__webpack_require__(/*! ../modules/es6.array.every */ "../node_modules/core-js/modules/es6.array.every.js");

__webpack_require__(/*! ../modules/es6.array.reduce */ "../node_modules/core-js/modules/es6.array.reduce.js");

__webpack_require__(/*! ../modules/es6.array.reduce-right */ "../node_modules/core-js/modules/es6.array.reduce-right.js");

__webpack_require__(/*! ../modules/es6.array.index-of */ "../node_modules/core-js/modules/es6.array.index-of.js");

__webpack_require__(/*! ../modules/es6.array.last-index-of */ "../node_modules/core-js/modules/es6.array.last-index-of.js");

__webpack_require__(/*! ../modules/es6.array.copy-within */ "../node_modules/core-js/modules/es6.array.copy-within.js");

__webpack_require__(/*! ../modules/es6.array.fill */ "../node_modules/core-js/modules/es6.array.fill.js");

__webpack_require__(/*! ../modules/es6.array.find */ "../node_modules/core-js/modules/es6.array.find.js");

__webpack_require__(/*! ../modules/es6.array.find-index */ "../node_modules/core-js/modules/es6.array.find-index.js");

__webpack_require__(/*! ../modules/es6.array.species */ "../node_modules/core-js/modules/es6.array.species.js");

__webpack_require__(/*! ../modules/es6.array.iterator */ "../node_modules/core-js/modules/es6.array.iterator.js");

__webpack_require__(/*! ../modules/es6.regexp.constructor */ "../node_modules/core-js/modules/es6.regexp.constructor.js");

__webpack_require__(/*! ../modules/es6.regexp.exec */ "../node_modules/core-js/modules/es6.regexp.exec.js");

__webpack_require__(/*! ../modules/es6.regexp.to-string */ "../node_modules/core-js/modules/es6.regexp.to-string.js");

__webpack_require__(/*! ../modules/es6.regexp.flags */ "../node_modules/core-js/modules/es6.regexp.flags.js");

__webpack_require__(/*! ../modules/es6.regexp.match */ "../node_modules/core-js/modules/es6.regexp.match.js");

__webpack_require__(/*! ../modules/es6.regexp.replace */ "../node_modules/core-js/modules/es6.regexp.replace.js");

__webpack_require__(/*! ../modules/es6.regexp.search */ "../node_modules/core-js/modules/es6.regexp.search.js");

__webpack_require__(/*! ../modules/es6.regexp.split */ "../node_modules/core-js/modules/es6.regexp.split.js");

__webpack_require__(/*! ../modules/es6.promise */ "../node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ../modules/es6.map */ "../node_modules/core-js/modules/es6.map.js");

__webpack_require__(/*! ../modules/es6.set */ "../node_modules/core-js/modules/es6.set.js");

__webpack_require__(/*! ../modules/es6.weak-map */ "../node_modules/core-js/modules/es6.weak-map.js");

__webpack_require__(/*! ../modules/es6.weak-set */ "../node_modules/core-js/modules/es6.weak-set.js");

__webpack_require__(/*! ../modules/es6.typed.array-buffer */ "../node_modules/core-js/modules/es6.typed.array-buffer.js");

__webpack_require__(/*! ../modules/es6.typed.data-view */ "../node_modules/core-js/modules/es6.typed.data-view.js");

__webpack_require__(/*! ../modules/es6.typed.int8-array */ "../node_modules/core-js/modules/es6.typed.int8-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint8-array */ "../node_modules/core-js/modules/es6.typed.uint8-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint8-clamped-array */ "../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js");

__webpack_require__(/*! ../modules/es6.typed.int16-array */ "../node_modules/core-js/modules/es6.typed.int16-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint16-array */ "../node_modules/core-js/modules/es6.typed.uint16-array.js");

__webpack_require__(/*! ../modules/es6.typed.int32-array */ "../node_modules/core-js/modules/es6.typed.int32-array.js");

__webpack_require__(/*! ../modules/es6.typed.uint32-array */ "../node_modules/core-js/modules/es6.typed.uint32-array.js");

__webpack_require__(/*! ../modules/es6.typed.float32-array */ "../node_modules/core-js/modules/es6.typed.float32-array.js");

__webpack_require__(/*! ../modules/es6.typed.float64-array */ "../node_modules/core-js/modules/es6.typed.float64-array.js");

__webpack_require__(/*! ../modules/es6.reflect.apply */ "../node_modules/core-js/modules/es6.reflect.apply.js");

__webpack_require__(/*! ../modules/es6.reflect.construct */ "../node_modules/core-js/modules/es6.reflect.construct.js");

__webpack_require__(/*! ../modules/es6.reflect.define-property */ "../node_modules/core-js/modules/es6.reflect.define-property.js");

__webpack_require__(/*! ../modules/es6.reflect.delete-property */ "../node_modules/core-js/modules/es6.reflect.delete-property.js");

__webpack_require__(/*! ../modules/es6.reflect.enumerate */ "../node_modules/core-js/modules/es6.reflect.enumerate.js");

__webpack_require__(/*! ../modules/es6.reflect.get */ "../node_modules/core-js/modules/es6.reflect.get.js");

__webpack_require__(/*! ../modules/es6.reflect.get-own-property-descriptor */ "../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js");

__webpack_require__(/*! ../modules/es6.reflect.get-prototype-of */ "../node_modules/core-js/modules/es6.reflect.get-prototype-of.js");

__webpack_require__(/*! ../modules/es6.reflect.has */ "../node_modules/core-js/modules/es6.reflect.has.js");

__webpack_require__(/*! ../modules/es6.reflect.is-extensible */ "../node_modules/core-js/modules/es6.reflect.is-extensible.js");

__webpack_require__(/*! ../modules/es6.reflect.own-keys */ "../node_modules/core-js/modules/es6.reflect.own-keys.js");

__webpack_require__(/*! ../modules/es6.reflect.prevent-extensions */ "../node_modules/core-js/modules/es6.reflect.prevent-extensions.js");

__webpack_require__(/*! ../modules/es6.reflect.set */ "../node_modules/core-js/modules/es6.reflect.set.js");

__webpack_require__(/*! ../modules/es6.reflect.set-prototype-of */ "../node_modules/core-js/modules/es6.reflect.set-prototype-of.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "../node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "../node_modules/core-js/fn/array/flat-map.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/fn/array/flat-map.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.array.flat-map */ "../node_modules/core-js/modules/es7.array.flat-map.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").Array.flatMap;

/***/ }),

/***/ "../node_modules/core-js/fn/array/includes.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/fn/array/includes.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.array.includes */ "../node_modules/core-js/modules/es7.array.includes.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").Array.includes;

/***/ }),

/***/ "../node_modules/core-js/fn/object/entries.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/fn/object/entries.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.object.entries */ "../node_modules/core-js/modules/es7.object.entries.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").Object.entries;

/***/ }),

/***/ "../node_modules/core-js/fn/object/get-own-property-descriptors.js":
/*!*************************************************************************!*\
  !*** ../node_modules/core-js/fn/object/get-own-property-descriptors.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.object.get-own-property-descriptors */ "../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").Object.getOwnPropertyDescriptors;

/***/ }),

/***/ "../node_modules/core-js/fn/object/values.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/fn/object/values.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.object.values */ "../node_modules/core-js/modules/es7.object.values.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").Object.values;

/***/ }),

/***/ "../node_modules/core-js/fn/promise/finally.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/fn/promise/finally.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ../../modules/es6.promise */ "../node_modules/core-js/modules/es6.promise.js");

__webpack_require__(/*! ../../modules/es7.promise.finally */ "../node_modules/core-js/modules/es7.promise.finally.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").Promise['finally'];

/***/ }),

/***/ "../node_modules/core-js/fn/string/pad-end.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/fn/string/pad-end.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.pad-end */ "../node_modules/core-js/modules/es7.string.pad-end.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").String.padEnd;

/***/ }),

/***/ "../node_modules/core-js/fn/string/pad-start.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/fn/string/pad-start.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.pad-start */ "../node_modules/core-js/modules/es7.string.pad-start.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").String.padStart;

/***/ }),

/***/ "../node_modules/core-js/fn/string/trim-end.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/fn/string/trim-end.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.trim-right */ "../node_modules/core-js/modules/es7.string.trim-right.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").String.trimRight;

/***/ }),

/***/ "../node_modules/core-js/fn/string/trim-start.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/fn/string/trim-start.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.string.trim-left */ "../node_modules/core-js/modules/es7.string.trim-left.js");

module.exports = __webpack_require__(/*! ../../modules/_core */ "../node_modules/core-js/modules/_core.js").String.trimLeft;

/***/ }),

/***/ "../node_modules/core-js/fn/symbol/async-iterator.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/fn/symbol/async-iterator.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../../modules/es7.symbol.async-iterator */ "../node_modules/core-js/modules/es7.symbol.async-iterator.js");

module.exports = __webpack_require__(/*! ../../modules/_wks-ext */ "../node_modules/core-js/modules/_wks-ext.js").f('asyncIterator');

/***/ }),

/***/ "../node_modules/core-js/library/fn/global.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/library/fn/global.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/es7.global */ "../node_modules/core-js/library/modules/es7.global.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "../node_modules/core-js/library/modules/_core.js").global;

/***/ }),

/***/ "../node_modules/core-js/library/modules/_a-function.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_a-function.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_an-object.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_an-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/library/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_core.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/library/modules/_core.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.10'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "../node_modules/core-js/library/modules/_ctx.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/library/modules/_ctx.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/library/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_descriptors.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_descriptors.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "../node_modules/core-js/library/modules/_dom-create.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_dom-create.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/library/modules/_is-object.js");

var document = __webpack_require__(/*! ./_global */ "../node_modules/core-js/library/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_export.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/library/modules/_export.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/library/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/library/modules/_core.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/library/modules/_ctx.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/library/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/library/modules/_has.js");

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var IS_WRAP = type & $export.W;
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE];
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] : (global[name] || {})[PROTOTYPE];
  var key, own, out;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    if (own && has(exports, key)) continue; // export native or passed

    out = own ? target[key] : source[key]; // prevent global pollution for namespaces

    exports[key] = IS_GLOBAL && typeof target[key] != 'function' ? source[key] // bind timers to global for call from export context
    : IS_BIND && own ? ctx(out, global) // wrap global constructors for prevent change them in library
    : IS_WRAP && target[key] == out ? function (C) {
      var F = function F(a, b, c) {
        if (this instanceof C) {
          switch (arguments.length) {
            case 0:
              return new C();

            case 1:
              return new C(a);

            case 2:
              return new C(a, b);
          }

          return new C(a, b, c);
        }

        return C.apply(this, arguments);
      };

      F[PROTOTYPE] = C[PROTOTYPE];
      return F; // make static versions for prototype methods
    }(out) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // export proto methods to core.%CONSTRUCTOR%.methods.%NAME%

    if (IS_PROTO) {
      (exports.virtual || (exports.virtual = {}))[key] = out; // export proto methods to core.%CONSTRUCTOR%.prototype.%NAME%

      if (type & $export.R && expProto && !expProto[key]) hide(expProto, key, out);
    }
  }
}; // type bitmap


$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "../node_modules/core-js/library/modules/_fails.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/library/modules/_fails.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_global.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/library/modules/_global.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "../node_modules/core-js/library/modules/_has.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/library/modules/_has.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_hide.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/library/modules/_hide.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/library/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/library/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/library/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_ie8-dom-define.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_ie8-dom-define.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/library/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/library/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "../node_modules/core-js/library/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "../node_modules/core-js/library/modules/_is-object.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_is-object.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_object-dp.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_object-dp.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/library/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "../node_modules/core-js/library/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/library/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/library/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_property-desc.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_property-desc.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/_to-primitive.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/library/modules/_to-primitive.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/library/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "../node_modules/core-js/library/modules/es7.global.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/library/modules/es7.global.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-global
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/library/modules/_export.js");

$export($export.G, {
  global: __webpack_require__(/*! ./_global */ "../node_modules/core-js/library/modules/_global.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/_a-function.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_a-function.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it) {
  if (typeof it != 'function') throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_a-number-value.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_a-number-value.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

module.exports = function (it, msg) {
  if (typeof it != 'number' && cof(it) != 'Number') throw TypeError(msg);
  return +it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_add-to-unscopables.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_add-to-unscopables.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('unscopables');

var ArrayProto = Array.prototype;
if (ArrayProto[UNSCOPABLES] == undefined) __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")(ArrayProto, UNSCOPABLES, {});

module.exports = function (key) {
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_advance-string-index.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_advance-string-index.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var at = __webpack_require__(/*! ./_string-at */ "../node_modules/core-js/modules/_string-at.js")(true); // `AdvanceStringIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-advancestringindex


module.exports = function (S, index, unicode) {
  return index + (unicode ? at(S, index).length : 1);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_an-instance.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_an-instance.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (it, Constructor, name, forbiddenField) {
  if (!(it instanceof Constructor) || forbiddenField !== undefined && forbiddenField in it) {
    throw TypeError(name + ': incorrect invocation!');
  }

  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_an-object.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_an-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

module.exports = function (it) {
  if (!isObject(it)) throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-copy-within.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_array-copy-within.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = [].copyWithin || function copyWithin(target
/* = 0 */
, start
/* = 0, end = @length */
) {
  var O = toObject(this);
  var len = toLength(O.length);
  var to = toAbsoluteIndex(target, len);
  var from = toAbsoluteIndex(start, len);
  var end = arguments.length > 2 ? arguments[2] : undefined;
  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);
  var inc = 1;

  if (from < to && to < from + count) {
    inc = -1;
    from += count - 1;
    to += count - 1;
  }

  while (count-- > 0) {
    if (from in O) O[to] = O[from];else delete O[to];
    to += inc;
    from += inc;
  }

  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-fill.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_array-fill.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)


var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = function fill(value
/* , start = 0, end = @length */
) {
  var O = toObject(this);
  var length = toLength(O.length);
  var aLen = arguments.length;
  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);
  var end = aLen > 2 ? arguments[2] : undefined;
  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);

  while (endPos > index) {
    O[index++] = value;
  }

  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-includes.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_array-includes.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// false -> Array#indexOf
// true  -> Array#includes
var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

module.exports = function (IS_INCLUDES) {
  return function ($this, el, fromIndex) {
    var O = toIObject($this);
    var length = toLength(O.length);
    var index = toAbsoluteIndex(fromIndex, length);
    var value; // Array#includes uses SameValueZero equality algorithm
    // eslint-disable-next-line no-self-compare

    if (IS_INCLUDES && el != el) while (length > index) {
      value = O[index++]; // eslint-disable-next-line no-self-compare

      if (value != value) return true; // Array#indexOf ignores holes, Array#includes - not
    } else for (; length > index; index++) {
      if (IS_INCLUDES || index in O) {
        if (O[index] === el) return IS_INCLUDES || index || 0;
      }
    }
    return !IS_INCLUDES && -1;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-methods.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_array-methods.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var asc = __webpack_require__(/*! ./_array-species-create */ "../node_modules/core-js/modules/_array-species-create.js");

module.exports = function (TYPE, $create) {
  var IS_MAP = TYPE == 1;
  var IS_FILTER = TYPE == 2;
  var IS_SOME = TYPE == 3;
  var IS_EVERY = TYPE == 4;
  var IS_FIND_INDEX = TYPE == 6;
  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
  var create = $create || asc;
  return function ($this, callbackfn, that) {
    var O = toObject($this);
    var self = IObject(O);
    var f = ctx(callbackfn, that, 3);
    var length = toLength(self.length);
    var index = 0;
    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
    var val, res;

    for (; length > index; index++) {
      if (NO_HOLES || index in self) {
        val = self[index];
        res = f(val, index, O);

        if (TYPE) {
          if (IS_MAP) result[index] = res; // map
          else if (res) switch (TYPE) {
              case 3:
                return true;
              // some

              case 5:
                return val;
              // find

              case 6:
                return index;
              // findIndex

              case 2:
                result.push(val);
              // filter
            } else if (IS_EVERY) return false; // every
        }
      }
    }

    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-reduce.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_array-reduce.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = function (that, callbackfn, aLen, memo, isRight) {
  aFunction(callbackfn);
  var O = toObject(that);
  var self = IObject(O);
  var length = toLength(O.length);
  var index = isRight ? length - 1 : 0;
  var i = isRight ? -1 : 1;
  if (aLen < 2) for (;;) {
    if (index in self) {
      memo = self[index];
      index += i;
      break;
    }

    index += i;

    if (isRight ? index < 0 : length <= index) {
      throw TypeError('Reduce of empty array with no initial value');
    }
  }

  for (; isRight ? index >= 0 : length > index; index += i) {
    if (index in self) {
      memo = callbackfn(memo, self[index], index, O);
    }
  }

  return memo;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-species-constructor.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/_array-species-constructor.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var isArray = __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species');

module.exports = function (original) {
  var C;

  if (isArray(original)) {
    C = original.constructor; // cross-realm fallback

    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;

    if (isObject(C)) {
      C = C[SPECIES];
      if (C === null) C = undefined;
    }
  }

  return C === undefined ? Array : C;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_array-species-create.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_array-species-create.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(/*! ./_array-species-constructor */ "../node_modules/core-js/modules/_array-species-constructor.js");

module.exports = function (original, length) {
  return new (speciesConstructor(original))(length);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_bind.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_bind.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var invoke = __webpack_require__(/*! ./_invoke */ "../node_modules/core-js/modules/_invoke.js");

var arraySlice = [].slice;
var factories = {};

var construct = function construct(F, len, args) {
  if (!(len in factories)) {
    for (var n = [], i = 0; i < len; i++) {
      n[i] = 'a[' + i + ']';
    } // eslint-disable-next-line no-new-func


    factories[len] = Function('F,a', 'return new F(' + n.join(',') + ')');
  }

  return factories[len](F, args);
};

module.exports = Function.bind || function bind(that
/* , ...args */
) {
  var fn = aFunction(this);
  var partArgs = arraySlice.call(arguments, 1);

  var bound = function bound()
  /* args... */
  {
    var args = partArgs.concat(arraySlice.call(arguments));
    return this instanceof bound ? construct(fn, args.length, args) : invoke(fn, args, that);
  };

  if (isObject(fn.prototype)) bound.prototype = fn.prototype;
  return bound;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_classof.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_classof.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// getting tag from 19.1.3.6 Object.prototype.toString()
var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var TAG = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toStringTag'); // ES3 wrong here


var ARG = cof(function () {
  return arguments;
}()) == 'Arguments'; // fallback for IE11 Script Access Denied error

var tryGet = function tryGet(it, key) {
  try {
    return it[key];
  } catch (e) {
    /* empty */
  }
};

module.exports = function (it) {
  var O, T, B;
  return it === undefined ? 'Undefined' : it === null ? 'Null' // @@toStringTag case
  : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T // builtinTag case
  : ARG ? cof(O) // ES3 arguments fallback
  : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_cof.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_cof.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function (it) {
  return toString.call(it).slice(8, -1);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_collection-strong.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_collection-strong.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var $iterDefine = __webpack_require__(/*! ./_iter-define */ "../node_modules/core-js/modules/_iter-define.js");

var step = __webpack_require__(/*! ./_iter-step */ "../node_modules/core-js/modules/_iter-step.js");

var setSpecies = __webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var fastKey = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").fastKey;

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var SIZE = DESCRIPTORS ? '_s' : 'size';

var getEntry = function getEntry(that, key) {
  // fast case
  var index = fastKey(key);
  var entry;
  if (index !== 'F') return that._i[index]; // frozen object case

  for (entry = that._f; entry; entry = entry.n) {
    if (entry.k == key) return entry;
  }
};

module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = create(null); // index

      that._f = undefined; // first entry

      that._l = undefined; // last entry

      that[SIZE] = 0; // size

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.1.3.1 Map.prototype.clear()
      // 23.2.3.2 Set.prototype.clear()
      clear: function clear() {
        for (var that = validate(this, NAME), data = that._i, entry = that._f; entry; entry = entry.n) {
          entry.r = true;
          if (entry.p) entry.p = entry.p.n = undefined;
          delete data[entry.i];
        }

        that._f = that._l = undefined;
        that[SIZE] = 0;
      },
      // 23.1.3.3 Map.prototype.delete(key)
      // 23.2.3.4 Set.prototype.delete(value)
      'delete': function _delete(key) {
        var that = validate(this, NAME);
        var entry = getEntry(that, key);

        if (entry) {
          var next = entry.n;
          var prev = entry.p;
          delete that._i[entry.i];
          entry.r = true;
          if (prev) prev.n = next;
          if (next) next.p = prev;
          if (that._f == entry) that._f = next;
          if (that._l == entry) that._l = prev;
          that[SIZE]--;
        }

        return !!entry;
      },
      // 23.2.3.6 Set.prototype.forEach(callbackfn, thisArg = undefined)
      // 23.1.3.5 Map.prototype.forEach(callbackfn, thisArg = undefined)
      forEach: function forEach(callbackfn
      /* , that = undefined */
      ) {
        validate(this, NAME);
        var f = ctx(callbackfn, arguments.length > 1 ? arguments[1] : undefined, 3);
        var entry;

        while (entry = entry ? entry.n : this._f) {
          f(entry.v, entry.k, this); // revert to the last existing entry

          while (entry && entry.r) {
            entry = entry.p;
          }
        }
      },
      // 23.1.3.7 Map.prototype.has(key)
      // 23.2.3.7 Set.prototype.has(value)
      has: function has(key) {
        return !!getEntry(validate(this, NAME), key);
      }
    });
    if (DESCRIPTORS) dP(C.prototype, 'size', {
      get: function get() {
        return validate(this, NAME)[SIZE];
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var entry = getEntry(that, key);
    var prev, index; // change existing entry

    if (entry) {
      entry.v = value; // create new entry
    } else {
      that._l = entry = {
        i: index = fastKey(key, true),
        // <- index
        k: key,
        // <- key
        v: value,
        // <- value
        p: prev = that._l,
        // <- previous entry
        n: undefined,
        // <- next entry
        r: false // <- removed

      };
      if (!that._f) that._f = entry;
      if (prev) prev.n = entry;
      that[SIZE]++; // add to index

      if (index !== 'F') that._i[index] = entry;
    }

    return that;
  },
  getEntry: getEntry,
  setStrong: function setStrong(C, NAME, IS_MAP) {
    // add .keys, .values, .entries, [@@iterator]
    // 23.1.3.4, 23.1.3.8, 23.1.3.11, 23.1.3.12, 23.2.3.5, 23.2.3.8, 23.2.3.10, 23.2.3.11
    $iterDefine(C, NAME, function (iterated, kind) {
      this._t = validate(iterated, NAME); // target

      this._k = kind; // kind

      this._l = undefined; // previous
    }, function () {
      var that = this;
      var kind = that._k;
      var entry = that._l; // revert to the last existing entry

      while (entry && entry.r) {
        entry = entry.p;
      } // get next entry


      if (!that._t || !(that._l = entry = entry ? entry.n : that._t._f)) {
        // or finish the iteration
        that._t = undefined;
        return step(1);
      } // return step by kind


      if (kind == 'keys') return step(0, entry.k);
      if (kind == 'values') return step(0, entry.v);
      return step(0, [entry.k, entry.v]);
    }, IS_MAP ? 'entries' : 'values', !IS_MAP, true); // add [@@species], 23.1.2.2, 23.2.2.2

    setSpecies(NAME);
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_collection-weak.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_collection-weak.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var getWeak = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").getWeak;

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js");

var $has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var arrayFind = createArrayMethod(5);
var arrayFindIndex = createArrayMethod(6);
var id = 0; // fallback for uncaught frozen keys

var uncaughtFrozenStore = function uncaughtFrozenStore(that) {
  return that._l || (that._l = new UncaughtFrozenStore());
};

var UncaughtFrozenStore = function UncaughtFrozenStore() {
  this.a = [];
};

var findUncaughtFrozen = function findUncaughtFrozen(store, key) {
  return arrayFind(store.a, function (it) {
    return it[0] === key;
  });
};

UncaughtFrozenStore.prototype = {
  get: function get(key) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) return entry[1];
  },
  has: function has(key) {
    return !!findUncaughtFrozen(this, key);
  },
  set: function set(key, value) {
    var entry = findUncaughtFrozen(this, key);
    if (entry) entry[1] = value;else this.a.push([key, value]);
  },
  'delete': function _delete(key) {
    var index = arrayFindIndex(this.a, function (it) {
      return it[0] === key;
    });
    if (~index) this.a.splice(index, 1);
    return !!~index;
  }
};
module.exports = {
  getConstructor: function getConstructor(wrapper, NAME, IS_MAP, ADDER) {
    var C = wrapper(function (that, iterable) {
      anInstance(that, C, NAME, '_i');
      that._t = NAME; // collection type

      that._i = id++; // collection id

      that._l = undefined; // leak store for uncaught frozen objects

      if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
    });
    redefineAll(C.prototype, {
      // 23.3.3.2 WeakMap.prototype.delete(key)
      // 23.4.3.3 WeakSet.prototype.delete(value)
      'delete': function _delete(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME))['delete'](key);
        return data && $has(data, this._i) && delete data[this._i];
      },
      // 23.3.3.4 WeakMap.prototype.has(key)
      // 23.4.3.4 WeakSet.prototype.has(value)
      has: function has(key) {
        if (!isObject(key)) return false;
        var data = getWeak(key);
        if (data === true) return uncaughtFrozenStore(validate(this, NAME)).has(key);
        return data && $has(data, this._i);
      }
    });
    return C;
  },
  def: function def(that, key, value) {
    var data = getWeak(anObject(key), true);
    if (data === true) uncaughtFrozenStore(that).set(key, value);else data[that._i] = value;
    return that;
  },
  ufstore: uncaughtFrozenStore
};

/***/ }),

/***/ "../node_modules/core-js/modules/_collection.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_collection.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "../node_modules/core-js/modules/_inherit-if-required.js");

module.exports = function (NAME, wrapper, methods, common, IS_MAP, IS_WEAK) {
  var Base = global[NAME];
  var C = Base;
  var ADDER = IS_MAP ? 'set' : 'add';
  var proto = C && C.prototype;
  var O = {};

  var fixMethod = function fixMethod(KEY) {
    var fn = proto[KEY];
    redefine(proto, KEY, KEY == 'delete' ? function (a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'has' ? function has(a) {
      return IS_WEAK && !isObject(a) ? false : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'get' ? function get(a) {
      return IS_WEAK && !isObject(a) ? undefined : fn.call(this, a === 0 ? 0 : a);
    } : KEY == 'add' ? function add(a) {
      fn.call(this, a === 0 ? 0 : a);
      return this;
    } : function set(a, b) {
      fn.call(this, a === 0 ? 0 : a, b);
      return this;
    });
  };

  if (typeof C != 'function' || !(IS_WEAK || proto.forEach && !fails(function () {
    new C().entries().next();
  }))) {
    // create collection constructor
    C = common.getConstructor(wrapper, NAME, IS_MAP, ADDER);
    redefineAll(C.prototype, methods);
    meta.NEED = true;
  } else {
    var instance = new C(); // early implementations not supports chaining

    var HASNT_CHAINING = instance[ADDER](IS_WEAK ? {} : -0, 1) != instance; // V8 ~  Chromium 40- weak-collections throws on primitives, but should return false

    var THROWS_ON_PRIMITIVES = fails(function () {
      instance.has(1);
    }); // most early implementations doesn't supports iterables, most modern - not close it correctly

    var ACCEPT_ITERABLES = $iterDetect(function (iter) {
      new C(iter);
    }); // eslint-disable-line no-new
    // for early implementations -0 and +0 not the same

    var BUGGY_ZERO = !IS_WEAK && fails(function () {
      // V8 ~ Chromium 42- fails only with 5+ elements
      var $instance = new C();
      var index = 5;

      while (index--) {
        $instance[ADDER](index, index);
      }

      return !$instance.has(-0);
    });

    if (!ACCEPT_ITERABLES) {
      C = wrapper(function (target, iterable) {
        anInstance(target, C, NAME);
        var that = inheritIfRequired(new Base(), target, C);
        if (iterable != undefined) forOf(iterable, IS_MAP, that[ADDER], that);
        return that;
      });
      C.prototype = proto;
      proto.constructor = C;
    }

    if (THROWS_ON_PRIMITIVES || BUGGY_ZERO) {
      fixMethod('delete');
      fixMethod('has');
      IS_MAP && fixMethod('get');
    }

    if (BUGGY_ZERO || HASNT_CHAINING) fixMethod(ADDER); // weak collections should not contains .clear method

    if (IS_WEAK && proto.clear) delete proto.clear;
  }

  setToStringTag(C, NAME);
  O[NAME] = C;
  $export($export.G + $export.W + $export.F * (C != Base), O);
  if (!IS_WEAK) common.setStrong(C, NAME, IS_MAP);
  return C;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_core.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_core.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var core = module.exports = {
  version: '2.6.10'
};
if (typeof __e == 'number') __e = core; // eslint-disable-line no-undef

/***/ }),

/***/ "../node_modules/core-js/modules/_create-property.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_create-property.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $defineProperty = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

module.exports = function (object, index, value) {
  if (index in object) $defineProperty.f(object, index, createDesc(0, value));else object[index] = value;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_ctx.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_ctx.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

module.exports = function (fn, that, length) {
  aFunction(fn);
  if (that === undefined) return fn;

  switch (length) {
    case 1:
      return function (a) {
        return fn.call(that, a);
      };

    case 2:
      return function (a, b) {
        return fn.call(that, a, b);
      };

    case 3:
      return function (a, b, c) {
        return fn.call(that, a, b, c);
      };
  }

  return function ()
  /* ...args */
  {
    return fn.apply(that, arguments);
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_date-to-iso-string.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_date-to-iso-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var getTime = Date.prototype.getTime;
var $toISOString = Date.prototype.toISOString;

var lz = function lz(num) {
  return num > 9 ? num : '0' + num;
}; // PhantomJS / old WebKit has a broken implementations


module.exports = fails(function () {
  return $toISOString.call(new Date(-5e13 - 1)) != '0385-07-25T07:06:39.999Z';
}) || !fails(function () {
  $toISOString.call(new Date(NaN));
}) ? function toISOString() {
  if (!isFinite(getTime.call(this))) throw RangeError('Invalid time value');
  var d = this;
  var y = d.getUTCFullYear();
  var m = d.getUTCMilliseconds();
  var s = y < 0 ? '-' : y > 9999 ? '+' : '';
  return s + ('00000' + Math.abs(y)).slice(s ? -6 : -4) + '-' + lz(d.getUTCMonth() + 1) + '-' + lz(d.getUTCDate()) + 'T' + lz(d.getUTCHours()) + ':' + lz(d.getUTCMinutes()) + ':' + lz(d.getUTCSeconds()) + '.' + (m > 99 ? m : '0' + lz(m)) + 'Z';
} : $toISOString;

/***/ }),

/***/ "../node_modules/core-js/modules/_date-to-primitive.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_date-to-primitive.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var NUMBER = 'number';

module.exports = function (hint) {
  if (hint !== 'string' && hint !== NUMBER && hint !== 'default') throw TypeError('Incorrect hint');
  return toPrimitive(anObject(this), hint != NUMBER);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_defined.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_defined.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function (it) {
  if (it == undefined) throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_descriptors.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_descriptors.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty({}, 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "../node_modules/core-js/modules/_dom-create.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_dom-create.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var document = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").document; // typeof document.createElement is 'object' in old IE


var is = isObject(document) && isObject(document.createElement);

module.exports = function (it) {
  return is ? document.createElement(it) : {};
};

/***/ }),

/***/ "../node_modules/core-js/modules/_enum-bug-keys.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_enum-bug-keys.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// IE 8- don't enum bug keys
module.exports = 'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'.split(',');

/***/ }),

/***/ "../node_modules/core-js/modules/_enum-keys.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_enum-keys.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all enumerable object keys, includes symbols
var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js");

module.exports = function (it) {
  var result = getKeys(it);
  var getSymbols = gOPS.f;

  if (getSymbols) {
    var symbols = getSymbols(it);
    var isEnum = pIE.f;
    var i = 0;
    var key;

    while (symbols.length > i) {
      if (isEnum.call(it, key = symbols[i++])) result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_export.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_export.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var PROTOTYPE = 'prototype';

var $export = function $export(type, name, source) {
  var IS_FORCED = type & $export.F;
  var IS_GLOBAL = type & $export.G;
  var IS_STATIC = type & $export.S;
  var IS_PROTO = type & $export.P;
  var IS_BIND = type & $export.B;
  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];
  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});
  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});
  var key, own, out, exp;
  if (IS_GLOBAL) source = name;

  for (key in source) {
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined; // export native or passed

    out = (own ? target : source)[key]; // bind timers to global for call from export context

    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out; // extend global

    if (target) redefine(target, key, out, type & $export.U); // export

    if (exports[key] != out) hide(exports, key, exp);
    if (IS_PROTO && expProto[key] != out) expProto[key] = out;
  }
};

global.core = core; // type bitmap

$export.F = 1; // forced

$export.G = 2; // global

$export.S = 4; // static

$export.P = 8; // proto

$export.B = 16; // bind

$export.W = 32; // wrap

$export.U = 64; // safe

$export.R = 128; // real proto method for `library`

module.exports = $export;

/***/ }),

/***/ "../node_modules/core-js/modules/_fails-is-regexp.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_fails-is-regexp.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var MATCH = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('match');

module.exports = function (KEY) {
  var re = /./;

  try {
    '/./'[KEY](re);
  } catch (e) {
    try {
      re[MATCH] = false;
      return !'/./'[KEY](re);
    } catch (f) {
      /* empty */
    }
  }

  return true;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_fails.js":
/*!*************************************************!*\
  !*** ../node_modules/core-js/modules/_fails.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return !!exec();
  } catch (e) {
    return true;
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_fix-re-wks.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_fix-re-wks.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.exec */ "../node_modules/core-js/modules/es6.regexp.exec.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "../node_modules/core-js/modules/_regexp-exec.js");

var SPECIES = wks('species');
var REPLACE_SUPPORTS_NAMED_GROUPS = !fails(function () {
  // #replace needs built-in support for named groups.
  // #match works fine because it just return the exec results, even if it has
  // a "grops" property.
  var re = /./;

  re.exec = function () {
    var result = [];
    result.groups = {
      a: '7'
    };
    return result;
  };

  return ''.replace(re, '$<a>') !== '7';
});

var SPLIT_WORKS_WITH_OVERWRITTEN_EXEC = function () {
  // Chrome 51 has a buggy "split" implementation when RegExp#exec !== nativeExec
  var re = /(?:)/;
  var originalExec = re.exec;

  re.exec = function () {
    return originalExec.apply(this, arguments);
  };

  var result = 'ab'.split(re);
  return result.length === 2 && result[0] === 'a' && result[1] === 'b';
}();

module.exports = function (KEY, length, exec) {
  var SYMBOL = wks(KEY);
  var DELEGATES_TO_SYMBOL = !fails(function () {
    // String methods call symbol-named RegEp methods
    var O = {};

    O[SYMBOL] = function () {
      return 7;
    };

    return ''[KEY](O) != 7;
  });
  var DELEGATES_TO_EXEC = DELEGATES_TO_SYMBOL ? !fails(function () {
    // Symbol-named RegExp methods call .exec
    var execCalled = false;
    var re = /a/;

    re.exec = function () {
      execCalled = true;
      return null;
    };

    if (KEY === 'split') {
      // RegExp[@@split] doesn't call the regex's exec method, but first creates
      // a new one. We need to return the patched regex when creating the new one.
      re.constructor = {};

      re.constructor[SPECIES] = function () {
        return re;
      };
    }

    re[SYMBOL]('');
    return !execCalled;
  }) : undefined;

  if (!DELEGATES_TO_SYMBOL || !DELEGATES_TO_EXEC || KEY === 'replace' && !REPLACE_SUPPORTS_NAMED_GROUPS || KEY === 'split' && !SPLIT_WORKS_WITH_OVERWRITTEN_EXEC) {
    var nativeRegExpMethod = /./[SYMBOL];
    var fns = exec(defined, SYMBOL, ''[KEY], function maybeCallNative(nativeMethod, regexp, str, arg2, forceStringMethod) {
      if (regexp.exec === regexpExec) {
        if (DELEGATES_TO_SYMBOL && !forceStringMethod) {
          // The native String method already delegates to @@method (this
          // polyfilled function), leasing to infinite recursion.
          // We avoid it by directly calling the native @@method method.
          return {
            done: true,
            value: nativeRegExpMethod.call(regexp, str, arg2)
          };
        }

        return {
          done: true,
          value: nativeMethod.call(str, regexp, arg2)
        };
      }

      return {
        done: false
      };
    });
    var strfn = fns[0];
    var rxfn = fns[1];
    redefine(String.prototype, KEY, strfn);
    hide(RegExp.prototype, SYMBOL, length == 2 // 21.2.5.8 RegExp.prototype[@@replace](string, replaceValue)
    // 21.2.5.11 RegExp.prototype[@@split](string, limit)
    ? function (string, arg) {
      return rxfn.call(string, this, arg);
    } // 21.2.5.6 RegExp.prototype[@@match](string)
    // 21.2.5.9 RegExp.prototype[@@search](string)
    : function (string) {
      return rxfn.call(string, this);
    });
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_flags.js":
/*!*************************************************!*\
  !*** ../node_modules/core-js/modules/_flags.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.2.5.3 get RegExp.prototype.flags

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

module.exports = function () {
  var that = anObject(this);
  var result = '';
  if (that.global) result += 'g';
  if (that.ignoreCase) result += 'i';
  if (that.multiline) result += 'm';
  if (that.unicode) result += 'u';
  if (that.sticky) result += 'y';
  return result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_flatten-into-array.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_flatten-into-array.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-FlattenIntoArray

var isArray = __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var IS_CONCAT_SPREADABLE = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('isConcatSpreadable');

function flattenIntoArray(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? ctx(mapper, thisArg, 3) : false;
  var element, spreadable;

  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      spreadable = false;

      if (isObject(element)) {
        spreadable = element[IS_CONCAT_SPREADABLE];
        spreadable = spreadable !== undefined ? !!spreadable : isArray(element);
      }

      if (spreadable && depth > 0) {
        targetIndex = flattenIntoArray(target, original, element, toLength(element.length), targetIndex, depth - 1) - 1;
      } else {
        if (targetIndex >= 0x1fffffffffffff) throw TypeError();
        target[targetIndex] = element;
      }

      targetIndex++;
    }

    sourceIndex++;
  }

  return targetIndex;
}

module.exports = flattenIntoArray;

/***/ }),

/***/ "../node_modules/core-js/modules/_for-of.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_for-of.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var call = __webpack_require__(/*! ./_iter-call */ "../node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "../node_modules/core-js/modules/_is-array-iter.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "../node_modules/core-js/modules/core.get-iterator-method.js");

var BREAK = {};
var RETURN = {};

var exports = module.exports = function (iterable, entries, fn, that, ITERATOR) {
  var iterFn = ITERATOR ? function () {
    return iterable;
  } : getIterFn(iterable);
  var f = ctx(fn, that, entries ? 2 : 1);
  var index = 0;
  var length, step, iterator, result;
  if (typeof iterFn != 'function') throw TypeError(iterable + ' is not iterable!'); // fast case for arrays with default iterator

  if (isArrayIter(iterFn)) for (length = toLength(iterable.length); length > index; index++) {
    result = entries ? f(anObject(step = iterable[index])[0], step[1]) : f(iterable[index]);
    if (result === BREAK || result === RETURN) return result;
  } else for (iterator = iterFn.call(iterable); !(step = iterator.next()).done;) {
    result = call(iterator, f, step.value, entries);
    if (result === BREAK || result === RETURN) return result;
  }
};

exports.BREAK = BREAK;
exports.RETURN = RETURN;

/***/ }),

/***/ "../node_modules/core-js/modules/_function-to-string.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/_function-to-string.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js")('native-function-to-string', Function.toString);

/***/ }),

/***/ "../node_modules/core-js/modules/_global.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_global.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math ? window : typeof self != 'undefined' && self.Math == Math ? self // eslint-disable-next-line no-new-func
: Function('return this')();
if (typeof __g == 'number') __g = global; // eslint-disable-line no-undef

/***/ }),

/***/ "../node_modules/core-js/modules/_has.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_has.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;

module.exports = function (it, key) {
  return hasOwnProperty.call(it, key);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_hide.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_hide.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? function (object, key, value) {
  return dP.f(object, key, createDesc(1, value));
} : function (object, key, value) {
  object[key] = value;
  return object;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_html.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_html.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var document = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").document;

module.exports = document && document.documentElement;

/***/ }),

/***/ "../node_modules/core-js/modules/_ie8-dom-define.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_ie8-dom-define.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return Object.defineProperty(__webpack_require__(/*! ./_dom-create */ "../node_modules/core-js/modules/_dom-create.js")('div'), 'a', {
    get: function get() {
      return 7;
    }
  }).a != 7;
});

/***/ }),

/***/ "../node_modules/core-js/modules/_inherit-if-required.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_inherit-if-required.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var setPrototypeOf = __webpack_require__(/*! ./_set-proto */ "../node_modules/core-js/modules/_set-proto.js").set;

module.exports = function (that, target, C) {
  var S = target.constructor;
  var P;

  if (S !== C && typeof S == 'function' && (P = S.prototype) !== C.prototype && isObject(P) && setPrototypeOf) {
    setPrototypeOf(that, P);
  }

  return that;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_invoke.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_invoke.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// fast apply, http://jsperf.lnkit.com/fast-apply/5
module.exports = function (fn, args, that) {
  var un = that === undefined;

  switch (args.length) {
    case 0:
      return un ? fn() : fn.call(that);

    case 1:
      return un ? fn(args[0]) : fn.call(that, args[0]);

    case 2:
      return un ? fn(args[0], args[1]) : fn.call(that, args[0], args[1]);

    case 3:
      return un ? fn(args[0], args[1], args[2]) : fn.call(that, args[0], args[1], args[2]);

    case 4:
      return un ? fn(args[0], args[1], args[2], args[3]) : fn.call(that, args[0], args[1], args[2], args[3]);
  }

  return fn.apply(that, args);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iobject.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_iobject.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js"); // eslint-disable-next-line no-prototype-builtins


module.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-array-iter.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_is-array-iter.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// check on default Array iterator
var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var ArrayProto = Array.prototype;

module.exports = function (it) {
  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-array.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_is-array.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

module.exports = Array.isArray || function isArray(arg) {
  return cof(arg) == 'Array';
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-integer.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_is-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var floor = Math.floor;

module.exports = function isInteger(it) {
  return !isObject(it) && isFinite(it) && floor(it) === it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-object.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_is-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

module.exports = function (it) {
  return _typeof(it) === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),

/***/ "../node_modules/core-js/modules/_is-regexp.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_is-regexp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.8 IsRegExp(argument)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var MATCH = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('match');

module.exports = function (it) {
  var isRegExp;
  return isObject(it) && ((isRegExp = it[MATCH]) !== undefined ? !!isRegExp : cof(it) == 'RegExp');
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-call.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-call.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// call something on iterator step with safe closing on error
var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

module.exports = function (iterator, fn, value, entries) {
  try {
    return entries ? fn(anObject(value)[0], value[1]) : fn(value); // 7.4.6 IteratorClose(iterator, completion)
  } catch (e) {
    var ret = iterator['return'];
    if (ret !== undefined) anObject(ret.call(iterator));
    throw e;
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-create.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-create.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var descriptor = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var IteratorPrototype = {}; // 25.1.2.1.1 %IteratorPrototype%[@@iterator]()

__webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")(IteratorPrototype, __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator'), function () {
  return this;
});

module.exports = function (Constructor, NAME, next) {
  Constructor.prototype = create(IteratorPrototype, {
    next: descriptor(1, next)
  });
  setToStringTag(Constructor, NAME + ' Iterator');
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-define.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-define.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var $iterCreate = __webpack_require__(/*! ./_iter-create */ "../node_modules/core-js/modules/_iter-create.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`

var FF_ITERATOR = '@@iterator';
var KEYS = 'keys';
var VALUES = 'values';

var returnThis = function returnThis() {
  return this;
};

module.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {
  $iterCreate(Constructor, NAME, next);

  var getMethod = function getMethod(kind) {
    if (!BUGGY && kind in proto) return proto[kind];

    switch (kind) {
      case KEYS:
        return function keys() {
          return new Constructor(this, kind);
        };

      case VALUES:
        return function values() {
          return new Constructor(this, kind);
        };
    }

    return function entries() {
      return new Constructor(this, kind);
    };
  };

  var TAG = NAME + ' Iterator';
  var DEF_VALUES = DEFAULT == VALUES;
  var VALUES_BUG = false;
  var proto = Base.prototype;
  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];
  var $default = $native || getMethod(DEFAULT);
  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;
  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;
  var methods, key, IteratorPrototype; // Fix native

  if ($anyNative) {
    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));

    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {
      // Set @@toStringTag to native iterators
      setToStringTag(IteratorPrototype, TAG, true); // fix for some old engines

      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);
    }
  } // fix Array#{values, @@iterator}.name in V8 / FF


  if (DEF_VALUES && $native && $native.name !== VALUES) {
    VALUES_BUG = true;

    $default = function values() {
      return $native.call(this);
    };
  } // Define iterator


  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {
    hide(proto, ITERATOR, $default);
  } // Plug for library


  Iterators[NAME] = $default;
  Iterators[TAG] = returnThis;

  if (DEFAULT) {
    methods = {
      values: DEF_VALUES ? $default : getMethod(VALUES),
      keys: IS_SET ? $default : getMethod(KEYS),
      entries: $entries
    };
    if (FORCED) for (key in methods) {
      if (!(key in proto)) redefine(proto, key, methods[key]);
    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);
  }

  return methods;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-detect.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-detect.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var SAFE_CLOSING = false;

try {
  var riter = [7][ITERATOR]();

  riter['return'] = function () {
    SAFE_CLOSING = true;
  }; // eslint-disable-next-line no-throw-literal


  Array.from(riter, function () {
    throw 2;
  });
} catch (e) {
  /* empty */
}

module.exports = function (exec, skipClosing) {
  if (!skipClosing && !SAFE_CLOSING) return false;
  var safe = false;

  try {
    var arr = [7];
    var iter = arr[ITERATOR]();

    iter.next = function () {
      return {
        done: safe = true
      };
    };

    arr[ITERATOR] = function () {
      return iter;
    };

    exec(arr);
  } catch (e) {
    /* empty */
  }

  return safe;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iter-step.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_iter-step.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (done, value) {
  return {
    value: value,
    done: !!done
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_iterators.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_iterators.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {};

/***/ }),

/***/ "../node_modules/core-js/modules/_library.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_library.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = false;

/***/ }),

/***/ "../node_modules/core-js/modules/_math-expm1.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_math-expm1.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.14 Math.expm1(x)
var $expm1 = Math.expm1;
module.exports = !$expm1 // Old FF bug
|| $expm1(10) > 22025.465794806719 || $expm1(10) < 22025.4657948067165168 // Tor Browser bug
|| $expm1(-2e-17) != -2e-17 ? function expm1(x) {
  return (x = +x) == 0 ? x : x > -1e-6 && x < 1e-6 ? x + x * x / 2 : Math.exp(x) - 1;
} : $expm1;

/***/ }),

/***/ "../node_modules/core-js/modules/_math-fround.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_math-fround.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var sign = __webpack_require__(/*! ./_math-sign */ "../node_modules/core-js/modules/_math-sign.js");

var pow = Math.pow;
var EPSILON = pow(2, -52);
var EPSILON32 = pow(2, -23);
var MAX32 = pow(2, 127) * (2 - EPSILON32);
var MIN32 = pow(2, -126);

var roundTiesToEven = function roundTiesToEven(n) {
  return n + 1 / EPSILON - 1 / EPSILON;
};

module.exports = Math.fround || function fround(x) {
  var $abs = Math.abs(x);
  var $sign = sign(x);
  var a, result;
  if ($abs < MIN32) return $sign * roundTiesToEven($abs / MIN32 / EPSILON32) * MIN32 * EPSILON32;
  a = (1 + EPSILON32 / EPSILON) * $abs;
  result = a - (a - $abs); // eslint-disable-next-line no-self-compare

  if (result > MAX32 || result != result) return $sign * Infinity;
  return $sign * result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_math-log1p.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_math-log1p.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.20 Math.log1p(x)
module.exports = Math.log1p || function log1p(x) {
  return (x = +x) > -1e-8 && x < 1e-8 ? x - x * x / 2 : Math.log(1 + x);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_math-sign.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_math-sign.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 20.2.2.28 Math.sign(x)
module.exports = Math.sign || function sign(x) {
  // eslint-disable-next-line no-self-compare
  return (x = +x) == 0 || x != x ? x : x < 0 ? -1 : 1;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_meta.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_meta.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var META = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js")('meta');

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var setDesc = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var id = 0;

var isExtensible = Object.isExtensible || function () {
  return true;
};

var FREEZE = !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return isExtensible(Object.preventExtensions({}));
});

var setMeta = function setMeta(it) {
  setDesc(it, META, {
    value: {
      i: 'O' + ++id,
      // object ID
      w: {} // weak collections IDs

    }
  });
};

var fastKey = function fastKey(it, create) {
  // return primitive with prefix
  if (!isObject(it)) return _typeof(it) == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;

  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return 'F'; // not necessary to add metadata

    if (!create) return 'E'; // add missing metadata

    setMeta(it); // return object ID
  }

  return it[META].i;
};

var getWeak = function getWeak(it, create) {
  if (!has(it, META)) {
    // can't set metadata to uncaught frozen object
    if (!isExtensible(it)) return true; // not necessary to add metadata

    if (!create) return false; // add missing metadata

    setMeta(it); // return hash weak collections IDs
  }

  return it[META].w;
}; // add metadata on freeze-family methods calling


var onFreeze = function onFreeze(it) {
  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);
  return it;
};

var meta = module.exports = {
  KEY: META,
  NEED: false,
  fastKey: fastKey,
  getWeak: getWeak,
  onFreeze: onFreeze
};

/***/ }),

/***/ "../node_modules/core-js/modules/_microtask.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_microtask.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var macrotask = __webpack_require__(/*! ./_task */ "../node_modules/core-js/modules/_task.js").set;

var Observer = global.MutationObserver || global.WebKitMutationObserver;
var process = global.process;
var Promise = global.Promise;
var isNode = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js")(process) == 'process';

module.exports = function () {
  var head, last, notify;

  var flush = function flush() {
    var parent, fn;
    if (isNode && (parent = process.domain)) parent.exit();

    while (head) {
      fn = head.fn;
      head = head.next;

      try {
        fn();
      } catch (e) {
        if (head) notify();else last = undefined;
        throw e;
      }
    }

    last = undefined;
    if (parent) parent.enter();
  }; // Node.js


  if (isNode) {
    notify = function notify() {
      process.nextTick(flush);
    }; // browsers with MutationObserver, except iOS Safari - https://github.com/zloirock/core-js/issues/339

  } else if (Observer && !(global.navigator && global.navigator.standalone)) {
    var toggle = true;
    var node = document.createTextNode('');
    new Observer(flush).observe(node, {
      characterData: true
    }); // eslint-disable-line no-new

    notify = function notify() {
      node.data = toggle = !toggle;
    }; // environments with maybe non-completely correct, but existent Promise

  } else if (Promise && Promise.resolve) {
    // Promise.resolve without an argument throws an error in LG WebOS 2
    var promise = Promise.resolve(undefined);

    notify = function notify() {
      promise.then(flush);
    }; // for other environments - macrotask based on:
    // - setImmediate
    // - MessageChannel
    // - window.postMessag
    // - onreadystatechange
    // - setTimeout

  } else {
    notify = function notify() {
      // strange IE + webpack dev server bug - use .call(global)
      macrotask.call(global, flush);
    };
  }

  return function (fn) {
    var task = {
      fn: fn,
      next: undefined
    };
    if (last) last.next = task;

    if (!head) {
      head = task;
      notify();
    }

    last = task;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_new-promise-capability.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/_new-promise-capability.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 25.4.1.5 NewPromiseCapability(C)

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

function PromiseCapability(C) {
  var resolve, reject;
  this.promise = new C(function ($$resolve, $$reject) {
    if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
    resolve = $$resolve;
    reject = $$reject;
  });
  this.resolve = aFunction(resolve);
  this.reject = aFunction(reject);
}

module.exports.f = function (C) {
  return new PromiseCapability(C);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-assign.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-assign.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.2.1 Object.assign(target, source, ...)

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js");

var pIE = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var $assign = Object.assign; // should work with symbols and should have deterministic property order (V8 bug)

module.exports = !$assign || __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  var A = {};
  var B = {}; // eslint-disable-next-line no-undef

  var S = Symbol();
  var K = 'abcdefghijklmnopqrst';
  A[S] = 7;
  K.split('').forEach(function (k) {
    B[k] = k;
  });
  return $assign({}, A)[S] != 7 || Object.keys($assign({}, B)).join('') != K;
}) ? function assign(target, source) {
  // eslint-disable-line no-unused-vars
  var T = toObject(target);
  var aLen = arguments.length;
  var index = 1;
  var getSymbols = gOPS.f;
  var isEnum = pIE.f;

  while (aLen > index) {
    var S = IObject(arguments[index++]);
    var keys = getSymbols ? getKeys(S).concat(getSymbols(S)) : getKeys(S);
    var length = keys.length;
    var j = 0;
    var key;

    while (length > j) {
      key = keys[j++];
      if (!DESCRIPTORS || isEnum.call(S, key)) T[key] = S[key];
    }
  }

  return T;
} : $assign;

/***/ }),

/***/ "../node_modules/core-js/modules/_object-create.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-create.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])
var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var dPs = __webpack_require__(/*! ./_object-dps */ "../node_modules/core-js/modules/_object-dps.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "../node_modules/core-js/modules/_enum-bug-keys.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "../node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var Empty = function Empty() {
  /* empty */
};

var PROTOTYPE = 'prototype'; // Create object with fake `null` prototype: use iframe Object with cleared prototype

var _createDict = function createDict() {
  // Thrash, waste and sodomy: IE GC bug
  var iframe = __webpack_require__(/*! ./_dom-create */ "../node_modules/core-js/modules/_dom-create.js")('iframe');

  var i = enumBugKeys.length;
  var lt = '<';
  var gt = '>';
  var iframeDocument;
  iframe.style.display = 'none';

  __webpack_require__(/*! ./_html */ "../node_modules/core-js/modules/_html.js").appendChild(iframe);

  iframe.src = 'javascript:'; // eslint-disable-line no-script-url
  // createDict = iframe.contentWindow.Object;
  // html.removeChild(iframe);

  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);
  iframeDocument.close();
  _createDict = iframeDocument.F;

  while (i--) {
    delete _createDict[PROTOTYPE][enumBugKeys[i]];
  }

  return _createDict();
};

module.exports = Object.create || function create(O, Properties) {
  var result;

  if (O !== null) {
    Empty[PROTOTYPE] = anObject(O);
    result = new Empty();
    Empty[PROTOTYPE] = null; // add "__proto__" for Object.getPrototypeOf polyfill

    result[IE_PROTO] = O;
  } else result = _createDict();

  return Properties === undefined ? result : dPs(result, Properties);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-dp.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_object-dp.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "../node_modules/core-js/modules/_ie8-dom-define.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var dP = Object.defineProperty;
exports.f = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? Object.defineProperty : function defineProperty(O, P, Attributes) {
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if (IE8_DOM_DEFINE) try {
    return dP(O, P, Attributes);
  } catch (e) {
    /* empty */
  }
  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');
  if ('value' in Attributes) O[P] = Attributes.value;
  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-dps.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-dps.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

module.exports = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject(O);
  var keys = getKeys(Properties);
  var length = keys.length;
  var i = 0;
  var P;

  while (length > i) {
    dP.f(O, P = keys[i++], Properties[P]);
  }

  return O;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gopd.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gopd.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pIE = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var IE8_DOM_DEFINE = __webpack_require__(/*! ./_ie8-dom-define */ "../node_modules/core-js/modules/_ie8-dom-define.js");

var gOPD = Object.getOwnPropertyDescriptor;
exports.f = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? gOPD : function getOwnPropertyDescriptor(O, P) {
  O = toIObject(O);
  P = toPrimitive(P, true);
  if (IE8_DOM_DEFINE) try {
    return gOPD(O, P);
  } catch (e) {
    /* empty */
  }
  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gopn-ext.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gopn-ext.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window
var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var toString = {}.toString;
var windowNames = (typeof window === "undefined" ? "undefined" : _typeof(window)) == 'object' && window && Object.getOwnPropertyNames ? Object.getOwnPropertyNames(window) : [];

var getWindowNames = function getWindowNames(it) {
  try {
    return gOPN(it);
  } catch (e) {
    return windowNames.slice();
  }
};

module.exports.f = function getOwnPropertyNames(it) {
  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gopn.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gopn.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "../node_modules/core-js/modules/_object-keys-internal.js");

var hiddenKeys = __webpack_require__(/*! ./_enum-bug-keys */ "../node_modules/core-js/modules/_enum-bug-keys.js").concat('length', 'prototype');

exports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return $keys(O, hiddenKeys);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gops.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gops.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = Object.getOwnPropertySymbols;

/***/ }),

/***/ "../node_modules/core-js/modules/_object-gpo.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-gpo.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)
var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "../node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

var ObjectProto = Object.prototype;

module.exports = Object.getPrototypeOf || function (O) {
  O = toObject(O);
  if (has(O, IE_PROTO)) return O[IE_PROTO];

  if (typeof O.constructor == 'function' && O instanceof O.constructor) {
    return O.constructor.prototype;
  }

  return O instanceof Object ? ObjectProto : null;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-keys-internal.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_object-keys-internal.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var arrayIndexOf = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js")(false);

var IE_PROTO = __webpack_require__(/*! ./_shared-key */ "../node_modules/core-js/modules/_shared-key.js")('IE_PROTO');

module.exports = function (object, names) {
  var O = toIObject(object);
  var i = 0;
  var result = [];
  var key;

  for (key in O) {
    if (key != IE_PROTO) has(O, key) && result.push(key);
  } // Don't enum bug & hidden keys


  while (names.length > i) {
    if (has(O, key = names[i++])) {
      ~arrayIndexOf(result, key) || result.push(key);
    }
  }

  return result;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-keys.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-keys.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 / 15.2.3.14 Object.keys(O)
var $keys = __webpack_require__(/*! ./_object-keys-internal */ "../node_modules/core-js/modules/_object-keys-internal.js");

var enumBugKeys = __webpack_require__(/*! ./_enum-bug-keys */ "../node_modules/core-js/modules/_enum-bug-keys.js");

module.exports = Object.keys || function keys(O) {
  return $keys(O, enumBugKeys);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-pie.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-pie.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.f = {}.propertyIsEnumerable;

/***/ }),

/***/ "../node_modules/core-js/modules/_object-sap.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_object-sap.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// most Object methods by ES6 should accept primitives
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

module.exports = function (KEY, exec) {
  var fn = (core.Object || {})[KEY] || Object[KEY];
  var exp = {};
  exp[KEY] = exec(fn);
  $export($export.S + $export.F * fails(function () {
    fn(1);
  }), 'Object', exp);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_object-to-array.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_object-to-array.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var isEnum = __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js").f;

module.exports = function (isEntries) {
  return function (it) {
    var O = toIObject(it);
    var keys = getKeys(O);
    var length = keys.length;
    var i = 0;
    var result = [];
    var key;

    while (length > i) {
      key = keys[i++];

      if (!DESCRIPTORS || isEnum.call(O, key)) {
        result.push(isEntries ? [key, O[key]] : O[key]);
      }
    }

    return result;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_own-keys.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_own-keys.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// all object keys, includes non-enumerable and symbols
var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js");

var gOPS = __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var Reflect = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Reflect;

module.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {
  var keys = gOPN.f(anObject(it));
  var getSymbols = gOPS.f;
  return getSymbols ? keys.concat(getSymbols(it)) : keys;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_parse-float.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_parse-float.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseFloat = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").parseFloat;

var $trim = __webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js").trim;

module.exports = 1 / $parseFloat(__webpack_require__(/*! ./_string-ws */ "../node_modules/core-js/modules/_string-ws.js") + '-0') !== -Infinity ? function parseFloat(str) {
  var string = $trim(String(str), 3);
  var result = $parseFloat(string);
  return result === 0 && string.charAt(0) == '-' ? -0 : result;
} : $parseFloat;

/***/ }),

/***/ "../node_modules/core-js/modules/_parse-int.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_parse-int.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $parseInt = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").parseInt;

var $trim = __webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js").trim;

var ws = __webpack_require__(/*! ./_string-ws */ "../node_modules/core-js/modules/_string-ws.js");

var hex = /^[-+]?0[xX]/;
module.exports = $parseInt(ws + '08') !== 8 || $parseInt(ws + '0x16') !== 22 ? function parseInt(str, radix) {
  var string = $trim(String(str), 3);
  return $parseInt(string, radix >>> 0 || (hex.test(string) ? 16 : 10));
} : $parseInt;

/***/ }),

/***/ "../node_modules/core-js/modules/_perform.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_perform.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (exec) {
  try {
    return {
      e: false,
      v: exec()
    };
  } catch (e) {
    return {
      e: true,
      v: e
    };
  }
};

/***/ }),

/***/ "../node_modules/core-js/modules/_promise-resolve.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/_promise-resolve.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var newPromiseCapability = __webpack_require__(/*! ./_new-promise-capability */ "../node_modules/core-js/modules/_new-promise-capability.js");

module.exports = function (C, x) {
  anObject(C);
  if (isObject(x) && x.constructor === C) return x;
  var promiseCapability = newPromiseCapability.f(C);
  var resolve = promiseCapability.resolve;
  resolve(x);
  return promiseCapability.promise;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_property-desc.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_property-desc.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value: value
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_redefine-all.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_redefine-all.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

module.exports = function (target, src, safe) {
  for (var key in src) {
    redefine(target, key, src[key], safe);
  }

  return target;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_redefine.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_redefine.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var SRC = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js")('src');

var $toString = __webpack_require__(/*! ./_function-to-string */ "../node_modules/core-js/modules/_function-to-string.js");

var TO_STRING = 'toString';
var TPL = ('' + $toString).split(TO_STRING);

__webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js").inspectSource = function (it) {
  return $toString.call(it);
};

(module.exports = function (O, key, val, safe) {
  var isFunction = typeof val == 'function';
  if (isFunction) has(val, 'name') || hide(val, 'name', key);
  if (O[key] === val) return;
  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));

  if (O === global) {
    O[key] = val;
  } else if (!safe) {
    delete O[key];
    hide(O, key, val);
  } else if (O[key]) {
    O[key] = val;
  } else {
    hide(O, key, val);
  } // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative

})(Function.prototype, TO_STRING, function toString() {
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),

/***/ "../node_modules/core-js/modules/_regexp-exec-abstract.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/_regexp-exec-abstract.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var builtinExec = RegExp.prototype.exec; // `RegExpExec` abstract operation
// https://tc39.github.io/ecma262/#sec-regexpexec

module.exports = function (R, S) {
  var exec = R.exec;

  if (typeof exec === 'function') {
    var result = exec.call(R, S);

    if (_typeof(result) !== 'object') {
      throw new TypeError('RegExp exec method returned something other than an Object or null');
    }

    return result;
  }

  if (classof(R) !== 'RegExp') {
    throw new TypeError('RegExp#exec called on incompatible receiver');
  }

  return builtinExec.call(R, S);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_regexp-exec.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_regexp-exec.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpFlags = __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js");

var nativeExec = RegExp.prototype.exec; // This always refers to the native implementation, because the
// String#replace polyfill uses ./fix-regexp-well-known-symbol-logic.js,
// which loads this file before patching the method.

var nativeReplace = String.prototype.replace;
var patchedExec = nativeExec;
var LAST_INDEX = 'lastIndex';

var UPDATES_LAST_INDEX_WRONG = function () {
  var re1 = /a/,
      re2 = /b*/g;
  nativeExec.call(re1, 'a');
  nativeExec.call(re2, 'a');
  return re1[LAST_INDEX] !== 0 || re2[LAST_INDEX] !== 0;
}(); // nonparticipating capturing group, copied from es5-shim's String#split patch.


var NPCG_INCLUDED = /()??/.exec('')[1] !== undefined;
var PATCH = UPDATES_LAST_INDEX_WRONG || NPCG_INCLUDED;

if (PATCH) {
  patchedExec = function exec(str) {
    var re = this;
    var lastIndex, reCopy, match, i;

    if (NPCG_INCLUDED) {
      reCopy = new RegExp('^' + re.source + '$(?!\\s)', regexpFlags.call(re));
    }

    if (UPDATES_LAST_INDEX_WRONG) lastIndex = re[LAST_INDEX];
    match = nativeExec.call(re, str);

    if (UPDATES_LAST_INDEX_WRONG && match) {
      re[LAST_INDEX] = re.global ? match.index + match[0].length : lastIndex;
    }

    if (NPCG_INCLUDED && match && match.length > 1) {
      // Fix browsers whose `exec` methods don't consistently return `undefined`
      // for NPCG, like IE8. NOTE: This doesn' work for /(.?)?/
      // eslint-disable-next-line no-loop-func
      nativeReplace.call(match[0], reCopy, function () {
        for (i = 1; i < arguments.length - 2; i++) {
          if (arguments[i] === undefined) match[i] = undefined;
        }
      });
    }

    return match;
  };
}

module.exports = patchedExec;

/***/ }),

/***/ "../node_modules/core-js/modules/_same-value.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_same-value.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.2.9 SameValue(x, y)
module.exports = Object.is || function is(x, y) {
  // eslint-disable-next-line no-self-compare
  return x === y ? x !== 0 || 1 / x === 1 / y : x != x && y != y;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-proto.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_set-proto.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// Works with __proto__ only. Old v8 can't work with null proto objects.

/* eslint-disable no-proto */
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var check = function check(O, proto) {
  anObject(O);
  if (!isObject(proto) && proto !== null) throw TypeError(proto + ": can't set as prototype!");
};

module.exports = {
  set: Object.setPrototypeOf || ('__proto__' in {} ? // eslint-disable-line
  function (test, buggy, set) {
    try {
      set = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js")(Function.call, __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f(Object.prototype, '__proto__').set, 2);
      set(test, []);
      buggy = !(test instanceof Array);
    } catch (e) {
      buggy = true;
    }

    return function setPrototypeOf(O, proto) {
      check(O, proto);
      if (buggy) O.__proto__ = proto;else set(O, proto);
      return O;
    };
  }({}, false) : undefined),
  check: check
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-species.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_set-species.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species');

module.exports = function (KEY) {
  var C = global[KEY];
  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {
    configurable: true,
    get: function get() {
      return this;
    }
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_set-to-string-tag.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_set-to-string-tag.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var def = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var TAG = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toStringTag');

module.exports = function (it, tag, stat) {
  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, {
    configurable: true,
    value: tag
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_shared-key.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_shared-key.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var shared = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js")('keys');

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

module.exports = function (key) {
  return shared[key] || (shared[key] = uid(key));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_shared.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/_shared.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var SHARED = '__core-js_shared__';
var store = global[SHARED] || (global[SHARED] = {});
(module.exports = function (key, value) {
  return store[key] || (store[key] = value !== undefined ? value : {});
})('versions', []).push({
  version: core.version,
  mode: __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js") ? 'pure' : 'global',
  copyright: '© 2019 Denis Pushkarev (zloirock.ru)'
});

/***/ }),

/***/ "../node_modules/core-js/modules/_species-constructor.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_species-constructor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.3.20 SpeciesConstructor(O, defaultConstructor)
var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var SPECIES = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species');

module.exports = function (O, D) {
  var C = anObject(O).constructor;
  var S;
  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_strict-method.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_strict-method.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

module.exports = function (method, arg) {
  return !!method && fails(function () {
    // eslint-disable-next-line no-useless-call
    arg ? method.call(null, function () {
      /* empty */
    }, 1) : method.call(null);
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-at.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_string-at.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js"); // true  -> String#at
// false -> String#codePointAt


module.exports = function (TO_STRING) {
  return function (that, pos) {
    var s = String(defined(that));
    var i = toInteger(pos);
    var l = s.length;
    var a, b;
    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;
    a = s.charCodeAt(i);
    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff ? TO_STRING ? s.charAt(i) : a : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;
  };
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-context.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/_string-context.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// helper for String#{startsWith, endsWith, includes}
var isRegExp = __webpack_require__(/*! ./_is-regexp */ "../node_modules/core-js/modules/_is-regexp.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (that, searchString, NAME) {
  if (isRegExp(searchString)) throw TypeError('String#' + NAME + " doesn't accept regex!");
  return String(defined(that));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-html.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_string-html.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

var quot = /"/g; // B.2.3.2.1 CreateHTML(string, tag, attribute, value)

var createHTML = function createHTML(string, tag, attribute, value) {
  var S = String(defined(string));
  var p1 = '<' + tag;
  if (attribute !== '') p1 += ' ' + attribute + '="' + String(value).replace(quot, '&quot;') + '"';
  return p1 + '>' + S + '</' + tag + '>';
};

module.exports = function (NAME, exec) {
  var O = {};
  O[NAME] = exec(createHTML);
  $export($export.P + $export.F * fails(function () {
    var test = ''[NAME]('"');
    return test !== test.toLowerCase() || test.split('"').length > 3;
  }), 'String', O);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-pad.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_string-pad.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-string-pad-start-end
var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "../node_modules/core-js/modules/_string-repeat.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (that, maxLength, fillString, left) {
  var S = String(defined(that));
  var stringLength = S.length;
  var fillStr = fillString === undefined ? ' ' : String(fillString);
  var intMaxLength = toLength(maxLength);
  if (intMaxLength <= stringLength || fillStr == '') return S;
  var fillLen = intMaxLength - stringLength;
  var stringFiller = repeat.call(fillStr, Math.ceil(fillLen / fillStr.length));
  if (stringFiller.length > fillLen) stringFiller = stringFiller.slice(0, fillLen);
  return left ? stringFiller + S : S + stringFiller;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-repeat.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/_string-repeat.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function repeat(count) {
  var str = String(defined(this));
  var res = '';
  var n = toInteger(count);
  if (n < 0 || n == Infinity) throw RangeError("Count can't be negative");

  for (; n > 0; (n >>>= 1) && (str += str)) {
    if (n & 1) res += str;
  }

  return res;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_string-trim.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_string-trim.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var spaces = __webpack_require__(/*! ./_string-ws */ "../node_modules/core-js/modules/_string-ws.js");

var space = '[' + spaces + ']';
var non = "\u200B\x85";
var ltrim = RegExp('^' + space + space + '*');
var rtrim = RegExp(space + space + '*$');

var exporter = function exporter(KEY, exec, ALIAS) {
  var exp = {};
  var FORCE = fails(function () {
    return !!spaces[KEY]() || non[KEY]() != non;
  });
  var fn = exp[KEY] = FORCE ? exec(trim) : spaces[KEY];
  if (ALIAS) exp[ALIAS] = fn;
  $export($export.P + $export.F * FORCE, 'String', exp);
}; // 1 -> String#trimLeft
// 2 -> String#trimRight
// 3 -> String#trim


var trim = exporter.trim = function (string, TYPE) {
  string = String(defined(string));
  if (TYPE & 1) string = string.replace(ltrim, '');
  if (TYPE & 2) string = string.replace(rtrim, '');
  return string;
};

module.exports = exporter;

/***/ }),

/***/ "../node_modules/core-js/modules/_string-ws.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_string-ws.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003" + "\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028\u2029\uFEFF";

/***/ }),

/***/ "../node_modules/core-js/modules/_task.js":
/*!************************************************!*\
  !*** ../node_modules/core-js/modules/_task.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var invoke = __webpack_require__(/*! ./_invoke */ "../node_modules/core-js/modules/_invoke.js");

var html = __webpack_require__(/*! ./_html */ "../node_modules/core-js/modules/_html.js");

var cel = __webpack_require__(/*! ./_dom-create */ "../node_modules/core-js/modules/_dom-create.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var process = global.process;
var setTask = global.setImmediate;
var clearTask = global.clearImmediate;
var MessageChannel = global.MessageChannel;
var Dispatch = global.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function run() {
  var id = +this; // eslint-disable-next-line no-prototype-builtins

  if (queue.hasOwnProperty(id)) {
    var fn = queue[id];
    delete queue[id];
    fn();
  }
};

var listener = function listener(event) {
  run.call(event.data);
}; // Node.js 0.9+ & IE10+ has setImmediate, otherwise:


if (!setTask || !clearTask) {
  setTask = function setImmediate(fn) {
    var args = [];
    var i = 1;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    queue[++counter] = function () {
      // eslint-disable-next-line no-new-func
      invoke(typeof fn == 'function' ? fn : Function(fn), args);
    };

    defer(counter);
    return counter;
  };

  clearTask = function clearImmediate(id) {
    delete queue[id];
  }; // Node.js 0.8-


  if (__webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js")(process) == 'process') {
    defer = function defer(id) {
      process.nextTick(ctx(run, id, 1));
    }; // Sphere (JS game engine) Dispatch API

  } else if (Dispatch && Dispatch.now) {
    defer = function defer(id) {
      Dispatch.now(ctx(run, id, 1));
    }; // Browsers with MessageChannel, includes WebWorkers

  } else if (MessageChannel) {
    channel = new MessageChannel();
    port = channel.port2;
    channel.port1.onmessage = listener;
    defer = ctx(port.postMessage, port, 1); // Browsers with postMessage, skip WebWorkers
    // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
  } else if (global.addEventListener && typeof postMessage == 'function' && !global.importScripts) {
    defer = function defer(id) {
      global.postMessage(id + '', '*');
    };

    global.addEventListener('message', listener, false); // IE8-
  } else if (ONREADYSTATECHANGE in cel('script')) {
    defer = function defer(id) {
      html.appendChild(cel('script'))[ONREADYSTATECHANGE] = function () {
        html.removeChild(this);
        run.call(id);
      };
    }; // Rest old browsers

  } else {
    defer = function defer(id) {
      setTimeout(ctx(run, id, 1), 0);
    };
  }
}

module.exports = {
  set: setTask,
  clear: clearTask
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-absolute-index.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/_to-absolute-index.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var max = Math.max;
var min = Math.min;

module.exports = function (index, length) {
  index = toInteger(index);
  return index < 0 ? max(index + length, 0) : min(index, length);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-index.js":
/*!****************************************************!*\
  !*** ../node_modules/core-js/modules/_to-index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://tc39.github.io/ecma262/#sec-toindex
var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

module.exports = function (it) {
  if (it === undefined) return 0;
  var number = toInteger(it);
  var length = toLength(number);
  if (number !== length) throw RangeError('Wrong length!');
  return length;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-integer.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_to-integer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil = Math.ceil;
var floor = Math.floor;

module.exports = function (it) {
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-iobject.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_to-iobject.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// to indexed object, toObject with fallback for non-array-like ES3 strings
var IObject = __webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js");

var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return IObject(defined(it));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-length.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_to-length.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var min = Math.min;

module.exports = function (it) {
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-object.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/_to-object.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(/*! ./_defined */ "../node_modules/core-js/modules/_defined.js");

module.exports = function (it) {
  return Object(defined(it));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_to-primitive.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_to-primitive.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js"); // instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string


module.exports = function (it, S) {
  if (!isObject(it)) return it;
  var fn, val;
  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;
  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),

/***/ "../node_modules/core-js/modules/_typed-array.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/_typed-array.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

if (__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js")) {
  var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

  var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

  var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

  var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

  var $typed = __webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js");

  var $buffer = __webpack_require__(/*! ./_typed-buffer */ "../node_modules/core-js/modules/_typed-buffer.js");

  var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

  var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

  var propertyDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

  var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

  var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

  var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

  var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

  var toIndex = __webpack_require__(/*! ./_to-index */ "../node_modules/core-js/modules/_to-index.js");

  var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

  var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

  var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

  var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

  var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

  var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

  var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "../node_modules/core-js/modules/_is-array-iter.js");

  var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

  var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

  var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

  var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "../node_modules/core-js/modules/core.get-iterator-method.js");

  var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

  var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

  var createArrayMethod = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js");

  var createArrayIncludes = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js");

  var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

  var ArrayIterators = __webpack_require__(/*! ./es6.array.iterator */ "../node_modules/core-js/modules/es6.array.iterator.js");

  var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

  var $iterDetect = __webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js");

  var setSpecies = __webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js");

  var arrayFill = __webpack_require__(/*! ./_array-fill */ "../node_modules/core-js/modules/_array-fill.js");

  var arrayCopyWithin = __webpack_require__(/*! ./_array-copy-within */ "../node_modules/core-js/modules/_array-copy-within.js");

  var $DP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

  var $GOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

  var dP = $DP.f;
  var gOPD = $GOPD.f;
  var RangeError = global.RangeError;
  var TypeError = global.TypeError;
  var Uint8Array = global.Uint8Array;
  var ARRAY_BUFFER = 'ArrayBuffer';
  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;
  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
  var PROTOTYPE = 'prototype';
  var ArrayProto = Array[PROTOTYPE];
  var $ArrayBuffer = $buffer.ArrayBuffer;
  var $DataView = $buffer.DataView;
  var arrayForEach = createArrayMethod(0);
  var arrayFilter = createArrayMethod(2);
  var arraySome = createArrayMethod(3);
  var arrayEvery = createArrayMethod(4);
  var arrayFind = createArrayMethod(5);
  var arrayFindIndex = createArrayMethod(6);
  var arrayIncludes = createArrayIncludes(true);
  var arrayIndexOf = createArrayIncludes(false);
  var arrayValues = ArrayIterators.values;
  var arrayKeys = ArrayIterators.keys;
  var arrayEntries = ArrayIterators.entries;
  var arrayLastIndexOf = ArrayProto.lastIndexOf;
  var arrayReduce = ArrayProto.reduce;
  var arrayReduceRight = ArrayProto.reduceRight;
  var arrayJoin = ArrayProto.join;
  var arraySort = ArrayProto.sort;
  var arraySlice = ArrayProto.slice;
  var arrayToString = ArrayProto.toString;
  var arrayToLocaleString = ArrayProto.toLocaleString;
  var ITERATOR = wks('iterator');
  var TAG = wks('toStringTag');
  var TYPED_CONSTRUCTOR = uid('typed_constructor');
  var DEF_CONSTRUCTOR = uid('def_constructor');
  var ALL_CONSTRUCTORS = $typed.CONSTR;
  var TYPED_ARRAY = $typed.TYPED;
  var VIEW = $typed.VIEW;
  var WRONG_LENGTH = 'Wrong length!';
  var $map = createArrayMethod(1, function (O, length) {
    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);
  });
  var LITTLE_ENDIAN = fails(function () {
    // eslint-disable-next-line no-undef
    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;
  });
  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {
    new Uint8Array(1).set({});
  });

  var toOffset = function toOffset(it, BYTES) {
    var offset = toInteger(it);
    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');
    return offset;
  };

  var validate = function validate(it) {
    if (isObject(it) && TYPED_ARRAY in it) return it;
    throw TypeError(it + ' is not a typed array!');
  };

  var allocate = function allocate(C, length) {
    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {
      throw TypeError('It is not a typed array constructor!');
    }

    return new C(length);
  };

  var speciesFromList = function speciesFromList(O, list) {
    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);
  };

  var fromList = function fromList(C, list) {
    var index = 0;
    var length = list.length;
    var result = allocate(C, length);

    while (length > index) {
      result[index] = list[index++];
    }

    return result;
  };

  var addGetter = function addGetter(it, key, internal) {
    dP(it, key, {
      get: function get() {
        return this._d[internal];
      }
    });
  };

  var $from = function from(source
  /* , mapfn, thisArg */
  ) {
    var O = toObject(source);
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iterFn = getIterFn(O);
    var i, length, values, result, step, iterator;

    if (iterFn != undefined && !isArrayIter(iterFn)) {
      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {
        values.push(step.value);
      }

      O = values;
    }

    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);

    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {
      result[i] = mapping ? mapfn(O[i], i) : O[i];
    }

    return result;
  };

  var $of = function of()
  /* ...items */
  {
    var index = 0;
    var length = arguments.length;
    var result = allocate(this, length);

    while (length > index) {
      result[index] = arguments[index++];
    }

    return result;
  }; // iOS Safari 6.x fails here


  var TO_LOCALE_BUG = !!Uint8Array && fails(function () {
    arrayToLocaleString.call(new Uint8Array(1));
  });

  var $toLocaleString = function toLocaleString() {
    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);
  };

  var proto = {
    copyWithin: function copyWithin(target, start
    /* , end */
    ) {
      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);
    },
    every: function every(callbackfn
    /* , thisArg */
    ) {
      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    fill: function fill(value
    /* , start, end */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayFill.apply(validate(this), arguments);
    },
    filter: function filter(callbackfn
    /* , thisArg */
    ) {
      return speciesFromList(this, arrayFilter(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined));
    },
    find: function find(predicate
    /* , thisArg */
    ) {
      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    findIndex: function findIndex(predicate
    /* , thisArg */
    ) {
      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);
    },
    forEach: function forEach(callbackfn
    /* , thisArg */
    ) {
      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    indexOf: function indexOf(searchElement
    /* , fromIndex */
    ) {
      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    includes: function includes(searchElement
    /* , fromIndex */
    ) {
      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);
    },
    join: function join(separator) {
      // eslint-disable-line no-unused-vars
      return arrayJoin.apply(validate(this), arguments);
    },
    lastIndexOf: function lastIndexOf(searchElement
    /* , fromIndex */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayLastIndexOf.apply(validate(this), arguments);
    },
    map: function map(mapfn
    /* , thisArg */
    ) {
      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    reduce: function reduce(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduce.apply(validate(this), arguments);
    },
    reduceRight: function reduceRight(callbackfn
    /* , initialValue */
    ) {
      // eslint-disable-line no-unused-vars
      return arrayReduceRight.apply(validate(this), arguments);
    },
    reverse: function reverse() {
      var that = this;
      var length = validate(that).length;
      var middle = Math.floor(length / 2);
      var index = 0;
      var value;

      while (index < middle) {
        value = that[index];
        that[index++] = that[--length];
        that[length] = value;
      }

      return that;
    },
    some: function some(callbackfn
    /* , thisArg */
    ) {
      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);
    },
    sort: function sort(comparefn) {
      return arraySort.call(validate(this), comparefn);
    },
    subarray: function subarray(begin, end) {
      var O = validate(this);
      var length = O.length;
      var $begin = toAbsoluteIndex(begin, length);
      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(O.buffer, O.byteOffset + $begin * O.BYTES_PER_ELEMENT, toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin));
    }
  };

  var $slice = function slice(start, end) {
    return speciesFromList(this, arraySlice.call(validate(this), start, end));
  };

  var $set = function set(arrayLike
  /* , offset */
  ) {
    validate(this);
    var offset = toOffset(arguments[1], 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError(WRONG_LENGTH);

    while (index < len) {
      this[offset + index] = src[index++];
    }
  };

  var $iterators = {
    entries: function entries() {
      return arrayEntries.call(validate(this));
    },
    keys: function keys() {
      return arrayKeys.call(validate(this));
    },
    values: function values() {
      return arrayValues.call(validate(this));
    }
  };

  var isTAIndex = function isTAIndex(target, key) {
    return isObject(target) && target[TYPED_ARRAY] && _typeof(key) != 'symbol' && key in target && String(+key) == String(key);
  };

  var $getDesc = function getOwnPropertyDescriptor(target, key) {
    return isTAIndex(target, key = toPrimitive(key, true)) ? propertyDesc(2, target[key]) : gOPD(target, key);
  };

  var $setDesc = function defineProperty(target, key, desc) {
    if (isTAIndex(target, key = toPrimitive(key, true)) && isObject(desc) && has(desc, 'value') && !has(desc, 'get') && !has(desc, 'set') // TODO: add validation descriptor w/o calling accessors
    && !desc.configurable && (!has(desc, 'writable') || desc.writable) && (!has(desc, 'enumerable') || desc.enumerable)) {
      target[key] = desc.value;
      return target;
    }

    return dP(target, key, desc);
  };

  if (!ALL_CONSTRUCTORS) {
    $GOPD.f = $getDesc;
    $DP.f = $setDesc;
  }

  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {
    getOwnPropertyDescriptor: $getDesc,
    defineProperty: $setDesc
  });

  if (fails(function () {
    arrayToString.call({});
  })) {
    arrayToString = arrayToLocaleString = function toString() {
      return arrayJoin.call(this);
    };
  }

  var $TypedArrayPrototype$ = redefineAll({}, proto);
  redefineAll($TypedArrayPrototype$, $iterators);
  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);
  redefineAll($TypedArrayPrototype$, {
    slice: $slice,
    set: $set,
    constructor: function constructor() {
      /* noop */
    },
    toString: arrayToString,
    toLocaleString: $toLocaleString
  });
  addGetter($TypedArrayPrototype$, 'buffer', 'b');
  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');
  addGetter($TypedArrayPrototype$, 'byteLength', 'l');
  addGetter($TypedArrayPrototype$, 'length', 'e');
  dP($TypedArrayPrototype$, TAG, {
    get: function get() {
      return this[TYPED_ARRAY];
    }
  }); // eslint-disable-next-line max-statements

  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {
    CLAMPED = !!CLAMPED;
    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';
    var GETTER = 'get' + KEY;
    var SETTER = 'set' + KEY;
    var TypedArray = global[NAME];
    var Base = TypedArray || {};
    var TAC = TypedArray && getPrototypeOf(TypedArray);
    var FORCED = !TypedArray || !$typed.ABV;
    var O = {};
    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];

    var getter = function getter(that, index) {
      var data = that._d;
      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);
    };

    var setter = function setter(that, index, value) {
      var data = that._d;
      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;
      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);
    };

    var addElement = function addElement(that, index) {
      dP(that, index, {
        get: function get() {
          return getter(this, index);
        },
        set: function set(value) {
          return setter(this, index, value);
        },
        enumerable: true
      });
    };

    if (FORCED) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME, '_d');
        var index = 0;
        var offset = 0;
        var buffer, byteLength, length, klass;

        if (!isObject(data)) {
          length = toIndex(data);
          byteLength = length * BYTES;
          buffer = new $ArrayBuffer(byteLength);
        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          buffer = data;
          offset = toOffset($offset, BYTES);
          var $len = data.byteLength;

          if ($length === undefined) {
            if ($len % BYTES) throw RangeError(WRONG_LENGTH);
            byteLength = $len - offset;
            if (byteLength < 0) throw RangeError(WRONG_LENGTH);
          } else {
            byteLength = toLength($length) * BYTES;
            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);
          }

          length = byteLength / BYTES;
        } else if (TYPED_ARRAY in data) {
          return fromList(TypedArray, data);
        } else {
          return $from.call(TypedArray, data);
        }

        hide(that, '_d', {
          b: buffer,
          o: offset,
          l: byteLength,
          e: length,
          v: new $DataView(buffer)
        });

        while (index < length) {
          addElement(that, index++);
        }
      });
      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);
      hide(TypedArrayPrototype, 'constructor', TypedArray);
    } else if (!fails(function () {
      TypedArray(1);
    }) || !fails(function () {
      new TypedArray(-1); // eslint-disable-line no-new
    }) || !$iterDetect(function (iter) {
      new TypedArray(); // eslint-disable-line no-new

      new TypedArray(null); // eslint-disable-line no-new

      new TypedArray(1.5); // eslint-disable-line no-new

      new TypedArray(iter); // eslint-disable-line no-new
    }, true)) {
      TypedArray = wrapper(function (that, data, $offset, $length) {
        anInstance(that, TypedArray, NAME);
        var klass; // `ws` module bug, temporarily remove validation length for Uint8Array
        // https://github.com/websockets/ws/pull/645

        if (!isObject(data)) return new Base(toIndex(data));

        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {
          return $length !== undefined ? new Base(data, toOffset($offset, BYTES), $length) : $offset !== undefined ? new Base(data, toOffset($offset, BYTES)) : new Base(data);
        }

        if (TYPED_ARRAY in data) return fromList(TypedArray, data);
        return $from.call(TypedArray, data);
      });
      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {
        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);
      });
      TypedArray[PROTOTYPE] = TypedArrayPrototype;
      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;
    }

    var $nativeIterator = TypedArrayPrototype[ITERATOR];
    var CORRECT_ITER_NAME = !!$nativeIterator && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);
    var $iterator = $iterators.values;
    hide(TypedArray, TYPED_CONSTRUCTOR, true);
    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);
    hide(TypedArrayPrototype, VIEW, true);
    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);

    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {
      dP(TypedArrayPrototype, TAG, {
        get: function get() {
          return NAME;
        }
      });
    }

    O[NAME] = TypedArray;
    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);
    $export($export.S, NAME, {
      BYTES_PER_ELEMENT: BYTES
    });
    $export($export.S + $export.F * fails(function () {
      Base.of.call(TypedArray, 1);
    }), NAME, {
      from: $from,
      of: $of
    });
    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);
    $export($export.P, NAME, proto);
    setSpecies(NAME);
    $export($export.P + $export.F * FORCED_SET, NAME, {
      set: $set
    });
    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);
    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;
    $export($export.P + $export.F * fails(function () {
      new TypedArray(1).slice();
    }), NAME, {
      slice: $slice
    });
    $export($export.P + $export.F * (fails(function () {
      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();
    }) || !fails(function () {
      TypedArrayPrototype.toLocaleString.call([1, 2]);
    })), NAME, {
      toLocaleString: $toLocaleString
    });
    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;
    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);
  };
} else module.exports = function () {
  /* empty */
};

/***/ }),

/***/ "../node_modules/core-js/modules/_typed-buffer.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/_typed-buffer.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var $typed = __webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var redefineAll = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var toIndex = __webpack_require__(/*! ./_to-index */ "../node_modules/core-js/modules/_to-index.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var arrayFill = __webpack_require__(/*! ./_array-fill */ "../node_modules/core-js/modules/_array-fill.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH = 'Wrong length!';
var WRONG_INDEX = 'Wrong index!';
var $ArrayBuffer = global[ARRAY_BUFFER];
var $DataView = global[DATA_VIEW];
var Math = global.Math;
var RangeError = global.RangeError; // eslint-disable-next-line no-shadow-restricted-names

var Infinity = global.Infinity;
var BaseBuffer = $ArrayBuffer;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;
var BUFFER = 'buffer';
var BYTE_LENGTH = 'byteLength';
var BYTE_OFFSET = 'byteOffset';
var $BUFFER = DESCRIPTORS ? '_b' : BUFFER;
var $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;
var $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET; // IEEE754 conversions based on https://github.com/feross/ieee754

function packIEEE754(value, mLen, nBytes) {
  var buffer = new Array(nBytes);
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;
  var i = 0;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  var e, m, c;
  value = abs(value); // eslint-disable-next-line no-self-compare

  if (value != value || value === Infinity) {
    // eslint-disable-next-line no-self-compare
    m = value != value ? 1 : 0;
    e = eMax;
  } else {
    e = floor(log(value) / LN2);

    if (value * (c = pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * pow(2, eBias - 1) * pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8) {
    ;
  }

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8) {
    ;
  }

  buffer[--i] |= s * 128;
  return buffer;
}

function unpackIEEE754(buffer, mLen, nBytes) {
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = eLen - 7;
  var i = nBytes - 1;
  var s = buffer[i--];
  var e = s & 127;
  var m;
  s >>= 7;

  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8) {
    ;
  }

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8) {
    ;
  }

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : s ? -Infinity : Infinity;
  } else {
    m = m + pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * pow(2, e - mLen);
}

function unpackI32(bytes) {
  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];
}

function packI8(it) {
  return [it & 0xff];
}

function packI16(it) {
  return [it & 0xff, it >> 8 & 0xff];
}

function packI32(it) {
  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];
}

function packF64(it) {
  return packIEEE754(it, 52, 8);
}

function packF32(it) {
  return packIEEE754(it, 23, 4);
}

function addGetter(C, key, internal) {
  dP(C[PROTOTYPE], key, {
    get: function get() {
      return this[internal];
    }
  });
}

function get(view, bytes, index, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = store.slice(start, start + bytes);
  return isLittleEndian ? pack : pack.reverse();
}

function set(view, bytes, index, conversion, value, isLittleEndian) {
  var numIndex = +index;
  var intIndex = toIndex(numIndex);
  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);
  var store = view[$BUFFER]._b;
  var start = intIndex + view[$OFFSET];
  var pack = conversion(+value);

  for (var i = 0; i < bytes; i++) {
    store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];
  }
}

if (!$typed.ABV) {
  $ArrayBuffer = function ArrayBuffer(length) {
    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);
    var byteLength = toIndex(length);
    this._b = arrayFill.call(new Array(byteLength), 0);
    this[$LENGTH] = byteLength;
  };

  $DataView = function DataView(buffer, byteOffset, byteLength) {
    anInstance(this, $DataView, DATA_VIEW);
    anInstance(buffer, $ArrayBuffer, DATA_VIEW);
    var bufferLength = buffer[$LENGTH];
    var offset = toInteger(byteOffset);
    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');
    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);
    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);
    this[$BUFFER] = buffer;
    this[$OFFSET] = offset;
    this[$LENGTH] = byteLength;
  };

  if (DESCRIPTORS) {
    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');
    addGetter($DataView, BUFFER, '_b');
    addGetter($DataView, BYTE_LENGTH, '_l');
    addGetter($DataView, BYTE_OFFSET, '_o');
  }

  redefineAll($DataView[PROTOTYPE], {
    getInt8: function getInt8(byteOffset) {
      return get(this, 1, byteOffset)[0] << 24 >> 24;
    },
    getUint8: function getUint8(byteOffset) {
      return get(this, 1, byteOffset)[0];
    },
    getInt16: function getInt16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
    },
    getUint16: function getUint16(byteOffset
    /* , littleEndian */
    ) {
      var bytes = get(this, 2, byteOffset, arguments[1]);
      return bytes[1] << 8 | bytes[0];
    },
    getInt32: function getInt32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1]));
    },
    getUint32: function getUint32(byteOffset
    /* , littleEndian */
    ) {
      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;
    },
    getFloat32: function getFloat32(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);
    },
    getFloat64: function getFloat64(byteOffset
    /* , littleEndian */
    ) {
      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);
    },
    setInt8: function setInt8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setUint8: function setUint8(byteOffset, value) {
      set(this, 1, byteOffset, packI8, value);
    },
    setInt16: function setInt16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setUint16: function setUint16(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 2, byteOffset, packI16, value, arguments[2]);
    },
    setInt32: function setInt32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setUint32: function setUint32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packI32, value, arguments[2]);
    },
    setFloat32: function setFloat32(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 4, byteOffset, packF32, value, arguments[2]);
    },
    setFloat64: function setFloat64(byteOffset, value
    /* , littleEndian */
    ) {
      set(this, 8, byteOffset, packF64, value, arguments[2]);
    }
  });
} else {
  if (!fails(function () {
    $ArrayBuffer(1);
  }) || !fails(function () {
    new $ArrayBuffer(-1); // eslint-disable-line no-new
  }) || fails(function () {
    new $ArrayBuffer(); // eslint-disable-line no-new

    new $ArrayBuffer(1.5); // eslint-disable-line no-new

    new $ArrayBuffer(NaN); // eslint-disable-line no-new

    return $ArrayBuffer.name != ARRAY_BUFFER;
  })) {
    $ArrayBuffer = function ArrayBuffer(length) {
      anInstance(this, $ArrayBuffer);
      return new BaseBuffer(toIndex(length));
    };

    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];

    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {
      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);
    }

    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;
  } // iOS Safari 7.x bug


  var view = new $DataView(new $ArrayBuffer(2));
  var $setInt8 = $DataView[PROTOTYPE].setInt8;
  view.setInt8(0, 2147483648);
  view.setInt8(1, 2147483649);
  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {
    setInt8: function setInt8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    },
    setUint8: function setUint8(byteOffset, value) {
      $setInt8.call(this, byteOffset, value << 24 >> 24);
    }
  }, true);
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);
hide($DataView[PROTOTYPE], $typed.VIEW, true);
exports[ARRAY_BUFFER] = $ArrayBuffer;
exports[DATA_VIEW] = $DataView;

/***/ }),

/***/ "../node_modules/core-js/modules/_typed.js":
/*!*************************************************!*\
  !*** ../node_modules/core-js/modules/_typed.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

var TYPED = uid('typed_array');
var VIEW = uid('view');
var ABV = !!(global.ArrayBuffer && global.DataView);
var CONSTR = ABV;
var i = 0;
var l = 9;
var Typed;
var TypedArrayConstructors = 'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'.split(',');

while (i < l) {
  if (Typed = global[TypedArrayConstructors[i++]]) {
    hide(Typed.prototype, TYPED, true);
    hide(Typed.prototype, VIEW, true);
  } else CONSTR = false;
}

module.exports = {
  ABV: ABV,
  CONSTR: CONSTR,
  TYPED: TYPED,
  VIEW: VIEW
};

/***/ }),

/***/ "../node_modules/core-js/modules/_uid.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_uid.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var id = 0;
var px = Math.random();

module.exports = function (key) {
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),

/***/ "../node_modules/core-js/modules/_user-agent.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_user-agent.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var navigator = global.navigator;
module.exports = navigator && navigator.userAgent || '';

/***/ }),

/***/ "../node_modules/core-js/modules/_validate-collection.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/_validate-collection.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

module.exports = function (it, TYPE) {
  if (!isObject(it) || it._t !== TYPE) throw TypeError('Incompatible receiver, ' + TYPE + ' required!');
  return it;
};

/***/ }),

/***/ "../node_modules/core-js/modules/_wks-define.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/_wks-define.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "../node_modules/core-js/modules/_wks-ext.js");

var defineProperty = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

module.exports = function (name) {
  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});
  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, {
    value: wksExt.f(name)
  });
};

/***/ }),

/***/ "../node_modules/core-js/modules/_wks-ext.js":
/*!***************************************************!*\
  !*** ../node_modules/core-js/modules/_wks-ext.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports.f = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

/***/ }),

/***/ "../node_modules/core-js/modules/_wks.js":
/*!***********************************************!*\
  !*** ../node_modules/core-js/modules/_wks.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var store = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js")('wks');

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

var _Symbol = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Symbol;

var USE_SYMBOL = typeof _Symbol == 'function';

var $exports = module.exports = function (name) {
  return store[name] || (store[name] = USE_SYMBOL && _Symbol[name] || (USE_SYMBOL ? _Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),

/***/ "../node_modules/core-js/modules/core.get-iterator-method.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/core.get-iterator-method.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var ITERATOR = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('iterator');

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

module.exports = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js").getIteratorMethod = function (it) {
  if (it != undefined) return it[ITERATOR] || it['@@iterator'] || Iterators[classof(it)];
};

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.copy-within.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.copy-within.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  copyWithin: __webpack_require__(/*! ./_array-copy-within */ "../node_modules/core-js/modules/_array-copy-within.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('copyWithin');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.every.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.every.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $every = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(4);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].every, true), 'Array', {
  // 22.1.3.5 / 15.4.4.16 Array.prototype.every(callbackfn [, thisArg])
  every: function every(callbackfn
  /* , thisArg */
  ) {
    return $every(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.fill.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.fill.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'Array', {
  fill: __webpack_require__(/*! ./_array-fill */ "../node_modules/core-js/modules/_array-fill.js")
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('fill');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.filter.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.filter.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $filter = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(2);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].filter, true), 'Array', {
  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])
  filter: function filter(callbackfn
  /* , thisArg */
  ) {
    return $filter(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.find-index.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.find-index.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.9 Array.prototype.findIndex(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(6);

var KEY = 'findIndex';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  findIndex: function findIndex(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.find.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.find.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $find = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(5);

var KEY = 'find';
var forced = true; // Shouldn't skip holes

if (KEY in []) Array(1)[KEY](function () {
  forced = false;
});
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn
  /* , that = undefined */
  ) {
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")(KEY);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.for-each.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.for-each.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $forEach = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(0);

var STRICT = __webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].forEach, true);

$export($export.P + $export.F * !STRICT, 'Array', {
  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])
  forEach: function forEach(callbackfn
  /* , thisArg */
  ) {
    return $forEach(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.from.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.from.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var call = __webpack_require__(/*! ./_iter-call */ "../node_modules/core-js/modules/_iter-call.js");

var isArrayIter = __webpack_require__(/*! ./_is-array-iter */ "../node_modules/core-js/modules/_is-array-iter.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "../node_modules/core-js/modules/_create-property.js");

var getIterFn = __webpack_require__(/*! ./core.get-iterator-method */ "../node_modules/core-js/modules/core.get-iterator-method.js");

$export($export.S + $export.F * !__webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  Array.from(iter);
}), 'Array', {
  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)
  from: function from(arrayLike
  /* , mapfn = undefined, thisArg = undefined */
  ) {
    var O = toObject(arrayLike);
    var C = typeof this == 'function' ? this : Array;
    var aLen = arguments.length;
    var mapfn = aLen > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var index = 0;
    var iterFn = getIterFn(O);
    var length, result, step, iterator;
    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2); // if object isn't iterable or it's array with default iterator - use simple case

    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {
      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {
        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);
      }
    } else {
      length = toLength(O.length);

      for (result = new C(length); length > index; index++) {
        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);
      }
    }

    result.length = index;
    return result;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.index-of.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.index-of.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $indexOf = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js")(false);

var $native = [].indexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])
  indexOf: function indexOf(searchElement
  /* , fromIndex = 0 */
  ) {
    return NEGATIVE_ZERO // convert -0 to +0
    ? $native.apply(this, arguments) || 0 : $indexOf(this, searchElement, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.is-array.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.is-array.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Array', {
  isArray: __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.iterator.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.iterator.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var addToUnscopables = __webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js");

var step = __webpack_require__(/*! ./_iter-step */ "../node_modules/core-js/modules/_iter-step.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js"); // 22.1.3.4 Array.prototype.entries()
// 22.1.3.13 Array.prototype.keys()
// 22.1.3.29 Array.prototype.values()
// 22.1.3.30 Array.prototype[@@iterator]()


module.exports = __webpack_require__(/*! ./_iter-define */ "../node_modules/core-js/modules/_iter-define.js")(Array, 'Array', function (iterated, kind) {
  this._t = toIObject(iterated); // target

  this._i = 0; // next index

  this._k = kind; // kind
  // 22.1.5.2.1 %ArrayIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var kind = this._k;
  var index = this._i++;

  if (!O || index >= O.length) {
    this._t = undefined;
    return step(1);
  }

  if (kind == 'keys') return step(0, index);
  if (kind == 'values') return step(0, O[index]);
  return step(0, [index, O[index]]);
}, 'values'); // argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)

Iterators.Arguments = Iterators.Array;
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.join.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.join.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 22.1.3.13 Array.prototype.join(separator)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var arrayJoin = [].join; // fallback for not array-like strings

$export($export.P + $export.F * (__webpack_require__(/*! ./_iobject */ "../node_modules/core-js/modules/_iobject.js") != Object || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")(arrayJoin)), 'Array', {
  join: function join(separator) {
    return arrayJoin.call(toIObject(this), separator === undefined ? ',' : separator);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.last-index-of.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.last-index-of.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var $native = [].lastIndexOf;
var NEGATIVE_ZERO = !!$native && 1 / [1].lastIndexOf(1, -0) < 0;
$export($export.P + $export.F * (NEGATIVE_ZERO || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")($native)), 'Array', {
  // 22.1.3.14 / 15.4.4.15 Array.prototype.lastIndexOf(searchElement [, fromIndex])
  lastIndexOf: function lastIndexOf(searchElement
  /* , fromIndex = @[*-1] */
  ) {
    // convert -0 to +0
    if (NEGATIVE_ZERO) return $native.apply(this, arguments) || 0;
    var O = toIObject(this);
    var length = toLength(O.length);
    var index = length - 1;
    if (arguments.length > 1) index = Math.min(index, toInteger(arguments[1]));
    if (index < 0) index = length + index;

    for (; index >= 0; index--) {
      if (index in O) if (O[index] === searchElement) return index || 0;
    }

    return -1;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.map.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.map.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $map = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(1);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].map, true), 'Array', {
  // 22.1.3.15 / 15.4.4.19 Array.prototype.map(callbackfn [, thisArg])
  map: function map(callbackfn
  /* , thisArg */
  ) {
    return $map(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.of.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.of.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "../node_modules/core-js/modules/_create-property.js"); // WebKit Array.of isn't generic


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  function F() {
    /* empty */
  }

  return !(Array.of.call(F) instanceof F);
}), 'Array', {
  // 22.1.2.3 Array.of( ...items)
  of: function of()
  /* ...args */
  {
    var index = 0;
    var aLen = arguments.length;
    var result = new (typeof this == 'function' ? this : Array)(aLen);

    while (aLen > index) {
      createProperty(result, index, arguments[index++]);
    }

    result.length = aLen;
    return result;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.reduce-right.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.reduce-right.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "../node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].reduceRight, true), 'Array', {
  // 22.1.3.19 / 15.4.4.22 Array.prototype.reduceRight(callbackfn [, initialValue])
  reduceRight: function reduceRight(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], true);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.reduce.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.reduce.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $reduce = __webpack_require__(/*! ./_array-reduce */ "../node_modules/core-js/modules/_array-reduce.js");

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].reduce, true), 'Array', {
  // 22.1.3.18 / 15.4.4.21 Array.prototype.reduce(callbackfn [, initialValue])
  reduce: function reduce(callbackfn
  /* , initialValue */
  ) {
    return $reduce(this, callbackfn, arguments.length, arguments[1], false);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.slice.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.slice.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var html = __webpack_require__(/*! ./_html */ "../node_modules/core-js/modules/_html.js");

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var arraySlice = [].slice; // fallback for not array-like ES3 strings and DOM objects

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  if (html) arraySlice.call(html);
}), 'Array', {
  slice: function slice(begin, end) {
    var len = toLength(this.length);
    var klass = cof(this);
    end = end === undefined ? len : end;
    if (klass == 'Array') return arraySlice.call(this, begin, end);
    var start = toAbsoluteIndex(begin, len);
    var upTo = toAbsoluteIndex(end, len);
    var size = toLength(upTo - start);
    var cloned = new Array(size);
    var i = 0;

    for (; i < size; i++) {
      cloned[i] = klass == 'String' ? this.charAt(start + i) : this[start + i];
    }

    return cloned;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.some.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.some.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $some = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(3);

$export($export.P + $export.F * !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")([].some, true), 'Array', {
  // 22.1.3.23 / 15.4.4.17 Array.prototype.some(callbackfn [, thisArg])
  some: function some(callbackfn
  /* , thisArg */
  ) {
    return $some(this, callbackfn, arguments[1]);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.sort.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.sort.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var $sort = [].sort;
var test = [1, 2, 3];
$export($export.P + $export.F * (fails(function () {
  // IE8-
  test.sort(undefined);
}) || !fails(function () {
  // V8 bug
  test.sort(null); // Old WebKit
}) || !__webpack_require__(/*! ./_strict-method */ "../node_modules/core-js/modules/_strict-method.js")($sort)), 'Array', {
  // 22.1.3.25 Array.prototype.sort(comparefn)
  sort: function sort(comparefn) {
    return comparefn === undefined ? $sort.call(toObject(this)) : $sort.call(toObject(this), aFunction(comparefn));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.array.species.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.array.species.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")('Array');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.now.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.now.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.3.1 / 15.9.4.4 Date.now()
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Date', {
  now: function now() {
    return new Date().getTime();
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-iso-string.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-iso-string.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.3.4.36 / 15.9.5.43 Date.prototype.toISOString()
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toISOString = __webpack_require__(/*! ./_date-to-iso-string */ "../node_modules/core-js/modules/_date-to-iso-string.js"); // PhantomJS / old WebKit has a broken implementations


$export($export.P + $export.F * (Date.prototype.toISOString !== toISOString), 'Date', {
  toISOString: toISOString
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-json.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-json.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

$export($export.P + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return new Date(NaN).toJSON() !== null || Date.prototype.toJSON.call({
    toISOString: function toISOString() {
      return 1;
    }
  }) !== 1;
}), 'Date', {
  // eslint-disable-next-line no-unused-vars
  toJSON: function toJSON(key) {
    var O = toObject(this);
    var pv = toPrimitive(O);
    return typeof pv == 'number' && !isFinite(pv) ? null : O.toISOString();
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-primitive.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-primitive.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var TO_PRIMITIVE = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toPrimitive');

var proto = Date.prototype;
if (!(TO_PRIMITIVE in proto)) __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")(proto, TO_PRIMITIVE, __webpack_require__(/*! ./_date-to-primitive */ "../node_modules/core-js/modules/_date-to-primitive.js"));

/***/ }),

/***/ "../node_modules/core-js/modules/es6.date.to-string.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.date.to-string.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var DateProto = Date.prototype;
var INVALID_DATE = 'Invalid Date';
var TO_STRING = 'toString';
var $toString = DateProto[TO_STRING];
var getTime = DateProto.getTime;

if (new Date(NaN) + '' != INVALID_DATE) {
  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(DateProto, TO_STRING, function toString() {
    var value = getTime.call(this); // eslint-disable-next-line no-self-compare

    return value === value ? $toString.call(this) : INVALID_DATE;
  });
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.function.bind.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.function.bind.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.2.3.2 / 15.3.4.5 Function.prototype.bind(thisArg, args...)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'Function', {
  bind: __webpack_require__(/*! ./_bind */ "../node_modules/core-js/modules/_bind.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.function.has-instance.js":
/*!********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.function.has-instance.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var HAS_INSTANCE = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('hasInstance');

var FunctionProto = Function.prototype; // 19.2.3.6 Function.prototype[@@hasInstance](V)

if (!(HAS_INSTANCE in FunctionProto)) __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f(FunctionProto, HAS_INSTANCE, {
  value: function value(O) {
    if (typeof this != 'function' || !isObject(O)) return false;
    if (!isObject(this.prototype)) return O instanceof this; // for environment w/o native `@@hasInstance` logic enough `instanceof`, but add this:

    while (O = getPrototypeOf(O)) {
      if (this.prototype === O) return true;
    }

    return false;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.function.name.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.function.name.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var FProto = Function.prototype;
var nameRE = /^\s*function ([^ (]*)/;
var NAME = 'name'; // 19.2.4.2 name

NAME in FProto || __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && dP(FProto, NAME, {
  configurable: true,
  get: function get() {
    try {
      return ('' + this).match(nameRE)[1];
    } catch (e) {
      return '';
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.map.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/es6.map.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "../node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var MAP = 'Map'; // 23.1 Map Objects

module.exports = __webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(MAP, function (get) {
  return function Map() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.1.3.6 Map.prototype.get(key)
  get: function get(key) {
    var entry = strong.getEntry(validate(this, MAP), key);
    return entry && entry.v;
  },
  // 23.1.3.9 Map.prototype.set(key, value)
  set: function set(key, value) {
    return strong.def(validate(this, MAP), key === 0 ? 0 : key, value);
  }
}, strong, true);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.acosh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.acosh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.3 Math.acosh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var log1p = __webpack_require__(/*! ./_math-log1p */ "../node_modules/core-js/modules/_math-log1p.js");

var sqrt = Math.sqrt;
var $acosh = Math.acosh;
$export($export.S + $export.F * !($acosh // V8 bug: https://code.google.com/p/v8/issues/detail?id=3509
&& Math.floor($acosh(Number.MAX_VALUE)) == 710 // Tor Browser bug: Math.acosh(Infinity) -> NaN
&& $acosh(Infinity) == Infinity), 'Math', {
  acosh: function acosh(x) {
    return (x = +x) < 1 ? NaN : x > 94906265.62425156 ? Math.log(x) + Math.LN2 : log1p(x - 1 + sqrt(x - 1) * sqrt(x + 1));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.asinh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.asinh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.5 Math.asinh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $asinh = Math.asinh;

function asinh(x) {
  return !isFinite(x = +x) || x == 0 ? x : x < 0 ? -asinh(-x) : Math.log(x + Math.sqrt(x * x + 1));
} // Tor Browser bug: Math.asinh(0) -> -0


$export($export.S + $export.F * !($asinh && 1 / $asinh(0) > 0), 'Math', {
  asinh: asinh
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.atanh.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.atanh.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.7 Math.atanh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $atanh = Math.atanh; // Tor Browser bug: Math.atanh(-0) -> 0

$export($export.S + $export.F * !($atanh && 1 / $atanh(-0) < 0), 'Math', {
  atanh: function atanh(x) {
    return (x = +x) == 0 ? x : Math.log((1 + x) / (1 - x)) / 2;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.cbrt.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.cbrt.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.9 Math.cbrt(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var sign = __webpack_require__(/*! ./_math-sign */ "../node_modules/core-js/modules/_math-sign.js");

$export($export.S, 'Math', {
  cbrt: function cbrt(x) {
    return sign(x = +x) * Math.pow(Math.abs(x), 1 / 3);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.clz32.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.clz32.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.11 Math.clz32(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  clz32: function clz32(x) {
    return (x >>>= 0) ? 31 - Math.floor(Math.log(x + 0.5) * Math.LOG2E) : 32;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.cosh.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.cosh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.12 Math.cosh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  cosh: function cosh(x) {
    return (exp(x = +x) + exp(-x)) / 2;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.expm1.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.expm1.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.14 Math.expm1(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $expm1 = __webpack_require__(/*! ./_math-expm1 */ "../node_modules/core-js/modules/_math-expm1.js");

$export($export.S + $export.F * ($expm1 != Math.expm1), 'Math', {
  expm1: $expm1
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.fround.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.fround.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.16 Math.fround(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  fround: __webpack_require__(/*! ./_math-fround */ "../node_modules/core-js/modules/_math-fround.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.hypot.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.hypot.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.17 Math.hypot([value1[, value2[, … ]]])
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var abs = Math.abs;
$export($export.S, 'Math', {
  hypot: function hypot(value1, value2) {
    // eslint-disable-line no-unused-vars
    var sum = 0;
    var i = 0;
    var aLen = arguments.length;
    var larg = 0;
    var arg, div;

    while (i < aLen) {
      arg = abs(arguments[i++]);

      if (larg < arg) {
        div = larg / arg;
        sum = sum * div * div + 1;
        larg = arg;
      } else if (arg > 0) {
        div = arg / larg;
        sum += div * div;
      } else sum += arg;
    }

    return larg === Infinity ? Infinity : larg * Math.sqrt(sum);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.imul.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.imul.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.18 Math.imul(x, y)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $imul = Math.imul; // some WebKit versions fails with big numbers, some has wrong arity

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return $imul(0xffffffff, 5) != -5 || $imul.length != 2;
}), 'Math', {
  imul: function imul(x, y) {
    var UINT16 = 0xffff;
    var xn = +x;
    var yn = +y;
    var xl = UINT16 & xn;
    var yl = UINT16 & yn;
    return 0 | xl * yl + ((UINT16 & xn >>> 16) * yl + xl * (UINT16 & yn >>> 16) << 16 >>> 0);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.log10.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.log10.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log10: function log10(x) {
    return Math.log(x) * Math.LOG10E;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.log1p.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.log1p.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.20 Math.log1p(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log1p: __webpack_require__(/*! ./_math-log1p */ "../node_modules/core-js/modules/_math-log1p.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.log2.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.log2.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  log2: function log2(x) {
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.sign.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.sign.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.28 Math.sign(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  sign: __webpack_require__(/*! ./_math-sign */ "../node_modules/core-js/modules/_math-sign.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.sinh.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.sinh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.30 Math.sinh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "../node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp; // V8 near Chromium 38 has a problem with very small numbers

$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return !Math.sinh(-2e-17) != -2e-17;
}), 'Math', {
  sinh: function sinh(x) {
    return Math.abs(x = +x) < 1 ? (expm1(x) - expm1(-x)) / 2 : (exp(x - 1) - exp(-x - 1)) * (Math.E / 2);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.tanh.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.tanh.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.33 Math.tanh(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var expm1 = __webpack_require__(/*! ./_math-expm1 */ "../node_modules/core-js/modules/_math-expm1.js");

var exp = Math.exp;
$export($export.S, 'Math', {
  tanh: function tanh(x) {
    var a = expm1(x = +x);
    var b = expm1(-x);
    return a == Infinity ? 1 : b == Infinity ? -1 : (a - b) / (exp(x) + exp(-x));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.math.trunc.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.math.trunc.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.34 Math.trunc(x)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Math', {
  trunc: function trunc(it) {
    return (it > 0 ? Math.floor : Math.ceil)(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.constructor.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.constructor.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var cof = __webpack_require__(/*! ./_cof */ "../node_modules/core-js/modules/_cof.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "../node_modules/core-js/modules/_inherit-if-required.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f;

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var $trim = __webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js").trim;

var NUMBER = 'Number';
var $Number = global[NUMBER];
var Base = $Number;
var proto = $Number.prototype; // Opera ~12 has broken Object#toString

var BROKEN_COF = cof(__webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js")(proto)) == NUMBER;
var TRIM = 'trim' in String.prototype; // 7.1.3 ToNumber(argument)

var toNumber = function toNumber(argument) {
  var it = toPrimitive(argument, false);

  if (typeof it == 'string' && it.length > 2) {
    it = TRIM ? it.trim() : $trim(it, 3);
    var first = it.charCodeAt(0);
    var third, radix, maxCode;

    if (first === 43 || first === 45) {
      third = it.charCodeAt(2);
      if (third === 88 || third === 120) return NaN; // Number('+0x1') should be NaN, old V8 fix
    } else if (first === 48) {
      switch (it.charCodeAt(1)) {
        case 66:
        case 98:
          radix = 2;
          maxCode = 49;
          break;
        // fast equal /^0b[01]+$/i

        case 79:
        case 111:
          radix = 8;
          maxCode = 55;
          break;
        // fast equal /^0o[0-7]+$/i

        default:
          return +it;
      }

      for (var digits = it.slice(2), i = 0, l = digits.length, code; i < l; i++) {
        code = digits.charCodeAt(i); // parseInt parses a string to a first unavailable symbol
        // but ToNumber should return NaN if a string contains unavailable symbols

        if (code < 48 || code > maxCode) return NaN;
      }

      return parseInt(digits, radix);
    }
  }

  return +it;
};

if (!$Number(' 0o1') || !$Number('0b1') || $Number('+0x1')) {
  $Number = function Number(value) {
    var it = arguments.length < 1 ? 0 : value;
    var that = this;
    return that instanceof $Number // check on 1..constructor(foo) case
    && (BROKEN_COF ? fails(function () {
      proto.valueOf.call(that);
    }) : cof(that) != NUMBER) ? inheritIfRequired(new Base(toNumber(it)), that, $Number) : toNumber(it);
  };

  for (var keys = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") ? gOPN(Base) : ( // ES3:
  'MAX_VALUE,MIN_VALUE,NaN,NEGATIVE_INFINITY,POSITIVE_INFINITY,' + // ES6 (in case, if modules with ES6 Number statics required before):
  'EPSILON,isFinite,isInteger,isNaN,isSafeInteger,MAX_SAFE_INTEGER,' + 'MIN_SAFE_INTEGER,parseFloat,parseInt,isInteger').split(','), j = 0, key; keys.length > j; j++) {
    if (has(Base, key = keys[j]) && !has($Number, key)) {
      dP($Number, key, gOPD(Base, key));
    }
  }

  $Number.prototype = proto;
  proto.constructor = $Number;

  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(global, NUMBER, $Number);
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.epsilon.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.epsilon.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.1 Number.EPSILON
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  EPSILON: Math.pow(2, -52)
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-finite.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-finite.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.2 Number.isFinite(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var _isFinite = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").isFinite;

$export($export.S, 'Number', {
  isFinite: function isFinite(it) {
    return typeof it == 'number' && _isFinite(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-integer.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-integer.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.3 Number.isInteger(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isInteger: __webpack_require__(/*! ./_is-integer */ "../node_modules/core-js/modules/_is-integer.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-nan.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-nan.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.4 Number.isNaN(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  isNaN: function isNaN(number) {
    // eslint-disable-next-line no-self-compare
    return number != number;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.is-safe-integer.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.is-safe-integer.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.5 Number.isSafeInteger(number)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var isInteger = __webpack_require__(/*! ./_is-integer */ "../node_modules/core-js/modules/_is-integer.js");

var abs = Math.abs;
$export($export.S, 'Number', {
  isSafeInteger: function isSafeInteger(number) {
    return isInteger(number) && abs(number) <= 0x1fffffffffffff;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.max-safe-integer.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.max-safe-integer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.6 Number.MAX_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MAX_SAFE_INTEGER: 0x1fffffffffffff
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.min-safe-integer.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.min-safe-integer.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 20.1.2.10 Number.MIN_SAFE_INTEGER
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Number', {
  MIN_SAFE_INTEGER: -0x1fffffffffffff
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.parse-float.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.parse-float.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "../node_modules/core-js/modules/_parse-float.js"); // 20.1.2.12 Number.parseFloat(string)


$export($export.S + $export.F * (Number.parseFloat != $parseFloat), 'Number', {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.parse-int.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.parse-int.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "../node_modules/core-js/modules/_parse-int.js"); // 20.1.2.13 Number.parseInt(string, radix)


$export($export.S + $export.F * (Number.parseInt != $parseInt), 'Number', {
  parseInt: $parseInt
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.to-fixed.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.to-fixed.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "../node_modules/core-js/modules/_a-number-value.js");

var repeat = __webpack_require__(/*! ./_string-repeat */ "../node_modules/core-js/modules/_string-repeat.js");

var $toFixed = 1.0.toFixed;
var floor = Math.floor;
var data = [0, 0, 0, 0, 0, 0];
var ERROR = 'Number.toFixed: incorrect invocation!';
var ZERO = '0';

var multiply = function multiply(n, c) {
  var i = -1;
  var c2 = c;

  while (++i < 6) {
    c2 += n * data[i];
    data[i] = c2 % 1e7;
    c2 = floor(c2 / 1e7);
  }
};

var divide = function divide(n) {
  var i = 6;
  var c = 0;

  while (--i >= 0) {
    c += data[i];
    data[i] = floor(c / n);
    c = c % n * 1e7;
  }
};

var numToString = function numToString() {
  var i = 6;
  var s = '';

  while (--i >= 0) {
    if (s !== '' || i === 0 || data[i] !== 0) {
      var t = String(data[i]);
      s = s === '' ? t : s + repeat.call(ZERO, 7 - t.length) + t;
    }
  }

  return s;
};

var pow = function pow(x, n, acc) {
  return n === 0 ? acc : n % 2 === 1 ? pow(x, n - 1, acc * x) : pow(x * x, n / 2, acc);
};

var log = function log(x) {
  var n = 0;
  var x2 = x;

  while (x2 >= 4096) {
    n += 12;
    x2 /= 4096;
  }

  while (x2 >= 2) {
    n += 1;
    x2 /= 2;
  }

  return n;
};

$export($export.P + $export.F * (!!$toFixed && (0.00008.toFixed(3) !== '0.000' || 0.9.toFixed(0) !== '1' || 1.255.toFixed(2) !== '1.25' || 1000000000000000128.0.toFixed(0) !== '1000000000000000128') || !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  // V8 ~ Android 4.3-
  $toFixed.call({});
})), 'Number', {
  toFixed: function toFixed(fractionDigits) {
    var x = aNumberValue(this, ERROR);
    var f = toInteger(fractionDigits);
    var s = '';
    var m = ZERO;
    var e, z, j, k;
    if (f < 0 || f > 20) throw RangeError(ERROR); // eslint-disable-next-line no-self-compare

    if (x != x) return 'NaN';
    if (x <= -1e21 || x >= 1e21) return String(x);

    if (x < 0) {
      s = '-';
      x = -x;
    }

    if (x > 1e-21) {
      e = log(x * pow(2, 69, 1)) - 69;
      z = e < 0 ? x * pow(2, -e, 1) : x / pow(2, e, 1);
      z *= 0x10000000000000;
      e = 52 - e;

      if (e > 0) {
        multiply(0, z);
        j = f;

        while (j >= 7) {
          multiply(1e7, 0);
          j -= 7;
        }

        multiply(pow(10, j, 1), 0);
        j = e - 1;

        while (j >= 23) {
          divide(1 << 23);
          j -= 23;
        }

        divide(1 << j);
        multiply(1, 1);
        divide(2);
        m = numToString();
      } else {
        multiply(0, z);
        multiply(1 << -e, 0);
        m = numToString() + repeat.call(ZERO, f);
      }
    }

    if (f > 0) {
      k = m.length;
      m = s + (k <= f ? '0.' + repeat.call(ZERO, f - k) + m : m.slice(0, k - f) + '.' + m.slice(k - f));
    } else {
      m = s + m;
    }

    return m;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.number.to-precision.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.number.to-precision.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var aNumberValue = __webpack_require__(/*! ./_a-number-value */ "../node_modules/core-js/modules/_a-number-value.js");

var $toPrecision = 1.0.toPrecision;
$export($export.P + $export.F * ($fails(function () {
  // IE7-
  return $toPrecision.call(1, undefined) !== '1';
}) || !$fails(function () {
  // V8 ~ Android 4.3-
  $toPrecision.call({});
})), 'Number', {
  toPrecision: function toPrecision(precision) {
    var that = aNumberValue(this, 'Number#toPrecision: incorrect invocation!');
    return precision === undefined ? $toPrecision.call(that) : $toPrecision.call(that, precision);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.assign.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.assign.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.1 Object.assign(target, source)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S + $export.F, 'Object', {
  assign: __webpack_require__(/*! ./_object-assign */ "../node_modules/core-js/modules/_object-assign.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.create.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.create.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js"); // 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])


$export($export.S, 'Object', {
  create: __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.define-properties.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.define-properties.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js"); // 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperties: __webpack_require__(/*! ./_object-dps */ "../node_modules/core-js/modules/_object-dps.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.define-property.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.define-property.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js"); // 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)


$export($export.S + $export.F * !__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js"), 'Object', {
  defineProperty: __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.freeze.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.freeze.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.5 Object.freeze(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('freeze', function ($freeze) {
  return function freeze(it) {
    return $freeze && isObject(it) ? $freeze(meta(it)) : it;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js":
/*!*********************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.get-own-property-descriptor.js ***!
  \*********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var $getOwnPropertyDescriptor = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('getOwnPropertyDescriptor', function () {
  return function getOwnPropertyDescriptor(it, key) {
    return $getOwnPropertyDescriptor(toIObject(it), key);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.get-own-property-names.js":
/*!****************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.get-own-property-names.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.7 Object.getOwnPropertyNames(O)
__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('getOwnPropertyNames', function () {
  return __webpack_require__(/*! ./_object-gopn-ext */ "../node_modules/core-js/modules/_object-gopn-ext.js").f;
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.get-prototype-of.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.get-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.9 Object.getPrototypeOf(O)
var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var $getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('getPrototypeOf', function () {
  return function getPrototypeOf(it) {
    return $getPrototypeOf(toObject(it));
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is-extensible.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is-extensible.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.11 Object.isExtensible(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('isExtensible', function ($isExtensible) {
  return function isExtensible(it) {
    return isObject(it) ? $isExtensible ? $isExtensible(it) : true : false;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is-frozen.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is-frozen.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.12 Object.isFrozen(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('isFrozen', function ($isFrozen) {
  return function isFrozen(it) {
    return isObject(it) ? $isFrozen ? $isFrozen(it) : false : true;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is-sealed.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is-sealed.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.13 Object.isSealed(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('isSealed', function ($isSealed) {
  return function isSealed(it) {
    return isObject(it) ? $isSealed ? $isSealed(it) : false : true;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.is.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.is.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.10 Object.is(value1, value2)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  is: __webpack_require__(/*! ./_same-value */ "../node_modules/core-js/modules/_same-value.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.keys.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.keys.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.14 Object.keys(O)
var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('keys', function () {
  return function keys(it) {
    return $keys(toObject(it));
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.prevent-extensions.js":
/*!************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.prevent-extensions.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.15 Object.preventExtensions(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('preventExtensions', function ($preventExtensions) {
  return function preventExtensions(it) {
    return $preventExtensions && isObject(it) ? $preventExtensions(meta(it)) : it;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.seal.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.seal.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.2.17 Object.seal(O)
var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").onFreeze;

__webpack_require__(/*! ./_object-sap */ "../node_modules/core-js/modules/_object-sap.js")('seal', function ($seal) {
  return function seal(it) {
    return $seal && isObject(it) ? $seal(meta(it)) : it;
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.set-prototype-of.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.set-prototype-of.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 19.1.3.19 Object.setPrototypeOf(O, proto)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Object', {
  setPrototypeOf: __webpack_require__(/*! ./_set-proto */ "../node_modules/core-js/modules/_set-proto.js").set
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.object.to-string.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.object.to-string.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 19.1.3.6 Object.prototype.toString()

var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var test = {};
test[__webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('toStringTag')] = 'z';

if (test + '' != '[object z]') {
  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(Object.prototype, 'toString', function toString() {
    return '[object ' + classof(this) + ']';
  }, true);
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.parse-float.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.parse-float.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseFloat = __webpack_require__(/*! ./_parse-float */ "../node_modules/core-js/modules/_parse-float.js"); // 18.2.4 parseFloat(string)


$export($export.G + $export.F * (parseFloat != $parseFloat), {
  parseFloat: $parseFloat
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.parse-int.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.parse-int.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $parseInt = __webpack_require__(/*! ./_parse-int */ "../node_modules/core-js/modules/_parse-int.js"); // 18.2.5 parseInt(string, radix)


$export($export.G + $export.F * (parseInt != $parseInt), {
  parseInt: $parseInt
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.promise.js":
/*!******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.promise.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var LIBRARY = __webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var ctx = __webpack_require__(/*! ./_ctx */ "../node_modules/core-js/modules/_ctx.js");

var classof = __webpack_require__(/*! ./_classof */ "../node_modules/core-js/modules/_classof.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var anInstance = __webpack_require__(/*! ./_an-instance */ "../node_modules/core-js/modules/_an-instance.js");

var forOf = __webpack_require__(/*! ./_for-of */ "../node_modules/core-js/modules/_for-of.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var task = __webpack_require__(/*! ./_task */ "../node_modules/core-js/modules/_task.js").set;

var microtask = __webpack_require__(/*! ./_microtask */ "../node_modules/core-js/modules/_microtask.js")();

var newPromiseCapabilityModule = __webpack_require__(/*! ./_new-promise-capability */ "../node_modules/core-js/modules/_new-promise-capability.js");

var perform = __webpack_require__(/*! ./_perform */ "../node_modules/core-js/modules/_perform.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "../node_modules/core-js/modules/_promise-resolve.js");

var PROMISE = 'Promise';
var TypeError = global.TypeError;
var process = global.process;
var versions = process && process.versions;
var v8 = versions && versions.v8 || '';
var $Promise = global[PROMISE];
var isNode = classof(process) == 'process';

var empty = function empty() {
  /* empty */
};

var Internal, newGenericPromiseCapability, OwnPromiseCapability, Wrapper;
var newPromiseCapability = newGenericPromiseCapability = newPromiseCapabilityModule.f;
var USE_NATIVE = !!function () {
  try {
    // correct subclassing with @@species support
    var promise = $Promise.resolve(1);

    var FakePromise = (promise.constructor = {})[__webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('species')] = function (exec) {
      exec(empty, empty);
    }; // unhandled rejections tracking support, NodeJS Promise without it fails @@species test


    return (isNode || typeof PromiseRejectionEvent == 'function') && promise.then(empty) instanceof FakePromise // v8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
    // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
    // we can't detect it synchronously, so just check versions
    && v8.indexOf('6.6') !== 0 && userAgent.indexOf('Chrome/66') === -1;
  } catch (e) {
    /* empty */
  }
}(); // helpers

var isThenable = function isThenable(it) {
  var then;
  return isObject(it) && typeof (then = it.then) == 'function' ? then : false;
};

var notify = function notify(promise, isReject) {
  if (promise._n) return;
  promise._n = true;
  var chain = promise._c;
  microtask(function () {
    var value = promise._v;
    var ok = promise._s == 1;
    var i = 0;

    var run = function run(reaction) {
      var handler = ok ? reaction.ok : reaction.fail;
      var resolve = reaction.resolve;
      var reject = reaction.reject;
      var domain = reaction.domain;
      var result, then, exited;

      try {
        if (handler) {
          if (!ok) {
            if (promise._h == 2) onHandleUnhandled(promise);
            promise._h = 1;
          }

          if (handler === true) result = value;else {
            if (domain) domain.enter();
            result = handler(value); // may throw

            if (domain) {
              domain.exit();
              exited = true;
            }
          }

          if (result === reaction.promise) {
            reject(TypeError('Promise-chain cycle'));
          } else if (then = isThenable(result)) {
            then.call(result, resolve, reject);
          } else resolve(result);
        } else reject(value);
      } catch (e) {
        if (domain && !exited) domain.exit();
        reject(e);
      }
    };

    while (chain.length > i) {
      run(chain[i++]);
    } // variable length - can't use forEach


    promise._c = [];
    promise._n = false;
    if (isReject && !promise._h) onUnhandled(promise);
  });
};

var onUnhandled = function onUnhandled(promise) {
  task.call(global, function () {
    var value = promise._v;
    var unhandled = isUnhandled(promise);
    var result, handler, console;

    if (unhandled) {
      result = perform(function () {
        if (isNode) {
          process.emit('unhandledRejection', value, promise);
        } else if (handler = global.onunhandledrejection) {
          handler({
            promise: promise,
            reason: value
          });
        } else if ((console = global.console) && console.error) {
          console.error('Unhandled promise rejection', value);
        }
      }); // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should

      promise._h = isNode || isUnhandled(promise) ? 2 : 1;
    }

    promise._a = undefined;
    if (unhandled && result.e) throw result.v;
  });
};

var isUnhandled = function isUnhandled(promise) {
  return promise._h !== 1 && (promise._a || promise._c).length === 0;
};

var onHandleUnhandled = function onHandleUnhandled(promise) {
  task.call(global, function () {
    var handler;

    if (isNode) {
      process.emit('rejectionHandled', promise);
    } else if (handler = global.onrejectionhandled) {
      handler({
        promise: promise,
        reason: promise._v
      });
    }
  });
};

var $reject = function $reject(value) {
  var promise = this;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  promise._v = value;
  promise._s = 2;
  if (!promise._a) promise._a = promise._c.slice();
  notify(promise, true);
};

var $resolve = function $resolve(value) {
  var promise = this;
  var then;
  if (promise._d) return;
  promise._d = true;
  promise = promise._w || promise; // unwrap

  try {
    if (promise === value) throw TypeError("Promise can't be resolved itself");

    if (then = isThenable(value)) {
      microtask(function () {
        var wrapper = {
          _w: promise,
          _d: false
        }; // wrap

        try {
          then.call(value, ctx($resolve, wrapper, 1), ctx($reject, wrapper, 1));
        } catch (e) {
          $reject.call(wrapper, e);
        }
      });
    } else {
      promise._v = value;
      promise._s = 1;
      notify(promise, false);
    }
  } catch (e) {
    $reject.call({
      _w: promise,
      _d: false
    }, e); // wrap
  }
}; // constructor polyfill


if (!USE_NATIVE) {
  // 25.4.3.1 Promise(executor)
  $Promise = function Promise(executor) {
    anInstance(this, $Promise, PROMISE, '_h');
    aFunction(executor);
    Internal.call(this);

    try {
      executor(ctx($resolve, this, 1), ctx($reject, this, 1));
    } catch (err) {
      $reject.call(this, err);
    }
  }; // eslint-disable-next-line no-unused-vars


  Internal = function Promise(executor) {
    this._c = []; // <- awaiting reactions

    this._a = undefined; // <- checked in isUnhandled reactions

    this._s = 0; // <- state

    this._d = false; // <- done

    this._v = undefined; // <- value

    this._h = 0; // <- rejection state, 0 - default, 1 - handled, 2 - unhandled

    this._n = false; // <- notify
  };

  Internal.prototype = __webpack_require__(/*! ./_redefine-all */ "../node_modules/core-js/modules/_redefine-all.js")($Promise.prototype, {
    // 25.4.5.3 Promise.prototype.then(onFulfilled, onRejected)
    then: function then(onFulfilled, onRejected) {
      var reaction = newPromiseCapability(speciesConstructor(this, $Promise));
      reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
      reaction.fail = typeof onRejected == 'function' && onRejected;
      reaction.domain = isNode ? process.domain : undefined;

      this._c.push(reaction);

      if (this._a) this._a.push(reaction);
      if (this._s) notify(this, false);
      return reaction.promise;
    },
    // 25.4.5.1 Promise.prototype.catch(onRejected)
    'catch': function _catch(onRejected) {
      return this.then(undefined, onRejected);
    }
  });

  OwnPromiseCapability = function OwnPromiseCapability() {
    var promise = new Internal();
    this.promise = promise;
    this.resolve = ctx($resolve, promise, 1);
    this.reject = ctx($reject, promise, 1);
  };

  newPromiseCapabilityModule.f = newPromiseCapability = function newPromiseCapability(C) {
    return C === $Promise || C === Wrapper ? new OwnPromiseCapability(C) : newGenericPromiseCapability(C);
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Promise: $Promise
});

__webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js")($Promise, PROMISE);

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")(PROMISE);

Wrapper = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js")[PROMISE]; // statics

$export($export.S + $export.F * !USE_NATIVE, PROMISE, {
  // 25.4.4.5 Promise.reject(r)
  reject: function reject(r) {
    var capability = newPromiseCapability(this);
    var $$reject = capability.reject;
    $$reject(r);
    return capability.promise;
  }
});
$export($export.S + $export.F * (LIBRARY || !USE_NATIVE), PROMISE, {
  // 25.4.4.6 Promise.resolve(x)
  resolve: function resolve(x) {
    return promiseResolve(LIBRARY && this === Wrapper ? $Promise : this, x);
  }
});
$export($export.S + $export.F * !(USE_NATIVE && __webpack_require__(/*! ./_iter-detect */ "../node_modules/core-js/modules/_iter-detect.js")(function (iter) {
  $Promise.all(iter)['catch'](empty);
})), PROMISE, {
  // 25.4.4.1 Promise.all(iterable)
  all: function all(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var resolve = capability.resolve;
    var reject = capability.reject;
    var result = perform(function () {
      var values = [];
      var index = 0;
      var remaining = 1;
      forOf(iterable, false, function (promise) {
        var $index = index++;
        var alreadyCalled = false;
        values.push(undefined);
        remaining++;
        C.resolve(promise).then(function (value) {
          if (alreadyCalled) return;
          alreadyCalled = true;
          values[$index] = value;
          --remaining || resolve(values);
        }, reject);
      });
      --remaining || resolve(values);
    });
    if (result.e) reject(result.v);
    return capability.promise;
  },
  // 25.4.4.4 Promise.race(iterable)
  race: function race(iterable) {
    var C = this;
    var capability = newPromiseCapability(C);
    var reject = capability.reject;
    var result = perform(function () {
      forOf(iterable, false, function (promise) {
        C.resolve(promise).then(capability.resolve, reject);
      });
    });
    if (result.e) reject(result.v);
    return capability.promise;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.apply.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.apply.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.1 Reflect.apply(target, thisArgument, argumentsList)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var rApply = (__webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Reflect || {}).apply;
var fApply = Function.apply; // MS Edge argumentsList argument is optional

$export($export.S + $export.F * !__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  rApply(function () {
    /* empty */
  });
}), 'Reflect', {
  apply: function apply(target, thisArgument, argumentsList) {
    var T = aFunction(target);
    var L = anObject(argumentsList);
    return rApply ? rApply(T, thisArgument, L) : fApply.call(T, thisArgument, L);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.construct.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.construct.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.2 Reflect.construct(target, argumentsList [, newTarget])
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var bind = __webpack_require__(/*! ./_bind */ "../node_modules/core-js/modules/_bind.js");

var rConstruct = (__webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").Reflect || {}).construct; // MS Edge supports only 2 arguments and argumentsList argument is optional
// FF Nightly sets third argument as `new.target`, but does not create `this` from it

var NEW_TARGET_BUG = fails(function () {
  function F() {
    /* empty */
  }

  return !(rConstruct(function () {
    /* empty */
  }, [], F) instanceof F);
});
var ARGS_BUG = !fails(function () {
  rConstruct(function () {
    /* empty */
  });
});
$export($export.S + $export.F * (NEW_TARGET_BUG || ARGS_BUG), 'Reflect', {
  construct: function construct(Target, args
  /* , newTarget */
  ) {
    aFunction(Target);
    anObject(args);
    var newTarget = arguments.length < 3 ? Target : aFunction(arguments[2]);
    if (ARGS_BUG && !NEW_TARGET_BUG) return rConstruct(Target, args, newTarget);

    if (Target == newTarget) {
      // w/o altered newTarget, optimization for 0-4 arguments
      switch (args.length) {
        case 0:
          return new Target();

        case 1:
          return new Target(args[0]);

        case 2:
          return new Target(args[0], args[1]);

        case 3:
          return new Target(args[0], args[1], args[2]);

        case 4:
          return new Target(args[0], args[1], args[2], args[3]);
      } // w/o altered newTarget, lot of arguments case


      var $args = [null];
      $args.push.apply($args, args);
      return new (bind.apply(Target, $args))();
    } // with altered newTarget, not support built-in constructors


    var proto = newTarget.prototype;
    var instance = create(isObject(proto) ? proto : Object.prototype);
    var result = Function.apply.call(Target, instance, args);
    return isObject(result) ? result : instance;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.define-property.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.define-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.3 Reflect.defineProperty(target, propertyKey, attributes)
var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js"); // MS Edge has broken Reflect.defineProperty - throwing instead of returning false


$export($export.S + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  // eslint-disable-next-line no-undef
  Reflect.defineProperty(dP.f({}, 1, {
    value: 1
  }), 1, {
    value: 2
  });
}), 'Reflect', {
  defineProperty: function defineProperty(target, propertyKey, attributes) {
    anObject(target);
    propertyKey = toPrimitive(propertyKey, true);
    anObject(attributes);

    try {
      dP.f(target, propertyKey, attributes);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.delete-property.js":
/*!**********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.delete-property.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.4 Reflect.deleteProperty(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js").f;

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  deleteProperty: function deleteProperty(target, propertyKey) {
    var desc = gOPD(anObject(target), propertyKey);
    return desc && !desc.configurable ? false : delete target[propertyKey];
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.enumerate.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.enumerate.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 26.1.5 Reflect.enumerate(target)

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var Enumerate = function Enumerate(iterated) {
  this._t = anObject(iterated); // target

  this._i = 0; // next index

  var keys = this._k = []; // keys

  var key;

  for (key in iterated) {
    keys.push(key);
  }
};

__webpack_require__(/*! ./_iter-create */ "../node_modules/core-js/modules/_iter-create.js")(Enumerate, 'Object', function () {
  var that = this;
  var keys = that._k;
  var key;

  do {
    if (that._i >= keys.length) return {
      value: undefined,
      done: true
    };
  } while (!((key = keys[that._i++]) in that._t));

  return {
    value: key,
    done: false
  };
});

$export($export.S, 'Reflect', {
  enumerate: function enumerate(target) {
    return new Enumerate(target);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.get-own-property-descriptor.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.7 Reflect.getOwnPropertyDescriptor(target, propertyKey)
var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
    return gOPD.f(anObject(target), propertyKey);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.get-prototype-of.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.get-prototype-of.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.8 Reflect.getPrototypeOf(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var getProto = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

$export($export.S, 'Reflect', {
  getPrototypeOf: function getPrototypeOf(target) {
    return getProto(anObject(target));
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.get.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.get.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.6 Reflect.get(target, propertyKey [, receiver])
var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

function get(target, propertyKey
/* , receiver */
) {
  var receiver = arguments.length < 3 ? target : arguments[2];
  var desc, proto;
  if (anObject(target) === receiver) return target[propertyKey];
  if (desc = gOPD.f(target, propertyKey)) return has(desc, 'value') ? desc.value : desc.get !== undefined ? desc.get.call(receiver) : undefined;
  if (isObject(proto = getPrototypeOf(target))) return get(proto, propertyKey, receiver);
}

$export($export.S, 'Reflect', {
  get: get
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.has.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.has.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.9 Reflect.has(target, propertyKey)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  has: function has(target, propertyKey) {
    return propertyKey in target;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.is-extensible.js":
/*!********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.is-extensible.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.10 Reflect.isExtensible(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var $isExtensible = Object.isExtensible;
$export($export.S, 'Reflect', {
  isExtensible: function isExtensible(target) {
    anObject(target);
    return $isExtensible ? $isExtensible(target) : true;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.own-keys.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.own-keys.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.11 Reflect.ownKeys(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.S, 'Reflect', {
  ownKeys: __webpack_require__(/*! ./_own-keys */ "../node_modules/core-js/modules/_own-keys.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.prevent-extensions.js":
/*!*************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.prevent-extensions.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.12 Reflect.preventExtensions(target)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var $preventExtensions = Object.preventExtensions;
$export($export.S, 'Reflect', {
  preventExtensions: function preventExtensions(target) {
    anObject(target);

    try {
      if ($preventExtensions) $preventExtensions(target);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.set-prototype-of.js":
/*!***********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.set-prototype-of.js ***!
  \***********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.14 Reflect.setPrototypeOf(target, proto)
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var setProto = __webpack_require__(/*! ./_set-proto */ "../node_modules/core-js/modules/_set-proto.js");

if (setProto) $export($export.S, 'Reflect', {
  setPrototypeOf: function setPrototypeOf(target, proto) {
    setProto.check(target, proto);

    try {
      setProto.set(target, proto);
      return true;
    } catch (e) {
      return false;
    }
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.reflect.set.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.reflect.set.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 26.1.13 Reflect.set(target, propertyKey, V [, receiver])
var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var getPrototypeOf = __webpack_require__(/*! ./_object-gpo */ "../node_modules/core-js/modules/_object-gpo.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

function set(target, propertyKey, V
/* , receiver */
) {
  var receiver = arguments.length < 4 ? target : arguments[3];
  var ownDesc = gOPD.f(anObject(target), propertyKey);
  var existingDescriptor, proto;

  if (!ownDesc) {
    if (isObject(proto = getPrototypeOf(target))) {
      return set(proto, propertyKey, V, receiver);
    }

    ownDesc = createDesc(0);
  }

  if (has(ownDesc, 'value')) {
    if (ownDesc.writable === false || !isObject(receiver)) return false;

    if (existingDescriptor = gOPD.f(receiver, propertyKey)) {
      if (existingDescriptor.get || existingDescriptor.set || existingDescriptor.writable === false) return false;
      existingDescriptor.value = V;
      dP.f(receiver, propertyKey, existingDescriptor);
    } else dP.f(receiver, propertyKey, createDesc(0, V));

    return true;
  }

  return ownDesc.set === undefined ? false : (ownDesc.set.call(receiver, V), true);
}

$export($export.S, 'Reflect', {
  set: set
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.constructor.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.constructor.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var inheritIfRequired = __webpack_require__(/*! ./_inherit-if-required */ "../node_modules/core-js/modules/_inherit-if-required.js");

var dP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f;

var gOPN = __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f;

var isRegExp = __webpack_require__(/*! ./_is-regexp */ "../node_modules/core-js/modules/_is-regexp.js");

var $flags = __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js");

var $RegExp = global.RegExp;
var Base = $RegExp;
var proto = $RegExp.prototype;
var re1 = /a/g;
var re2 = /a/g; // "new" creates a new object, old webkit buggy here

var CORRECT_NEW = new $RegExp(re1) !== re1;

if (__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && (!CORRECT_NEW || __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  re2[__webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js")('match')] = false; // RegExp constructor can alter flags and IsRegExp works correct with @@match

  return $RegExp(re1) != re1 || $RegExp(re2) == re2 || $RegExp(re1, 'i') != '/a/i';
}))) {
  $RegExp = function RegExp(p, f) {
    var tiRE = this instanceof $RegExp;
    var piRE = isRegExp(p);
    var fiU = f === undefined;
    return !tiRE && piRE && p.constructor === $RegExp && fiU ? p : inheritIfRequired(CORRECT_NEW ? new Base(piRE && !fiU ? p.source : p, f) : Base((piRE = p instanceof $RegExp) ? p.source : p, piRE && fiU ? $flags.call(p) : f), tiRE ? this : proto, $RegExp);
  };

  var proxy = function proxy(key) {
    key in $RegExp || dP($RegExp, key, {
      configurable: true,
      get: function get() {
        return Base[key];
      },
      set: function set(it) {
        Base[key] = it;
      }
    });
  };

  for (var keys = gOPN(Base), i = 0; keys.length > i;) {
    proxy(keys[i++]);
  }

  proto.constructor = $RegExp;
  $RegExp.prototype = proto;

  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(global, 'RegExp', $RegExp);
}

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")('RegExp');

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.exec.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.exec.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "../node_modules/core-js/modules/_regexp-exec.js");

__webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js")({
  target: 'RegExp',
  proto: true,
  forced: regexpExec !== /./.exec
}, {
  exec: regexpExec
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.flags.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.flags.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 21.2.5.3 get RegExp.prototype.flags()
if (__webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js") && /./g.flags != 'g') __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js").f(RegExp.prototype, 'flags', {
  configurable: true,
  get: __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.match.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.match.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "../node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@match logic


__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('match', 1, function (defined, MATCH, $match, maybeCallNative) {
  return [// `String.prototype.match` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.match
  function match(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[MATCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[MATCH](String(O));
  }, // `RegExp.prototype[@@match]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@match
  function (regexp) {
    var res = maybeCallNative($match, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    if (!rx.global) return regExpExec(rx, S);
    var fullUnicode = rx.unicode;
    rx.lastIndex = 0;
    var A = [];
    var n = 0;
    var result;

    while ((result = regExpExec(rx, S)) !== null) {
      var matchStr = String(result[0]);
      A[n] = matchStr;
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
      n++;
    }

    return n === 0 ? null : A;
  }];
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.replace.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.replace.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var toInteger = __webpack_require__(/*! ./_to-integer */ "../node_modules/core-js/modules/_to-integer.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "../node_modules/core-js/modules/_advance-string-index.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js");

var max = Math.max;
var min = Math.min;
var floor = Math.floor;
var SUBSTITUTION_SYMBOLS = /\$([$&`']|\d\d?|<[^>]*>)/g;
var SUBSTITUTION_SYMBOLS_NO_NAMED = /\$([$&`']|\d\d?)/g;

var maybeToString = function maybeToString(it) {
  return it === undefined ? it : String(it);
}; // @@replace logic


__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('replace', 2, function (defined, REPLACE, $replace, maybeCallNative) {
  return [// `String.prototype.replace` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.replace
  function replace(searchValue, replaceValue) {
    var O = defined(this);
    var fn = searchValue == undefined ? undefined : searchValue[REPLACE];
    return fn !== undefined ? fn.call(searchValue, O, replaceValue) : $replace.call(String(O), searchValue, replaceValue);
  }, // `RegExp.prototype[@@replace]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@replace
  function (regexp, replaceValue) {
    var res = maybeCallNative($replace, regexp, this, replaceValue);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var functionalReplace = typeof replaceValue === 'function';
    if (!functionalReplace) replaceValue = String(replaceValue);
    var global = rx.global;

    if (global) {
      var fullUnicode = rx.unicode;
      rx.lastIndex = 0;
    }

    var results = [];

    while (true) {
      var result = regExpExec(rx, S);
      if (result === null) break;
      results.push(result);
      if (!global) break;
      var matchStr = String(result[0]);
      if (matchStr === '') rx.lastIndex = advanceStringIndex(S, toLength(rx.lastIndex), fullUnicode);
    }

    var accumulatedResult = '';
    var nextSourcePosition = 0;

    for (var i = 0; i < results.length; i++) {
      result = results[i];
      var matched = String(result[0]);
      var position = max(min(toInteger(result.index), S.length), 0);
      var captures = []; // NOTE: This is equivalent to
      //   captures = result.slice(1).map(maybeToString)
      // but for some reason `nativeSlice.call(result, 1, result.length)` (called in
      // the slice polyfill when slicing native arrays) "doesn't work" in safari 9 and
      // causes a crash (https://pastebin.com/N21QzeQA) when trying to debug it.

      for (var j = 1; j < result.length; j++) {
        captures.push(maybeToString(result[j]));
      }

      var namedCaptures = result.groups;

      if (functionalReplace) {
        var replacerArgs = [matched].concat(captures, position, S);
        if (namedCaptures !== undefined) replacerArgs.push(namedCaptures);
        var replacement = String(replaceValue.apply(undefined, replacerArgs));
      } else {
        replacement = getSubstitution(matched, S, position, captures, namedCaptures, replaceValue);
      }

      if (position >= nextSourcePosition) {
        accumulatedResult += S.slice(nextSourcePosition, position) + replacement;
        nextSourcePosition = position + matched.length;
      }
    }

    return accumulatedResult + S.slice(nextSourcePosition);
  }]; // https://tc39.github.io/ecma262/#sec-getsubstitution

  function getSubstitution(matched, str, position, captures, namedCaptures, replacement) {
    var tailPos = position + matched.length;
    var m = captures.length;
    var symbols = SUBSTITUTION_SYMBOLS_NO_NAMED;

    if (namedCaptures !== undefined) {
      namedCaptures = toObject(namedCaptures);
      symbols = SUBSTITUTION_SYMBOLS;
    }

    return $replace.call(replacement, symbols, function (match, ch) {
      var capture;

      switch (ch.charAt(0)) {
        case '$':
          return '$';

        case '&':
          return matched;

        case '`':
          return str.slice(0, position);

        case "'":
          return str.slice(tailPos);

        case '<':
          capture = namedCaptures[ch.slice(1, -1)];
          break;

        default:
          // \d\d?
          var n = +ch;
          if (n === 0) return match;

          if (n > m) {
            var f = floor(n / 10);
            if (f === 0) return match;
            if (f <= m) return captures[f - 1] === undefined ? ch.charAt(1) : captures[f - 1] + ch.charAt(1);
            return match;
          }

          capture = captures[n - 1];
      }

      return capture === undefined ? '' : capture;
    });
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.search.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.search.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var sameValue = __webpack_require__(/*! ./_same-value */ "../node_modules/core-js/modules/_same-value.js");

var regExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js"); // @@search logic


__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('search', 1, function (defined, SEARCH, $search, maybeCallNative) {
  return [// `String.prototype.search` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.search
  function search(regexp) {
    var O = defined(this);
    var fn = regexp == undefined ? undefined : regexp[SEARCH];
    return fn !== undefined ? fn.call(regexp, O) : new RegExp(regexp)[SEARCH](String(O));
  }, // `RegExp.prototype[@@search]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@search
  function (regexp) {
    var res = maybeCallNative($search, regexp, this);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var previousLastIndex = rx.lastIndex;
    if (!sameValue(previousLastIndex, 0)) rx.lastIndex = 0;
    var result = regExpExec(rx, S);
    if (!sameValue(rx.lastIndex, previousLastIndex)) rx.lastIndex = previousLastIndex;
    return result === null ? -1 : result.index;
  }];
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.split.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.split.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var isRegExp = __webpack_require__(/*! ./_is-regexp */ "../node_modules/core-js/modules/_is-regexp.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var advanceStringIndex = __webpack_require__(/*! ./_advance-string-index */ "../node_modules/core-js/modules/_advance-string-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var callRegExpExec = __webpack_require__(/*! ./_regexp-exec-abstract */ "../node_modules/core-js/modules/_regexp-exec-abstract.js");

var regexpExec = __webpack_require__(/*! ./_regexp-exec */ "../node_modules/core-js/modules/_regexp-exec.js");

var fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var $min = Math.min;
var $push = [].push;
var $SPLIT = 'split';
var LENGTH = 'length';
var LAST_INDEX = 'lastIndex';
var MAX_UINT32 = 0xffffffff; // babel-minify transpiles RegExp('x', 'y') -> /x/y and it causes SyntaxError

var SUPPORTS_Y = !fails(function () {
  RegExp(MAX_UINT32, 'y');
}); // @@split logic

__webpack_require__(/*! ./_fix-re-wks */ "../node_modules/core-js/modules/_fix-re-wks.js")('split', 2, function (defined, SPLIT, $split, maybeCallNative) {
  var internalSplit;

  if ('abbc'[$SPLIT](/(b)*/)[1] == 'c' || 'test'[$SPLIT](/(?:)/, -1)[LENGTH] != 4 || 'ab'[$SPLIT](/(?:ab)*/)[LENGTH] != 2 || '.'[$SPLIT](/(.?)(.?)/)[LENGTH] != 4 || '.'[$SPLIT](/()()/)[LENGTH] > 1 || ''[$SPLIT](/.?/)[LENGTH]) {
    // based on es5-shim implementation, need to rework it
    internalSplit = function internalSplit(separator, limit) {
      var string = String(this);
      if (separator === undefined && limit === 0) return []; // If `separator` is not a regex, use native split

      if (!isRegExp(separator)) return $split.call(string, separator, limit);
      var output = [];
      var flags = (separator.ignoreCase ? 'i' : '') + (separator.multiline ? 'm' : '') + (separator.unicode ? 'u' : '') + (separator.sticky ? 'y' : '');
      var lastLastIndex = 0;
      var splitLimit = limit === undefined ? MAX_UINT32 : limit >>> 0; // Make `global` and avoid `lastIndex` issues by working with a copy

      var separatorCopy = new RegExp(separator.source, flags + 'g');
      var match, lastIndex, lastLength;

      while (match = regexpExec.call(separatorCopy, string)) {
        lastIndex = separatorCopy[LAST_INDEX];

        if (lastIndex > lastLastIndex) {
          output.push(string.slice(lastLastIndex, match.index));
          if (match[LENGTH] > 1 && match.index < string[LENGTH]) $push.apply(output, match.slice(1));
          lastLength = match[0][LENGTH];
          lastLastIndex = lastIndex;
          if (output[LENGTH] >= splitLimit) break;
        }

        if (separatorCopy[LAST_INDEX] === match.index) separatorCopy[LAST_INDEX]++; // Avoid an infinite loop
      }

      if (lastLastIndex === string[LENGTH]) {
        if (lastLength || !separatorCopy.test('')) output.push('');
      } else output.push(string.slice(lastLastIndex));

      return output[LENGTH] > splitLimit ? output.slice(0, splitLimit) : output;
    }; // Chakra, V8

  } else if ('0'[$SPLIT](undefined, 0)[LENGTH]) {
    internalSplit = function internalSplit(separator, limit) {
      return separator === undefined && limit === 0 ? [] : $split.call(this, separator, limit);
    };
  } else {
    internalSplit = $split;
  }

  return [// `String.prototype.split` method
  // https://tc39.github.io/ecma262/#sec-string.prototype.split
  function split(separator, limit) {
    var O = defined(this);
    var splitter = separator == undefined ? undefined : separator[SPLIT];
    return splitter !== undefined ? splitter.call(separator, O, limit) : internalSplit.call(String(O), separator, limit);
  }, // `RegExp.prototype[@@split]` method
  // https://tc39.github.io/ecma262/#sec-regexp.prototype-@@split
  //
  // NOTE: This cannot be properly polyfilled in engines that don't support
  // the 'y' flag.
  function (regexp, limit) {
    var res = maybeCallNative(internalSplit, regexp, this, limit, internalSplit !== $split);
    if (res.done) return res.value;
    var rx = anObject(regexp);
    var S = String(this);
    var C = speciesConstructor(rx, RegExp);
    var unicodeMatching = rx.unicode;
    var flags = (rx.ignoreCase ? 'i' : '') + (rx.multiline ? 'm' : '') + (rx.unicode ? 'u' : '') + (SUPPORTS_Y ? 'y' : 'g'); // ^(? + rx + ) is needed, in combination with some S slicing, to
    // simulate the 'y' flag.

    var splitter = new C(SUPPORTS_Y ? rx : '^(?:' + rx.source + ')', flags);
    var lim = limit === undefined ? MAX_UINT32 : limit >>> 0;
    if (lim === 0) return [];
    if (S.length === 0) return callRegExpExec(splitter, S) === null ? [S] : [];
    var p = 0;
    var q = 0;
    var A = [];

    while (q < S.length) {
      splitter.lastIndex = SUPPORTS_Y ? q : 0;
      var z = callRegExpExec(splitter, SUPPORTS_Y ? S : S.slice(q));
      var e;

      if (z === null || (e = $min(toLength(splitter.lastIndex + (SUPPORTS_Y ? 0 : q)), S.length)) === p) {
        q = advanceStringIndex(S, q, unicodeMatching);
      } else {
        A.push(S.slice(p, q));
        if (A.length === lim) return A;

        for (var i = 1; i <= z.length - 1; i++) {
          A.push(z[i]);
          if (A.length === lim) return A;
        }

        q = p = e;
      }
    }

    A.push(S.slice(p));
    return A;
  }];
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.regexp.to-string.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.regexp.to-string.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__(/*! ./es6.regexp.flags */ "../node_modules/core-js/modules/es6.regexp.flags.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var $flags = __webpack_require__(/*! ./_flags */ "../node_modules/core-js/modules/_flags.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var TO_STRING = 'toString';
var $toString = /./[TO_STRING];

var define = function define(fn) {
  __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js")(RegExp.prototype, TO_STRING, fn, true);
}; // 21.2.5.14 RegExp.prototype.toString()


if (__webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return $toString.call({
    source: 'a',
    flags: 'b'
  }) != '/a/b';
})) {
  define(function toString() {
    var R = anObject(this);
    return '/'.concat(R.source, '/', 'flags' in R ? R.flags : !DESCRIPTORS && R instanceof RegExp ? $flags.call(R) : undefined);
  }); // FF44- RegExp#toString has a wrong name
} else if ($toString.name != TO_STRING) {
  define(function toString() {
    return $toString.call(this);
  });
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.set.js":
/*!**************************************************!*\
  !*** ../node_modules/core-js/modules/es6.set.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var strong = __webpack_require__(/*! ./_collection-strong */ "../node_modules/core-js/modules/_collection-strong.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var SET = 'Set'; // 23.2 Set Objects

module.exports = __webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(SET, function (get) {
  return function Set() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.2.3.1 Set.prototype.add(value)
  add: function add(value) {
    return strong.def(validate(this, SET), value = value === 0 ? 0 : value, value);
  }
}, strong);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.anchor.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.anchor.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.2 String.prototype.anchor(name)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('anchor', function (createHTML) {
  return function anchor(name) {
    return createHTML(this, 'a', 'name', name);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.big.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.big.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.3 String.prototype.big()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('big', function (createHTML) {
  return function big() {
    return createHTML(this, 'big', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.blink.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.blink.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.4 String.prototype.blink()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('blink', function (createHTML) {
  return function blink() {
    return createHTML(this, 'blink', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.bold.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.bold.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.5 String.prototype.bold()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('bold', function (createHTML) {
  return function bold() {
    return createHTML(this, 'b', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.code-point-at.js":
/*!*******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.code-point-at.js ***!
  \*******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $at = __webpack_require__(/*! ./_string-at */ "../node_modules/core-js/modules/_string-at.js")(false);

$export($export.P, 'String', {
  // 21.1.3.3 String.prototype.codePointAt(pos)
  codePointAt: function codePointAt(pos) {
    return $at(this, pos);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.ends-with.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.ends-with.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.6 String.prototype.endsWith(searchString [, endPosition])


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "../node_modules/core-js/modules/_string-context.js");

var ENDS_WITH = 'endsWith';
var $endsWith = ''[ENDS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "../node_modules/core-js/modules/_fails-is-regexp.js")(ENDS_WITH), 'String', {
  endsWith: function endsWith(searchString
  /* , endPosition = @length */
  ) {
    var that = context(this, searchString, ENDS_WITH);
    var endPosition = arguments.length > 1 ? arguments[1] : undefined;
    var len = toLength(that.length);
    var end = endPosition === undefined ? len : Math.min(toLength(endPosition), len);
    var search = String(searchString);
    return $endsWith ? $endsWith.call(that, search, end) : that.slice(end - search.length, end) === search;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.fixed.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.fixed.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.6 String.prototype.fixed()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('fixed', function (createHTML) {
  return function fixed() {
    return createHTML(this, 'tt', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.fontcolor.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.fontcolor.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.7 String.prototype.fontcolor(color)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('fontcolor', function (createHTML) {
  return function fontcolor(color) {
    return createHTML(this, 'font', 'color', color);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.fontsize.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.fontsize.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.8 String.prototype.fontsize(size)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('fontsize', function (createHTML) {
  return function fontsize(size) {
    return createHTML(this, 'font', 'size', size);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.from-code-point.js":
/*!*********************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.from-code-point.js ***!
  \*********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var fromCharCode = String.fromCharCode;
var $fromCodePoint = String.fromCodePoint; // length should be 1, old FF problem

$export($export.S + $export.F * (!!$fromCodePoint && $fromCodePoint.length != 1), 'String', {
  // 21.1.2.2 String.fromCodePoint(...codePoints)
  fromCodePoint: function fromCodePoint(x) {
    // eslint-disable-line no-unused-vars
    var res = [];
    var aLen = arguments.length;
    var i = 0;
    var code;

    while (aLen > i) {
      code = +arguments[i++];
      if (toAbsoluteIndex(code, 0x10ffff) !== code) throw RangeError(code + ' is not a valid code point');
      res.push(code < 0x10000 ? fromCharCode(code) : fromCharCode(((code -= 0x10000) >> 10) + 0xd800, code % 0x400 + 0xdc00));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.includes.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.includes.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.7 String.prototype.includes(searchString, position = 0)


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var context = __webpack_require__(/*! ./_string-context */ "../node_modules/core-js/modules/_string-context.js");

var INCLUDES = 'includes';
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "../node_modules/core-js/modules/_fails-is-regexp.js")(INCLUDES), 'String', {
  includes: function includes(searchString
  /* , position = 0 */
  ) {
    return !!~context(this, searchString, INCLUDES).indexOf(searchString, arguments.length > 1 ? arguments[1] : undefined);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.italics.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.italics.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.9 String.prototype.italics()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('italics', function (createHTML) {
  return function italics() {
    return createHTML(this, 'i', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.iterator.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.iterator.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $at = __webpack_require__(/*! ./_string-at */ "../node_modules/core-js/modules/_string-at.js")(true); // 21.1.3.27 String.prototype[@@iterator]()


__webpack_require__(/*! ./_iter-define */ "../node_modules/core-js/modules/_iter-define.js")(String, 'String', function (iterated) {
  this._t = String(iterated); // target

  this._i = 0; // next index
  // 21.1.5.2.1 %StringIteratorPrototype%.next()
}, function () {
  var O = this._t;
  var index = this._i;
  var point;
  if (index >= O.length) return {
    value: undefined,
    done: true
  };
  point = $at(O, index);
  this._i += point.length;
  return {
    value: point,
    done: false
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.link.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.link.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.10 String.prototype.link(url)

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('link', function (createHTML) {
  return function link(url) {
    return createHTML(this, 'a', 'href', url);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.raw.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.raw.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

$export($export.S, 'String', {
  // 21.1.2.4 String.raw(callSite, ...substitutions)
  raw: function raw(callSite) {
    var tpl = toIObject(callSite.raw);
    var len = toLength(tpl.length);
    var aLen = arguments.length;
    var res = [];
    var i = 0;

    while (len > i) {
      res.push(String(tpl[i++]));
      if (i < aLen) res.push(String(arguments[i]));
    }

    return res.join('');
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.repeat.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.repeat.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.P, 'String', {
  // 21.1.3.13 String.prototype.repeat(count)
  repeat: __webpack_require__(/*! ./_string-repeat */ "../node_modules/core-js/modules/_string-repeat.js")
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.small.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.small.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.11 String.prototype.small()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('small', function (createHTML) {
  return function small() {
    return createHTML(this, 'small', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.starts-with.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.starts-with.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// 21.1.3.18 String.prototype.startsWith(searchString [, position ])


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var context = __webpack_require__(/*! ./_string-context */ "../node_modules/core-js/modules/_string-context.js");

var STARTS_WITH = 'startsWith';
var $startsWith = ''[STARTS_WITH];
$export($export.P + $export.F * __webpack_require__(/*! ./_fails-is-regexp */ "../node_modules/core-js/modules/_fails-is-regexp.js")(STARTS_WITH), 'String', {
  startsWith: function startsWith(searchString
  /* , position = 0 */
  ) {
    var that = context(this, searchString, STARTS_WITH);
    var index = toLength(Math.min(arguments.length > 1 ? arguments[1] : undefined, that.length));
    var search = String(searchString);
    return $startsWith ? $startsWith.call(that, search, index) : that.slice(index, index + search.length) === search;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.strike.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.strike.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.12 String.prototype.strike()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('strike', function (createHTML) {
  return function strike() {
    return createHTML(this, 'strike', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.sub.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.sub.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.13 String.prototype.sub()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('sub', function (createHTML) {
  return function sub() {
    return createHTML(this, 'sub', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.sup.js":
/*!*********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.sup.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // B.2.3.14 String.prototype.sup()

__webpack_require__(/*! ./_string-html */ "../node_modules/core-js/modules/_string-html.js")('sup', function (createHTML) {
  return function sup() {
    return createHTML(this, 'sup', '', '');
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.string.trim.js":
/*!**********************************************************!*\
  !*** ../node_modules/core-js/modules/es6.string.trim.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // 21.1.3.25 String.prototype.trim()

__webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js")('trim', function ($trim) {
  return function trim() {
    return $trim(this, 3);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.symbol.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/es6.symbol.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // ECMAScript 6 symbols shim

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var has = __webpack_require__(/*! ./_has */ "../node_modules/core-js/modules/_has.js");

var DESCRIPTORS = __webpack_require__(/*! ./_descriptors */ "../node_modules/core-js/modules/_descriptors.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var META = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js").KEY;

var $fails = __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js");

var shared = __webpack_require__(/*! ./_shared */ "../node_modules/core-js/modules/_shared.js");

var setToStringTag = __webpack_require__(/*! ./_set-to-string-tag */ "../node_modules/core-js/modules/_set-to-string-tag.js");

var uid = __webpack_require__(/*! ./_uid */ "../node_modules/core-js/modules/_uid.js");

var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

var wksExt = __webpack_require__(/*! ./_wks-ext */ "../node_modules/core-js/modules/_wks-ext.js");

var wksDefine = __webpack_require__(/*! ./_wks-define */ "../node_modules/core-js/modules/_wks-define.js");

var enumKeys = __webpack_require__(/*! ./_enum-keys */ "../node_modules/core-js/modules/_enum-keys.js");

var isArray = __webpack_require__(/*! ./_is-array */ "../node_modules/core-js/modules/_is-array.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var toPrimitive = __webpack_require__(/*! ./_to-primitive */ "../node_modules/core-js/modules/_to-primitive.js");

var createDesc = __webpack_require__(/*! ./_property-desc */ "../node_modules/core-js/modules/_property-desc.js");

var _create = __webpack_require__(/*! ./_object-create */ "../node_modules/core-js/modules/_object-create.js");

var gOPNExt = __webpack_require__(/*! ./_object-gopn-ext */ "../node_modules/core-js/modules/_object-gopn-ext.js");

var $GOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var $GOPS = __webpack_require__(/*! ./_object-gops */ "../node_modules/core-js/modules/_object-gops.js");

var $DP = __webpack_require__(/*! ./_object-dp */ "../node_modules/core-js/modules/_object-dp.js");

var $keys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var gOPD = $GOPD.f;
var dP = $DP.f;
var gOPN = gOPNExt.f;
var $Symbol = global.Symbol;
var $JSON = global.JSON;

var _stringify = $JSON && $JSON.stringify;

var PROTOTYPE = 'prototype';
var HIDDEN = wks('_hidden');
var TO_PRIMITIVE = wks('toPrimitive');
var isEnum = {}.propertyIsEnumerable;
var SymbolRegistry = shared('symbol-registry');
var AllSymbols = shared('symbols');
var OPSymbols = shared('op-symbols');
var ObjectProto = Object[PROTOTYPE];
var USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;
var QObject = global.QObject; // Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173

var setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild; // fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687

var setSymbolDesc = DESCRIPTORS && $fails(function () {
  return _create(dP({}, 'a', {
    get: function get() {
      return dP(this, 'a', {
        value: 7
      }).a;
    }
  })).a != 7;
}) ? function (it, key, D) {
  var protoDesc = gOPD(ObjectProto, key);
  if (protoDesc) delete ObjectProto[key];
  dP(it, key, D);
  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);
} : dP;

var wrap = function wrap(tag) {
  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);

  sym._k = tag;
  return sym;
};

var isSymbol = USE_NATIVE && _typeof($Symbol.iterator) == 'symbol' ? function (it) {
  return _typeof(it) == 'symbol';
} : function (it) {
  return it instanceof $Symbol;
};

var $defineProperty = function defineProperty(it, key, D) {
  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);
  anObject(it);
  key = toPrimitive(key, true);
  anObject(D);

  if (has(AllSymbols, key)) {
    if (!D.enumerable) {
      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));
      it[HIDDEN][key] = true;
    } else {
      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;
      D = _create(D, {
        enumerable: createDesc(0, false)
      });
    }

    return setSymbolDesc(it, key, D);
  }

  return dP(it, key, D);
};

var $defineProperties = function defineProperties(it, P) {
  anObject(it);
  var keys = enumKeys(P = toIObject(P));
  var i = 0;
  var l = keys.length;
  var key;

  while (l > i) {
    $defineProperty(it, key = keys[i++], P[key]);
  }

  return it;
};

var $create = function create(it, P) {
  return P === undefined ? _create(it) : $defineProperties(_create(it), P);
};

var $propertyIsEnumerable = function propertyIsEnumerable(key) {
  var E = isEnum.call(this, key = toPrimitive(key, true));
  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;
  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;
};

var $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {
  it = toIObject(it);
  key = toPrimitive(key, true);
  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;
  var D = gOPD(it, key);
  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;
  return D;
};

var $getOwnPropertyNames = function getOwnPropertyNames(it) {
  var names = gOPN(toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);
  }

  return result;
};

var $getOwnPropertySymbols = function getOwnPropertySymbols(it) {
  var IS_OP = it === ObjectProto;
  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));
  var result = [];
  var i = 0;
  var key;

  while (names.length > i) {
    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);
  }

  return result;
}; // 19.4.1.1 Symbol([description])


if (!USE_NATIVE) {
  $Symbol = function _Symbol() {
    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');
    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);

    var $set = function $set(value) {
      if (this === ObjectProto) $set.call(OPSymbols, value);
      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;
      setSymbolDesc(this, tag, createDesc(1, value));
    };

    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, {
      configurable: true,
      set: $set
    });
    return wrap(tag);
  };

  redefine($Symbol[PROTOTYPE], 'toString', function toString() {
    return this._k;
  });
  $GOPD.f = $getOwnPropertyDescriptor;
  $DP.f = $defineProperty;
  __webpack_require__(/*! ./_object-gopn */ "../node_modules/core-js/modules/_object-gopn.js").f = gOPNExt.f = $getOwnPropertyNames;
  __webpack_require__(/*! ./_object-pie */ "../node_modules/core-js/modules/_object-pie.js").f = $propertyIsEnumerable;
  $GOPS.f = $getOwnPropertySymbols;

  if (DESCRIPTORS && !__webpack_require__(/*! ./_library */ "../node_modules/core-js/modules/_library.js")) {
    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);
  }

  wksExt.f = function (name) {
    return wrap(wks(name));
  };
}

$export($export.G + $export.W + $export.F * !USE_NATIVE, {
  Symbol: $Symbol
});

for (var es6Symbols = // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14
'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'.split(','), j = 0; es6Symbols.length > j;) {
  wks(es6Symbols[j++]);
}

for (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) {
  wksDefine(wellKnownSymbols[k++]);
}

$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {
  // 19.4.2.1 Symbol.for(key)
  'for': function _for(key) {
    return has(SymbolRegistry, key += '') ? SymbolRegistry[key] : SymbolRegistry[key] = $Symbol(key);
  },
  // 19.4.2.5 Symbol.keyFor(sym)
  keyFor: function keyFor(sym) {
    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');

    for (var key in SymbolRegistry) {
      if (SymbolRegistry[key] === sym) return key;
    }
  },
  useSetter: function useSetter() {
    setter = true;
  },
  useSimple: function useSimple() {
    setter = false;
  }
});
$export($export.S + $export.F * !USE_NATIVE, 'Object', {
  // 19.1.2.2 Object.create(O [, Properties])
  create: $create,
  // 19.1.2.4 Object.defineProperty(O, P, Attributes)
  defineProperty: $defineProperty,
  // 19.1.2.3 Object.defineProperties(O, Properties)
  defineProperties: $defineProperties,
  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)
  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,
  // 19.1.2.7 Object.getOwnPropertyNames(O)
  getOwnPropertyNames: $getOwnPropertyNames,
  // 19.1.2.8 Object.getOwnPropertySymbols(O)
  getOwnPropertySymbols: $getOwnPropertySymbols
}); // Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives
// https://bugs.chromium.org/p/v8/issues/detail?id=3443

var FAILS_ON_PRIMITIVES = $fails(function () {
  $GOPS.f(1);
});
$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {
  getOwnPropertySymbols: function getOwnPropertySymbols(it) {
    return $GOPS.f(toObject(it));
  }
}); // 24.3.2 JSON.stringify(value [, replacer [, space]])

$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {
  var S = $Symbol(); // MS Edge converts symbol values to JSON as {}
  // WebKit converts symbol values to JSON as null
  // V8 throws on boxed symbols

  return _stringify([S]) != '[null]' || _stringify({
    a: S
  }) != '{}' || _stringify(Object(S)) != '{}';
})), 'JSON', {
  stringify: function stringify(it) {
    var args = [it];
    var i = 1;
    var replacer, $replacer;

    while (arguments.length > i) {
      args.push(arguments[i++]);
    }

    $replacer = replacer = args[1];
    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined

    if (!isArray(replacer)) replacer = function replacer(key, value) {
      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);
      if (!isSymbol(value)) return value;
    };
    args[1] = replacer;
    return _stringify.apply($JSON, args);
  }
}); // 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)

$Symbol[PROTOTYPE][TO_PRIMITIVE] || __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js")($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf); // 19.4.3.5 Symbol.prototype[@@toStringTag]

setToStringTag($Symbol, 'Symbol'); // 20.2.1.9 Math[@@toStringTag]

setToStringTag(Math, 'Math', true); // 24.3.3 JSON[@@toStringTag]

setToStringTag(global.JSON, 'JSON', true);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.array-buffer.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.array-buffer.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $typed = __webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js");

var buffer = __webpack_require__(/*! ./_typed-buffer */ "../node_modules/core-js/modules/_typed-buffer.js");

var anObject = __webpack_require__(/*! ./_an-object */ "../node_modules/core-js/modules/_an-object.js");

var toAbsoluteIndex = __webpack_require__(/*! ./_to-absolute-index */ "../node_modules/core-js/modules/_to-absolute-index.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var ArrayBuffer = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js").ArrayBuffer;

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var $ArrayBuffer = buffer.ArrayBuffer;
var $DataView = buffer.DataView;
var $isView = $typed.ABV && ArrayBuffer.isView;
var $slice = $ArrayBuffer.prototype.slice;
var VIEW = $typed.VIEW;
var ARRAY_BUFFER = 'ArrayBuffer';
$export($export.G + $export.W + $export.F * (ArrayBuffer !== $ArrayBuffer), {
  ArrayBuffer: $ArrayBuffer
});
$export($export.S + $export.F * !$typed.CONSTR, ARRAY_BUFFER, {
  // 24.1.3.1 ArrayBuffer.isView(arg)
  isView: function isView(it) {
    return $isView && $isView(it) || isObject(it) && VIEW in it;
  }
});
$export($export.P + $export.U + $export.F * __webpack_require__(/*! ./_fails */ "../node_modules/core-js/modules/_fails.js")(function () {
  return !new $ArrayBuffer(2).slice(1, undefined).byteLength;
}), ARRAY_BUFFER, {
  // 24.1.4.3 ArrayBuffer.prototype.slice(start, end)
  slice: function slice(start, end) {
    if ($slice !== undefined && end === undefined) return $slice.call(anObject(this), start); // FF fix

    var len = anObject(this).byteLength;
    var first = toAbsoluteIndex(start, len);
    var fin = toAbsoluteIndex(end === undefined ? len : end, len);
    var result = new (speciesConstructor(this, $ArrayBuffer))(toLength(fin - first));
    var viewS = new $DataView(this);
    var viewT = new $DataView(result);
    var index = 0;

    while (first < fin) {
      viewT.setUint8(index++, viewS.getUint8(first++));
    }

    return result;
  }
});

__webpack_require__(/*! ./_set-species */ "../node_modules/core-js/modules/_set-species.js")(ARRAY_BUFFER);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.data-view.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.data-view.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

$export($export.G + $export.W + $export.F * !__webpack_require__(/*! ./_typed */ "../node_modules/core-js/modules/_typed.js").ABV, {
  DataView: __webpack_require__(/*! ./_typed-buffer */ "../node_modules/core-js/modules/_typed-buffer.js").DataView
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.float32-array.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.float32-array.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Float32', 4, function (init) {
  return function Float32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.float64-array.js":
/*!******************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.float64-array.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Float64', 8, function (init) {
  return function Float64Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.int16-array.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.int16-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Int16', 2, function (init) {
  return function Int16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.int32-array.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.int32-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Int32', 4, function (init) {
  return function Int32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.int8-array.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.int8-array.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Int8', 1, function (init) {
  return function Int8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint16-array.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint16-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint16', 2, function (init) {
  return function Uint16Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint32-array.js":
/*!*****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint32-array.js ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint32', 4, function (init) {
  return function Uint32Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint8-array.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint8-array.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8Array(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
});

/***/ }),

/***/ "../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js":
/*!************************************************************************!*\
  !*** ../node_modules/core-js/modules/es6.typed.uint8-clamped-array.js ***!
  \************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_typed-array */ "../node_modules/core-js/modules/_typed-array.js")('Uint8', 1, function (init) {
  return function Uint8ClampedArray(data, byteOffset, length) {
    return init(this, data, byteOffset, length);
  };
}, true);

/***/ }),

/***/ "../node_modules/core-js/modules/es6.weak-map.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.weak-map.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var each = __webpack_require__(/*! ./_array-methods */ "../node_modules/core-js/modules/_array-methods.js")(0);

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var meta = __webpack_require__(/*! ./_meta */ "../node_modules/core-js/modules/_meta.js");

var assign = __webpack_require__(/*! ./_object-assign */ "../node_modules/core-js/modules/_object-assign.js");

var weak = __webpack_require__(/*! ./_collection-weak */ "../node_modules/core-js/modules/_collection-weak.js");

var isObject = __webpack_require__(/*! ./_is-object */ "../node_modules/core-js/modules/_is-object.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var NATIVE_WEAK_MAP = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var IS_IE11 = !global.ActiveXObject && 'ActiveXObject' in global;
var WEAK_MAP = 'WeakMap';
var getWeak = meta.getWeak;
var isExtensible = Object.isExtensible;
var uncaughtFrozenStore = weak.ufstore;
var InternalMap;

var wrapper = function wrapper(get) {
  return function WeakMap() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
};

var methods = {
  // 23.3.3.3 WeakMap.prototype.get(key)
  get: function get(key) {
    if (isObject(key)) {
      var data = getWeak(key);
      if (data === true) return uncaughtFrozenStore(validate(this, WEAK_MAP)).get(key);
      return data ? data[this._i] : undefined;
    }
  },
  // 23.3.3.5 WeakMap.prototype.set(key, value)
  set: function set(key, value) {
    return weak.def(validate(this, WEAK_MAP), key, value);
  }
}; // 23.3 WeakMap Objects

var $WeakMap = module.exports = __webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(WEAK_MAP, wrapper, methods, weak, true, true); // IE11 WeakMap frozen keys fix


if (NATIVE_WEAK_MAP && IS_IE11) {
  InternalMap = weak.getConstructor(wrapper, WEAK_MAP);
  assign(InternalMap.prototype, methods);
  meta.NEED = true;
  each(['delete', 'has', 'get', 'set'], function (key) {
    var proto = $WeakMap.prototype;
    var method = proto[key];
    redefine(proto, key, function (a, b) {
      // store frozen objects on internal weakmap shim
      if (isObject(a) && !isExtensible(a)) {
        if (!this._f) this._f = new InternalMap();

        var result = this._f[key](a, b);

        return key == 'set' ? this : result; // store all the rest on native weakmap
      }

      return method.call(this, a, b);
    });
  });
}

/***/ }),

/***/ "../node_modules/core-js/modules/es6.weak-set.js":
/*!*******************************************************!*\
  !*** ../node_modules/core-js/modules/es6.weak-set.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var weak = __webpack_require__(/*! ./_collection-weak */ "../node_modules/core-js/modules/_collection-weak.js");

var validate = __webpack_require__(/*! ./_validate-collection */ "../node_modules/core-js/modules/_validate-collection.js");

var WEAK_SET = 'WeakSet'; // 23.4 WeakSet Objects

__webpack_require__(/*! ./_collection */ "../node_modules/core-js/modules/_collection.js")(WEAK_SET, function (get) {
  return function WeakSet() {
    return get(this, arguments.length > 0 ? arguments[0] : undefined);
  };
}, {
  // 23.4.3.1 WeakSet.prototype.add(value)
  add: function add(value) {
    return weak.def(validate(this, WEAK_SET), value, true);
  }
}, weak, false, true);

/***/ }),

/***/ "../node_modules/core-js/modules/es7.array.flat-map.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.array.flat-map.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://tc39.github.io/proposal-flatMap/#sec-Array.prototype.flatMap

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var flattenIntoArray = __webpack_require__(/*! ./_flatten-into-array */ "../node_modules/core-js/modules/_flatten-into-array.js");

var toObject = __webpack_require__(/*! ./_to-object */ "../node_modules/core-js/modules/_to-object.js");

var toLength = __webpack_require__(/*! ./_to-length */ "../node_modules/core-js/modules/_to-length.js");

var aFunction = __webpack_require__(/*! ./_a-function */ "../node_modules/core-js/modules/_a-function.js");

var arraySpeciesCreate = __webpack_require__(/*! ./_array-species-create */ "../node_modules/core-js/modules/_array-species-create.js");

$export($export.P, 'Array', {
  flatMap: function flatMap(callbackfn
  /* , thisArg */
  ) {
    var O = toObject(this);
    var sourceLen, A;
    aFunction(callbackfn);
    sourceLen = toLength(O.length);
    A = arraySpeciesCreate(O, 0);
    flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments[1]);
    return A;
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('flatMap');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.array.includes.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.array.includes.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/Array.prototype.includes

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $includes = __webpack_require__(/*! ./_array-includes */ "../node_modules/core-js/modules/_array-includes.js")(true);

$export($export.P, 'Array', {
  includes: function includes(el
  /* , fromIndex = 0 */
  ) {
    return $includes(this, el, arguments.length > 1 ? arguments[1] : undefined);
  }
});

__webpack_require__(/*! ./_add-to-unscopables */ "../node_modules/core-js/modules/_add-to-unscopables.js")('includes');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.entries.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.entries.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $entries = __webpack_require__(/*! ./_object-to-array */ "../node_modules/core-js/modules/_object-to-array.js")(true);

$export($export.S, 'Object', {
  entries: function entries(it) {
    return $entries(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js":
/*!**********************************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.get-own-property-descriptors.js ***!
  \**********************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-getownpropertydescriptors
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var ownKeys = __webpack_require__(/*! ./_own-keys */ "../node_modules/core-js/modules/_own-keys.js");

var toIObject = __webpack_require__(/*! ./_to-iobject */ "../node_modules/core-js/modules/_to-iobject.js");

var gOPD = __webpack_require__(/*! ./_object-gopd */ "../node_modules/core-js/modules/_object-gopd.js");

var createProperty = __webpack_require__(/*! ./_create-property */ "../node_modules/core-js/modules/_create-property.js");

$export($export.S, 'Object', {
  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {
    var O = toIObject(object);
    var getDesc = gOPD.f;
    var keys = ownKeys(O);
    var result = {};
    var i = 0;
    var key, desc;

    while (keys.length > i) {
      desc = getDesc(O, key = keys[i++]);
      if (desc !== undefined) createProperty(result, key, desc);
    }

    return result;
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.object.values.js":
/*!************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.object.values.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// https://github.com/tc39/proposal-object-values-entries
var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $values = __webpack_require__(/*! ./_object-to-array */ "../node_modules/core-js/modules/_object-to-array.js")(false);

$export($export.S, 'Object', {
  values: function values(it) {
    return $values(it);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.promise.finally.js":
/*!**************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.promise.finally.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// https://github.com/tc39/proposal-promise-finally


var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var core = __webpack_require__(/*! ./_core */ "../node_modules/core-js/modules/_core.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var speciesConstructor = __webpack_require__(/*! ./_species-constructor */ "../node_modules/core-js/modules/_species-constructor.js");

var promiseResolve = __webpack_require__(/*! ./_promise-resolve */ "../node_modules/core-js/modules/_promise-resolve.js");

$export($export.P + $export.R, 'Promise', {
  'finally': function _finally(onFinally) {
    var C = speciesConstructor(this, core.Promise || global.Promise);
    var isFunction = typeof onFinally == 'function';
    return this.then(isFunction ? function (x) {
      return promiseResolve(C, onFinally()).then(function () {
        return x;
      });
    } : onFinally, isFunction ? function (e) {
      return promiseResolve(C, onFinally()).then(function () {
        throw e;
      });
    } : onFinally);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.pad-end.js":
/*!*************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.pad-end.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "../node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padEnd: function padEnd(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, false);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.pad-start.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.pad-start.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/tc39/proposal-string-pad-start-end

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $pad = __webpack_require__(/*! ./_string-pad */ "../node_modules/core-js/modules/_string-pad.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js"); // https://github.com/zloirock/core-js/issues/280


var WEBKIT_BUG = /Version\/10\.\d+(\.\d+)?( Mobile\/\w+)? Safari\//.test(userAgent);
$export($export.P + $export.F * WEBKIT_BUG, 'String', {
  padStart: function padStart(maxLength
  /* , fillString = ' ' */
  ) {
    return $pad(this, maxLength, arguments.length > 1 ? arguments[1] : undefined, true);
  }
});

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.trim-left.js":
/*!***************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.trim-left.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js")('trimLeft', function ($trim) {
  return function trimLeft() {
    return $trim(this, 1);
  };
}, 'trimStart');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.string.trim-right.js":
/*!****************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.string.trim-right.js ***!
  \****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 // https://github.com/sebmarkbage/ecmascript-string-left-right-trim

__webpack_require__(/*! ./_string-trim */ "../node_modules/core-js/modules/_string-trim.js")('trimRight', function ($trim) {
  return function trimRight() {
    return $trim(this, 2);
  };
}, 'trimEnd');

/***/ }),

/***/ "../node_modules/core-js/modules/es7.symbol.async-iterator.js":
/*!********************************************************************!*\
  !*** ../node_modules/core-js/modules/es7.symbol.async-iterator.js ***!
  \********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ./_wks-define */ "../node_modules/core-js/modules/_wks-define.js")('asyncIterator');

/***/ }),

/***/ "../node_modules/core-js/modules/web.dom.iterable.js":
/*!***********************************************************!*\
  !*** ../node_modules/core-js/modules/web.dom.iterable.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $iterators = __webpack_require__(/*! ./es6.array.iterator */ "../node_modules/core-js/modules/es6.array.iterator.js");

var getKeys = __webpack_require__(/*! ./_object-keys */ "../node_modules/core-js/modules/_object-keys.js");

var redefine = __webpack_require__(/*! ./_redefine */ "../node_modules/core-js/modules/_redefine.js");

var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var hide = __webpack_require__(/*! ./_hide */ "../node_modules/core-js/modules/_hide.js");

var Iterators = __webpack_require__(/*! ./_iterators */ "../node_modules/core-js/modules/_iterators.js");

var wks = __webpack_require__(/*! ./_wks */ "../node_modules/core-js/modules/_wks.js");

var ITERATOR = wks('iterator');
var TO_STRING_TAG = wks('toStringTag');
var ArrayValues = Iterators.Array;
var DOMIterables = {
  CSSRuleList: true,
  // TODO: Not spec compliant, should be false.
  CSSStyleDeclaration: false,
  CSSValueList: false,
  ClientRectList: false,
  DOMRectList: false,
  DOMStringList: false,
  DOMTokenList: true,
  DataTransferItemList: false,
  FileList: false,
  HTMLAllCollection: false,
  HTMLCollection: false,
  HTMLFormElement: false,
  HTMLSelectElement: false,
  MediaList: true,
  // TODO: Not spec compliant, should be false.
  MimeTypeArray: false,
  NamedNodeMap: false,
  NodeList: true,
  PaintRequestList: false,
  Plugin: false,
  PluginArray: false,
  SVGLengthList: false,
  SVGNumberList: false,
  SVGPathSegList: false,
  SVGPointList: false,
  SVGStringList: false,
  SVGTransformList: false,
  SourceBufferList: false,
  StyleSheetList: true,
  // TODO: Not spec compliant, should be false.
  TextTrackCueList: false,
  TextTrackList: false,
  TouchList: false
};

for (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {
  var NAME = collections[i];
  var explicit = DOMIterables[NAME];
  var Collection = global[NAME];
  var proto = Collection && Collection.prototype;
  var key;

  if (proto) {
    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);
    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);
    Iterators[NAME] = ArrayValues;
    if (explicit) for (key in $iterators) {
      if (!proto[key]) redefine(proto, key, $iterators[key], true);
    }
  }
}

/***/ }),

/***/ "../node_modules/core-js/modules/web.immediate.js":
/*!********************************************************!*\
  !*** ../node_modules/core-js/modules/web.immediate.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var $task = __webpack_require__(/*! ./_task */ "../node_modules/core-js/modules/_task.js");

$export($export.G + $export.B, {
  setImmediate: $task.set,
  clearImmediate: $task.clear
});

/***/ }),

/***/ "../node_modules/core-js/modules/web.timers.js":
/*!*****************************************************!*\
  !*** ../node_modules/core-js/modules/web.timers.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// ie9- setTimeout & setInterval additional parameters fix
var global = __webpack_require__(/*! ./_global */ "../node_modules/core-js/modules/_global.js");

var $export = __webpack_require__(/*! ./_export */ "../node_modules/core-js/modules/_export.js");

var userAgent = __webpack_require__(/*! ./_user-agent */ "../node_modules/core-js/modules/_user-agent.js");

var slice = [].slice;
var MSIE = /MSIE .\./.test(userAgent); // <- dirty ie9- check

var wrap = function wrap(set) {
  return function (fn, time
  /* , ...args */
  ) {
    var boundArgs = arguments.length > 2;
    var args = boundArgs ? slice.call(arguments, 2) : false;
    return set(boundArgs ? function () {
      // eslint-disable-next-line no-new-func
      (typeof fn == 'function' ? fn : Function(fn)).apply(this, args);
    } : fn, time);
  };
};

$export($export.G + $export.B + $export.F * MSIE, {
  setTimeout: wrap(global.setTimeout),
  setInterval: wrap(global.setInterval)
});

/***/ }),

/***/ "../node_modules/core-js/web/index.js":
/*!********************************************!*\
  !*** ../node_modules/core-js/web/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! ../modules/web.timers */ "../node_modules/core-js/modules/web.timers.js");

__webpack_require__(/*! ../modules/web.immediate */ "../node_modules/core-js/modules/web.immediate.js");

__webpack_require__(/*! ../modules/web.dom.iterable */ "../node_modules/core-js/modules/web.dom.iterable.js");

module.exports = __webpack_require__(/*! ../modules/_core */ "../node_modules/core-js/modules/_core.js");

/***/ }),

/***/ "../node_modules/gsap/CSSPlugin.js":
/*!*****************************************!*\
  !*** ../node_modules/gsap/CSSPlugin.js ***!
  \*****************************************/
/*! exports provided: CSSPlugin, default, _getBBox, _createElement, checkPrefix */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return CSSPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CSSPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getBBox", function() { return _getBBox; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_createElement", function() { return _createElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkPrefix", function() { return _checkPropPrefix; });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "../node_modules/gsap/gsap-core.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/*!
 * CSSPlugin 3.0.1
 * https://greensock.com
 *
 * Copyright 2008-2019, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _win,
    _doc,
    _docElement,
    _pluginInitted,
    _tempDiv,
    _tempDivStyler,
    _recentSetterPlugin,
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _transformProps = {},
    _RAD2DEG = 180 / Math.PI,
    _DEG2RAD = Math.PI / 180,
    _atan2 = Math.atan2,
    _bigNum = 1e8,
    _capsExp = /([A-Z])/g,
    _numWithUnitExp = /[-+=\.]*\d+[\.e-]*\d*[a-z%]*/g,
    _horizontalExp = /(?:left|right|width|margin|padding|x)/i,
    _complexExp = /[\s,\(]\S/,
    _propertyAliases = {
  autoAlpha: "opacity,visibility",
  scale: "scaleX,scaleY",
  alpha: "opacity"
},
    _renderCSSProp = function _renderCSSProp(ratio, data) {
  return data.set(data.t, data.p, ~~((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderPropWithEnd = function _renderPropWithEnd(ratio, data) {
  return data.set(data.t, data.p, ratio === 1 ? data.e : ~~((data.s + data.c * ratio) * 10000) / 10000 + data.u, data);
},
    _renderCSSPropWithBeginning = function _renderCSSPropWithBeginning(ratio, data) {
  return data.set(data.t, data.p, ratio ? ~~((data.s + data.c * ratio) * 10000) / 10000 + data.u : data.b, data);
},
    //if units change, we need a way to render the original unit/value when the tween goes all the way back to the beginning (ratio:0)
_renderRoundedCSSProp = function _renderRoundedCSSProp(ratio, data) {
  var value = data.s + data.c * ratio;
  data.set(data.t, data.p, ~~(value + (value < 0 ? -.5 : .5)) + data.u, data);
},
    _renderNonTweeningValue = function _renderNonTweeningValue(ratio, data) {
  return data.set(data.t, data.p, ratio ? data.e : data.b, data);
},
    _renderNonTweeningValueOnlyAtEnd = function _renderNonTweeningValueOnlyAtEnd(ratio, data) {
  return data.set(data.t, data.p, ratio !== 1 ? data.b : data.e, data);
},
    _setterCSSStyle = function _setterCSSStyle(target, property, value) {
  return target.style[property] = value;
},
    _setterCSSProp = function _setterCSSProp(target, property, value) {
  return target.style.setProperty(property, value);
},
    _setterTransform = function _setterTransform(target, property, value) {
  return target._gsap[property] = value;
},
    _setterScale = function _setterScale(target, property, value) {
  return target._gsap.scaleX = target._gsap.scaleY = value;
},
    _setterScaleWithRender = function _setterScaleWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache.scaleX = cache.scaleY = value;
  cache.renderTransform(ratio, cache);
},
    _setterTransformWithRender = function _setterTransformWithRender(target, property, value, data, ratio) {
  var cache = target._gsap;
  cache[property] = value;
  cache.renderTransform(ratio, cache);
},
    _transformProp = "transform",
    _transformOriginProp = _transformProp + "Origin",
    _supports3D,
    _createElement = function _createElement(type, ns) {
  var e = _doc.createElementNS ? _doc.createElementNS((ns || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), type) : _doc.createElement(type); //some servers swap in https for http in the namespace which can break things, making "style" inaccessible.

  return e.style ? e : _doc.createElement(type); //some environments won't allow access to the element's style when created with a namespace in which case we default to the standard createElement() to work around the issue. Also note that when GSAP is embedded directly inside an SVG file, createElement() won't allow access to the style object in Firefox (see https://greensock.com/forums/topic/20215-problem-using-tweenmax-in-standalone-self-containing-svg-file-err-cannot-set-property-csstext-of-undefined/).
},
    _getComputedProperty = function _getComputedProperty(target, property) {
  var cs = getComputedStyle(target);
  return cs[property] || cs.getPropertyValue(property.replace(_capsExp, "-$1").toLowerCase()) || cs.getPropertyValue(property); //css variables may not need caps swapped out for dashes and lowercase.
},
    _checkPropPrefix = function _checkPropPrefix(property, element) {
  var e = element || _tempDiv,
      s = e.style,
      i = 5,
      a = "O,Moz,ms,Ms,Webkit".split(",");

  if (property in s) {
    return property;
  }

  property = property.charAt(0).toUpperCase() + property.substr(1);

  while (i-- && !(a[i] + property in s)) {}

  return i < 0 ? null : (i === 3 ? "ms" : i >= 0 ? a[i] : "") + property;
},
    _initCore = function _initCore() {
  if (_windowExists()) {
    _win = window;
    _doc = _win.document;
    _docElement = _doc.documentElement;
    _tempDiv = _createElement("div") || {
      style: {}
    };
    _tempDivStyler = _createElement("div");
    _transformProp = _checkPropPrefix(_transformProp);
    _transformOriginProp = _checkPropPrefix(_transformOriginProp);
    _tempDiv.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0"; //make sure to override certain properties that may contaminate measurements, in case the user has overreaching style sheets.

    _supports3D = !!_checkPropPrefix("perspective");
    _pluginInitted = 1;
  }
},
    _getBBoxHack = function _getBBoxHack(swapIfPossible) {
  //works around issues in some browsers (like Firefox) that don't correctly report getBBox() on SVG elements inside a <defs> element and/or <mask>. We try creating an SVG, adding it to the documentElement and toss the element in there so that it's definitely part of the rendering tree, then grab the bbox and if it works, we actually swap out the original getBBox() method for our own that does these extra steps whenever getBBox is needed. This helps ensure that performance is optimal (only do all these extra steps when absolutely necessary...most elements don't need it).
  var svg = _createElement("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
      oldParent = this.parentNode,
      oldSibling = this.nextSibling,
      oldCSS = this.style.cssText,
      bbox;

  _docElement.appendChild(svg);

  svg.appendChild(this);
  this.style.display = "block";

  if (swapIfPossible) {
    try {
      bbox = this.getBBox();
      this._gsapBBox = this.getBBox; //store the original

      this.getBBox = _getBBoxHack;
    } catch (e) {}
  } else if (this._gsapBBox) {
    bbox = this._gsapBBox();
  }

  if (oldSibling) {
    oldParent.insertBefore(this, oldSibling);
  } else {
    oldParent.appendChild(this);
  }

  _docElement.removeChild(svg);

  this.style.cssText = oldCSS;
  return bbox;
},
    _getAttributeFallbacks = function _getAttributeFallbacks(target, attributesArray) {
  var i = attributesArray.length;

  while (i--) {
    if (target.hasAttribute(attributesArray[i])) {
      return target.getAttribute(attributesArray[i]);
    }
  }
},
    _getBBox = function _getBBox(target) {
  var bounds;

  try {
    bounds = target.getBBox(); //Firefox throws errors if you try calling getBBox() on an SVG element that's not rendered (like in a <symbol> or <defs>). https://bugzilla.mozilla.org/show_bug.cgi?id=612118
  } catch (error) {
    bounds = _getBBoxHack.call(target, true);
  } //some browsers (like Firefox) misreport the bounds if the element has zero width and height (it just assumes it's at x:0, y:0), thus we need to manually grab the position in that case.


  return bounds && !bounds.width && !bounds.x && !bounds.y ? {
    x: +_getAttributeFallbacks(target, ["x", "cx", "x1"]),
    y: +_getAttributeFallbacks(target, ["y", "cy", "y1"]),
    width: 0,
    height: 0
  } : bounds;
},
    _isSVG = function _isSVG(e) {
  return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && _getBBox(e));
},
    //reports if the element is an SVG on which getBBox() actually works
_removeProperty = function _removeProperty(target, property) {
  if (property) {
    var style = target.style;

    if (property in _transformProps) {
      property = _transformProp;
    }

    if (style.removeProperty) {
      if (property.substr(0, 2) === "ms" || property.substr(0, 6) === "webkit") {
        //Microsoft and some Webkit browsers don't conform to the standard of capitalizing the first prefix character, so we adjust so that when we prefix the caps with a dash, it's correct (otherwise it'd be "ms-transform" instead of "-ms-transform" for IE9, for example)
        property = "-" + property;
      }

      style.removeProperty(property.replace(_capsExp, "-$1").toLowerCase());
    } else {
      //note: old versions of IE use "removeAttribute()" instead of "removeProperty()"
      style.removeAttribute(property);
    }
  }
},
    _addNonTweeningPT = function _addNonTweeningPT(plugin, target, property, beginning, end, onlySetAtEnd) {
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 1, onlySetAtEnd ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue);
  plugin._pt = pt;
  pt.b = beginning;
  pt.e = end;

  plugin._props.push(property);

  return pt;
},
    _nonConvertibleUnits = {
  deg: 1,
  rad: 1,
  turn: 1
},
    //takes a single value like 20px and converts it to the unit specified, like "%", returning only the numeric amount.
_convertToUnit = function _convertToUnit(target, property, value, unit) {
  var curValue = parseFloat(value),
      curUnit = (value + "").substr((curValue + "").length) || "px",
      style = _tempDiv.style,
      horizontal = _horizontalExp.test(property),
      isRootSVG = target.tagName.toLowerCase() === "svg",
      measureProperty = (isRootSVG ? "client" : "offset") + (horizontal ? "Width" : "Height"),
      amount = 100,
      toPixels = unit === "px",
      px,
      parent,
      cache,
      isSVG;

  if (unit === curUnit || _nonConvertibleUnits[unit] || _nonConvertibleUnits[curUnit]) {
    return curValue;
  }

  isSVG = target.getCTM && _isSVG(target);

  if (unit === "%" && _transformProps[property]) {
    //transforms are relative to the size of the element itself!
    return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(curValue / (isSVG ? target.getBBox()[horizontal ? "width" : "height"] : target[measureProperty]) * amount);
  }

  style[horizontal ? "width" : "height"] = amount + (toPixels ? curUnit : unit);
  parent = unit === "em" && target.appendChild && !isRootSVG ? target : target.parentNode;

  if (isSVG) {
    parent = (target.ownerSVGElement || {}).parentNode;
  }

  if (!parent || parent === _doc || !parent.appendChild) {
    parent = _doc.body;
  }

  cache = parent._gsap;

  if (cache && unit === "%" && cache.width && horizontal && cache.time === _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time) {
    px = cache.width * curValue / amount;
  } else {
    parent.appendChild(_tempDiv);
    px = _tempDiv[measureProperty];
    parent.removeChild(_tempDiv);

    if (horizontal && unit === "%") {
      cache = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getCache"])(parent);
      cache.time = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_ticker"].time;
      cache.width = px / curValue * amount;
    }
  }

  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(toPixels ? px * curValue / amount : amount / px * curValue);
},
    _get = function _get(target, property, unit, uncache) {
  var value;

  if (!_pluginInitted) {
    _initCore();
  }

  if (property in _propertyAliases) {
    property = _propertyAliases[property];

    if (~property.indexOf(",")) {
      property = property.split(",")[0];
    }
  }

  if (_transformProps[property]) {
    value = _parseTransform(target, uncache);
    value = property !== "transformOrigin" ? value[property] : _firstTwoOnly(_getComputedProperty(target, _transformOriginProp)) + value.zOrigin + "px";
  } else {
    value = target.style[property];

    if (!value || value === "auto" || uncache) {
      value = _getComputedProperty(target, property) || Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getProperty"])(target, property);
    }
  }

  return unit ? _convertToUnit(target, property, value, unit) + unit : value;
},
    _tweenComplexCSSString = function _tweenComplexCSSString(target, prop, start, end) {
  //note: we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, target.style, prop, 0, 1, _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_renderComplexString"]),
      index = 0,
      matchIndex = 0,
      a,
      result,
      startValues,
      startNum,
      color,
      startValue,
      endValue,
      endNum,
      chunk,
      endUnit,
      startUnit,
      relative,
      endValues;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (end === "auto") {
    target.style[prop] = end;
    end = _getComputedProperty(target, prop) || end;
    target.style[prop] = start;
  }

  a = [start, end];

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_colorStringFilter"])(a); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.


  start = a[0];
  end = a[1];
  startValues = start.match(_numWithUnitExp) || [];
  endValues = end.match(_numWithUnitExp) || [];

  if (endValues.length) {
    while (result = _numWithUnitExp.exec(end)) {
      endValue = result[0];
      chunk = end.substring(index, result.index);

      if (color) {
        color = (color + 1) % 5;
      } else if (chunk.substr(-5) === "rgba(") {
        color = 1;
      }

      if (endValue !== (startValue = startValues[matchIndex++] || "")) {
        startNum = parseFloat(startValue) || 0;
        startUnit = startValue.substr((startNum + "").length);
        relative = endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);
        endUnit = endValue.substr((endNum + "").length);
        index = _numWithUnitExp.lastIndex - endUnit.length;

        if (!endUnit) {
          //if something like "perspective:300" is passed in and we must add a unit to the end
          endUnit = endUnit || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[prop] || startUnit;

          if (index === end.length) {
            end += endUnit;
            pt.e += endUnit;
          }
        }

        if (startUnit !== endUnit) {
          startNum = _convertToUnit(target, prop, startValue, endUnit);
        } //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.


        pt._pt = {
          _next: pt._pt,
          p: chunk || matchIndex === 1 ? chunk : ",",
          //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
          s: startNum,
          c: relative ? relative * endNum : endNum - startNum,
          m: color && color < 4 ? Math.round : 0
        };
      }
    }

    pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)
  } else {
    pt.r = prop === "display" ? _renderNonTweeningValueOnlyAtEnd : _renderNonTweeningValue;
  }

  if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_relExp"].test(end)) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _tweenComplexCSSString.call(pluginInstance...) to ensure that it's scoped properly. We may call it from within another plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _keywordToPercent = {
  top: "0%",
  bottom: "100%",
  left: "0%",
  right: "100%",
  center: "50%"
},
    _convertKeywordsToPercentages = function _convertKeywordsToPercentages(value) {
  var split = value.split(" "),
      x = split[0],
      y = split[1] || "50%";

  if (x === "top" || x === "bottom" || y === "left" || y === "right") {
    //the user provided them in the wrong order, so flip them
    split = x;
    x = y;
    y = split;
  }

  split[0] = _keywordToPercent[x] || x;
  split[1] = _keywordToPercent[y] || y;
  return split.join(" ");
},
    _renderClearProps = function _renderClearProps(ratio, data) {
  if (data.tween && data.tween._time === data.tween._dur) {
    var target = data.t,
        style = target.style,
        props = data.u,
        prop,
        clearTransforms,
        i;

    if (props === "all" || props === true) {
      style.cssText = "";
      clearTransforms = 1;
    } else {
      props = props.split(",");
      i = props.length;

      while (--i > -1) {
        prop = props[i];

        if (_transformProps[prop]) {
          clearTransforms = 1;
          prop = prop === "transformOrigin" ? _transformOriginProp : _transformProp;
        }

        _removeProperty(target, prop);
      }
    }

    if (clearTransforms) {
      _removeProperty(target, _transformProp);

      clearTransforms = target._gsap;

      if (clearTransforms) {
        if (clearTransforms.svg) {
          target.removeAttribute("transform");
        }

        delete clearTransforms.x;
      }
    }
  }
},
    // note: specialProps should return 1 if (and only if) they have a non-zero priority. It indicates we need to sort the linked list.
_specialProps = {
  clearProps: function clearProps(plugin, target, property, endValue, tween) {
    var pt = plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, 0, 0, _renderClearProps);
    pt.u = endValue;
    pt.pr = -10;
    pt.tween = tween;

    plugin._props.push(property);

    return 1;
  }
  /* className feature (about 0.4kb gzipped).
  , className(plugin, target, property, endValue, tween) {
  	let _renderClassName = (ratio, data) => {
  			data.css.render(ratio, data.css);
  			if (!ratio || ratio === 1) {
  				let inline = data.rmv,
  					target = data.t,
  					p;
  				target.setAttribute("class", ratio ? data.e : data.b);
  				for (p in inline) {
  					_removeProperty(target, p);
  				}
  			}
  		},
  		_getAllStyles = (target) => {
  			let styles = {},
  				computed = getComputedStyle(target),
  				p;
  			for (p in computed) {
  				if (isNaN(p) && p !== "cssText" && p !== "length") {
  					styles[p] = computed[p];
  				}
  			}
  			_setDefaults(styles, _parseTransform(target, 1));
  			return styles;
  		},
  		startClassList = target.getAttribute("class"),
  		style = target.style,
  		cssText = style.cssText,
  		cache = target._gsap,
  		classPT = cache.classPT,
  		inlineToRemoveAtEnd = {},
  		data = {t:target, plugin:plugin, rmv:inlineToRemoveAtEnd, b:startClassList, e:(endValue.charAt(1) !== "=") ? endValue : startClassList.replace(new RegExp("(?:\\s|^)" + endValue.substr(2) + "(?![\\w-])"), "") + ((endValue.charAt(0) === "+") ? " " + endValue.substr(2) : "")},
  		changingVars = {},
  		startVars = _getAllStyles(target),
  		transformRelated = /(transform|perspective)/i,
  		endVars, p;
  	if (classPT) {
  		classPT.r(1, classPT.d);
  		_removeLinkedListItem(classPT.d.plugin, classPT, "_pt");
  	}
  	target.setAttribute("class", data.e);
  	endVars = _getAllStyles(target, true);
  	target.setAttribute("class", startClassList);
  	for (p in endVars) {
  		if (endVars[p] !== startVars[p] && !transformRelated.test(p)) {
  			changingVars[p] = endVars[p];
  			if (!style[p] && style[p] !== "0") {
  				inlineToRemoveAtEnd[p] = 1;
  			}
  		}
  	}
  	cache.classPT = plugin._pt = new PropTween(plugin._pt, target, "className", 0, 0, _renderClassName, data, 0, -11);
  	if (style.cssText !== cssText) { //only apply if things change. Otherwise, in cases like a background-image that's pulled dynamically, it could cause a refresh. See https://greensock.com/forums/topic/20368-possible-gsap-bug-switching-classnames-in-chrome/.
  		style.cssText = cssText; //we recorded cssText before we swapped classes and ran _getAllStyles() because in cases when a className tween is overwritten, we remove all the related tweening properties from that class change (otherwise class-specific stuff can't override properties we've directly set on the target's style object due to specificity).
  	}
  	_parseTransform(target, true); //to clear the caching of transforms
  	data.css = new gsap.plugins.css();
  	data.css.init(target, changingVars, tween);
  	plugin._props.push(...data.css._props);
  	return 1;
  }
  */

},

/*
 * --------------------------------------------------------------------------------------
 * TRANSFORMS
 * --------------------------------------------------------------------------------------
 */
_identity2DMatrix = [1, 0, 0, 1, 0, 0],
    _rotationalProperties = {},
    _isNullTransform = function _isNullTransform(value) {
  return value === "matrix(1, 0, 0, 1, 0, 0)" || value === "none" || !value;
},
    _getComputedTransformMatrixAsArray = function _getComputedTransformMatrixAsArray(target) {
  var matrixString = _getComputedProperty(target, _transformProp);

  return _isNullTransform(matrixString) ? _identity2DMatrix : matrixString.substr(7).match(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_numExp"]).map(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"]);
},
    _getMatrix = function _getMatrix(target, force2D) {
  var cache = target._gsap,
      style = target.style,
      matrix = _getComputedTransformMatrixAsArray(target),
      parent,
      nextSibling,
      temp,
      addedToDOM;

  if (cache.svg && target.getAttribute("transform")) {
    temp = target.transform.baseVal.consolidate().matrix; //ensures that even complex values like "translate(50,60) rotate(135,0,0)" are parsed because it mashes it into a matrix.

    matrix = [temp.a, temp.b, temp.c, temp.d, temp.e, temp.f];
    return matrix.join(",") === "1,0,0,1,0,0" ? _identity2DMatrix : matrix;
  } else if (matrix === _identity2DMatrix && !target.offsetParent && target !== _docElement && !cache.svg) {
    //note: if offsetParent is null, that means the element isn't in the normal document flow, like if it has display:none or one of its ancestors has display:none). Firefox returns null for getComputedStyle() if the element is in an iframe that has display:none. https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    //browsers don't report transforms accurately unless the element is in the DOM and has a display value that's not "none". Firefox and Microsoft browsers have a partial bug where they'll report transforms even if display:none BUT not any percentage-based values like translate(-50%, 8px) will be reported as if it's translate(0, 8px).
    temp = style.display;
    style.display = "block";
    parent = target.parentNode;

    if (!parent || !target.offsetParent) {
      addedToDOM = 1; //flag

      nextSibling = target.nextSibling;

      _docElement.appendChild(target); //we must add it to the DOM in order to get values properly

    }

    matrix = _getComputedTransformMatrixAsArray(target);

    if (temp) {
      style.display = temp;
    } else {
      _removeProperty(target, "display");
    }

    if (addedToDOM) {
      if (nextSibling) {
        parent.insertBefore(target, nextSibling);
      } else if (parent) {
        parent.appendChild(target);
      } else {
        _docElement.removeChild(target);
      }
    }
  }

  return force2D && matrix.length > 6 ? [matrix[0], matrix[1], matrix[4], matrix[5], matrix[12], matrix[13]] : matrix;
},
    _applySVGOrigin = function _applySVGOrigin(target, origin, originIsAbsolute, smooth, matrixArray, pluginToAddPropTweensTo) {
  var cache = target._gsap,
      matrix = matrixArray || _getMatrix(target, true),
      xOriginOld = cache.xOrigin || 0,
      yOriginOld = cache.yOrigin || 0,
      xOffsetOld = cache.xOffset || 0,
      yOffsetOld = cache.yOffset || 0,
      a = matrix[0],
      b = matrix[1],
      c = matrix[2],
      d = matrix[3],
      tx = matrix[4],
      ty = matrix[5],
      originSplit = origin.split(" "),
      xOrigin = parseFloat(originSplit[0]) || 0,
      yOrigin = parseFloat(originSplit[1]) || 0,
      bounds,
      determinant,
      x,
      y;

  if (!originIsAbsolute) {
    bounds = _getBBox(target);
    xOrigin = bounds.x + (~originSplit[0].indexOf("%") ? xOrigin / 100 * bounds.width : xOrigin);
    yOrigin = bounds.y + (~(originSplit[1] || originSplit[0]).indexOf("%") ? yOrigin / 100 * bounds.height : yOrigin);
  } else if (matrix !== _identity2DMatrix && (determinant = a * d - b * c)) {
    //if it's zero (like if scaleX and scaleY are zero), skip it to avoid errors with dividing by zero.
    x = xOrigin * (d / determinant) + yOrigin * (-c / determinant) + (c * ty - d * tx) / determinant;
    y = xOrigin * (-b / determinant) + yOrigin * (a / determinant) - (a * ty - b * tx) / determinant;
    xOrigin = x;
    yOrigin = y;
  }

  if (smooth || smooth !== false && cache.smooth) {
    tx = xOrigin - xOriginOld;
    ty = yOrigin - yOriginOld;
    cache.xOffset += tx * a + ty * c - tx;
    cache.yOffset += tx * b + ty * d - ty;
  } else {
    cache.xOffset = cache.yOffset = 0;
  }

  cache.xOrigin = xOrigin;
  cache.yOrigin = yOrigin;
  cache.smooth = !!smooth;
  cache.origin = origin;
  cache.originIsAbsolute = !!originIsAbsolute;

  if (pluginToAddPropTweensTo) {
    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOrigin", xOriginOld, xOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOrigin", yOriginOld, yOrigin);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "xOffset", xOffsetOld, cache.xOffset);

    _addNonTweeningPT(pluginToAddPropTweensTo, cache, "yOffset", yOffsetOld, cache.yOffset);
  }
},
    _parseTransform = function _parseTransform(target, uncache) {
  var cache = target._gsap || new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["GSCache"](target);

  if ("x" in cache && !uncache) {
    return cache;
  }

  var style = target.style,
      invertedScaleX = cache.scaleX < 0,
      xOrigin = cache.xOrigin || 0,
      yOrigin = cache.yOrigin || 0,
      px = "px",
      deg = "deg",
      origin = _getComputedProperty(target, _transformOriginProp) || "0",
      x,
      y,
      z,
      scaleX,
      scaleY,
      rotation,
      rotationX,
      rotationY,
      skewX,
      skewY,
      perspective,
      matrix,
      angle,
      cos,
      sin,
      a,
      b,
      c,
      d,
      a12,
      a22,
      t1,
      t2,
      t3,
      a13,
      a23,
      a33,
      a42,
      a43,
      a32;
  x = y = z = rotation = rotationX = rotationY = skewX = skewY = perspective = 0;
  scaleX = scaleY = 1;
  cache.svg = !!(target.getCTM && _isSVG(target));
  matrix = _getMatrix(target, cache.svg);

  if (cache.svg) {
    _applySVGOrigin(target, origin, cache.originIsAbsolute, cache.smooth !== false, matrix);
  }

  if (matrix !== _identity2DMatrix) {
    a = matrix[0]; //a11

    b = matrix[1]; //a21

    c = matrix[2]; //a31

    d = matrix[3]; //a41

    x = a12 = matrix[4];
    y = a22 = matrix[5]; //2D matrix

    if (matrix.length === 6) {
      scaleX = Math.sqrt(a * a + b * b);
      scaleY = Math.sqrt(d * d + c * c);
      rotation = a || b ? _atan2(b, a) * _RAD2DEG : cache.rotation || 0; //note: if scaleX is 0, we cannot accurately measure rotation. Same for skewX with a scaleY of 0. Therefore, we default to the previously recorded value (or zero if that doesn't exist).

      skewX = c || d ? _atan2(c, d) * _RAD2DEG + rotation : cache.skewX || 0;

      if (cache.svg) {
        x -= xOrigin - (xOrigin * a + yOrigin * c);
        y -= yOrigin - (xOrigin * b + yOrigin * d);
      } //3D matrix

    } else {
      a32 = matrix[6];
      a42 = matrix[7];
      a13 = matrix[8];
      a23 = matrix[9];
      a33 = matrix[10];
      a43 = matrix[11];
      x = matrix[12];
      y = matrix[13];
      z = matrix[14];
      angle = _atan2(a32, a33);
      rotationX = angle * _RAD2DEG; //rotationX

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a12 * cos + a13 * sin;
        t2 = a22 * cos + a23 * sin;
        t3 = a32 * cos + a33 * sin;
        a13 = a12 * -sin + a13 * cos;
        a23 = a22 * -sin + a23 * cos;
        a33 = a32 * -sin + a33 * cos;
        a43 = a42 * -sin + a43 * cos;
        a12 = t1;
        a22 = t2;
        a32 = t3;
      } //rotationY


      angle = _atan2(-c, a33);
      rotationY = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(-angle);
        sin = Math.sin(-angle);
        t1 = a * cos - a13 * sin;
        t2 = b * cos - a23 * sin;
        t3 = c * cos - a33 * sin;
        a43 = d * sin + a43 * cos;
        a = t1;
        b = t2;
        c = t3;
      } //rotationZ


      angle = _atan2(b, a);
      rotation = angle * _RAD2DEG;

      if (angle) {
        cos = Math.cos(angle);
        sin = Math.sin(angle);
        t1 = a * cos + b * sin;
        t2 = a12 * cos + a22 * sin;
        b = b * cos - a * sin;
        a22 = a22 * cos - a12 * sin;
        a = t1;
        a12 = t2;
      }

      if (rotationX && Math.abs(rotationX) + Math.abs(rotation) > 359.9) {
        //when rotationY is set, it will often be parsed as 180 degrees different than it should be, and rotationX and rotation both being 180 (it looks the same), so we adjust for that here.
        rotationX = rotation = 0;
        rotationY = 180 - rotationY;
      }

      scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a * a + b * b + c * c));
      scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(Math.sqrt(a22 * a22 + a32 * a32));
      angle = _atan2(a12, a22);
      skewX = Math.abs(angle) > 0.0002 ? angle * _RAD2DEG : 0;
      perspective = a43 ? 1 / (a43 < 0 ? -a43 : a43) : 0;
    }

    if (cache.svg) {
      //sense if there are CSS transforms applied on an SVG element in which case we must overwrite them when rendering. The transform attribute is more reliable cross-browser, but we can't just remove the CSS ones because they may be applied in a CSS rule somewhere (not just inline).
      matrix = target.getAttribute("transform");
      cache.forceCSS = target.setAttribute("transform", "") || !_isNullTransform(_getComputedProperty(target, _transformProp));
      matrix && target.setAttribute("transform", matrix);
    }
  }

  if (Math.abs(skewX) > 90 && Math.abs(skewX) < 270) {
    if (invertedScaleX) {
      scaleX *= -1;
      skewX += rotation <= 0 ? 180 : -180;
      rotation += rotation <= 0 ? 180 : -180;
    } else {
      scaleY *= -1;
      skewX += skewX <= 0 ? 180 : -180;
    }
  }

  cache.x = ((cache.xPercent = x && Math.round(target.offsetWidth / 2) === Math.round(-x) ? -50 : 0) ? 0 : x) + px;
  cache.y = ((cache.yPercent = y && Math.round(target.offsetHeight / 2) === Math.round(-y) ? -50 : 0) ? 0 : y) + px;
  cache.z = z + px;
  cache.scaleX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleX);
  cache.scaleY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(scaleY);
  cache.rotation = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotation) + deg;
  cache.rotationX = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationX) + deg;
  cache.rotationY = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(rotationY) + deg;
  cache.skewX = skewX + deg;
  cache.skewY = skewY + deg;
  cache.transformPerspective = perspective + px;

  if (cache.zOrigin = parseFloat(origin.split(" ")[2]) || 0) {
    style[_transformOriginProp] = _firstTwoOnly(origin);
  }

  cache.xOffset = cache.yOffset = 0;
  cache.force3D = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].force3D;
  cache.renderTransform = cache.svg ? _renderSVGTransforms : _supports3D ? _renderCSSTransforms : _renderNon3DTransforms;
  return cache;
},
    _firstTwoOnly = function _firstTwoOnly(value) {
  return (value = value.split(" "))[0] + " " + value[1];
},
    //for handling transformOrigin values, stripping out the 3rd dimension
_addPxTranslate = function _addPxTranslate(target, start, value) {
  var unit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(start);
  return Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(parseFloat(start) + parseFloat(_convertToUnit(target, "x", value + "px", unit))) + unit;
},
    _renderNon3DTransforms = function _renderNon3DTransforms(ratio, cache) {
  cache.z = "0px";
  cache.rotationY = cache.rotationX = "0deg";
  cache.force3D = 0;

  _renderCSSTransforms(ratio, cache);
},
    _zeroDeg = "0deg",
    _zeroPx = "0px",
    _endParenthesis = ") ",
    _renderCSSTransforms = function _renderCSSTransforms(ratio, cache) {
  var _ref = cache || this,
      xPercent = _ref.xPercent,
      yPercent = _ref.yPercent,
      x = _ref.x,
      y = _ref.y,
      z = _ref.z,
      rotation = _ref.rotation,
      rotationY = _ref.rotationY,
      rotationX = _ref.rotationX,
      skewX = _ref.skewX,
      skewY = _ref.skewY,
      scaleX = _ref.scaleX,
      scaleY = _ref.scaleY,
      transformPerspective = _ref.transformPerspective,
      force3D = _ref.force3D,
      target = _ref.target,
      zOrigin = _ref.zOrigin,
      transforms = "",
      use3D = force3D === "auto" && ratio && ratio !== 1 || force3D === true; // Safari has a bug that causes it not to render 3D transform-origin values properly, so we force the z origin to 0, record it in the cache, and then do the math here to offset the translate values accordingly (basically do the 3D transform-origin part manually)


  if (zOrigin && (rotationX !== _zeroDeg || rotationY !== _zeroDeg)) {
    var angle = parseFloat(rotationY) * _DEG2RAD,
        a13 = Math.sin(angle),
        a33 = Math.cos(angle),
        cos;

    angle = parseFloat(rotationX) * _DEG2RAD;
    cos = Math.cos(angle);
    x = _addPxTranslate(target, x, a13 * cos * -zOrigin);
    y = _addPxTranslate(target, y, -Math.sin(angle) * -zOrigin);
    z = _addPxTranslate(target, z, a33 * cos * -zOrigin + zOrigin);
  }

  if (xPercent || yPercent) {
    transforms = "translate(" + xPercent + "%, " + yPercent + "%) ";
  }

  if (use3D || x !== _zeroPx || y !== _zeroPx || z !== _zeroPx) {
    transforms += z !== _zeroPx || use3D ? "translate3d(" + x + ", " + y + ", " + z + ") " : "translate(" + x + ", " + y + _endParenthesis;
  }

  if (transformPerspective !== _zeroPx) {
    transforms += "perspective(" + transformPerspective + _endParenthesis;
  }

  if (rotation !== _zeroDeg) {
    transforms += "rotate(" + rotation + _endParenthesis;
  }

  if (rotationY !== _zeroDeg) {
    transforms += "rotateY(" + rotationY + _endParenthesis;
  }

  if (rotationX !== _zeroDeg) {
    transforms += "rotateX(" + rotationX + _endParenthesis;
  }

  if (skewX !== _zeroDeg || skewY !== _zeroDeg) {
    transforms += "skew(" + skewX + ", " + skewY + _endParenthesis;
  }

  if (scaleX !== 1 || scaleY !== 1) {
    transforms += "scale(" + scaleX + ", " + scaleY + _endParenthesis;
  }

  target.style[_transformProp] = transforms || "translate(0, 0)";
},
    _renderSVGTransforms = function _renderSVGTransforms(ratio, cache) {
  var _ref2 = cache || this,
      xPercent = _ref2.xPercent,
      yPercent = _ref2.yPercent,
      x = _ref2.x,
      y = _ref2.y,
      rotation = _ref2.rotation,
      skewX = _ref2.skewX,
      skewY = _ref2.skewY,
      scaleX = _ref2.scaleX,
      scaleY = _ref2.scaleY,
      target = _ref2.target,
      xOrigin = _ref2.xOrigin,
      yOrigin = _ref2.yOrigin,
      xOffset = _ref2.xOffset,
      yOffset = _ref2.yOffset,
      forceCSS = _ref2.forceCSS,
      tx = parseFloat(x),
      ty = parseFloat(y),
      a11,
      a21,
      a12,
      a22,
      temp;

  rotation = parseFloat(rotation);
  skewX = parseFloat(skewX);
  skewY = parseFloat(skewY);

  if (skewY) {
    //for performance reasons, we combine all skewing into the skewX and rotation values. Remember, a skewY of 10 degrees looks the same as a rotation of 10 degrees plus a skewX of 10 degrees.
    skewY = parseFloat(skewY);
    skewX += skewY;
    rotation += skewY;
  }

  if (rotation || skewX) {
    rotation *= _DEG2RAD;
    skewX *= _DEG2RAD;
    a11 = Math.cos(rotation) * scaleX;
    a21 = Math.sin(rotation) * scaleX;
    a12 = Math.sin(rotation - skewX) * -scaleY;
    a22 = Math.cos(rotation - skewX) * scaleY;

    if (skewX) {
      skewY *= _DEG2RAD;
      temp = Math.tan(skewX - skewY);
      temp = Math.sqrt(1 + temp * temp);
      a12 *= temp;
      a22 *= temp;

      if (skewY) {
        temp = Math.tan(skewY);
        temp = Math.sqrt(1 + temp * temp);
        a11 *= temp;
        a21 *= temp;
      }
    }

    a11 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a11);
    a21 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a21);
    a12 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a12);
    a22 = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(a22);
  } else {
    a11 = scaleX;
    a22 = scaleY;
    a21 = a12 = 0;
  }

  if (tx && !~(x + "").indexOf("px") || ty && !~(y + "").indexOf("px")) {
    tx = _convertToUnit(target, "x", x, "px");
    ty = _convertToUnit(target, "y", y, "px");
  }

  if (xOrigin || yOrigin || xOffset || yOffset) {
    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xOrigin - (xOrigin * a11 + yOrigin * a12) + xOffset);
    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yOrigin - (xOrigin * a21 + yOrigin * a22) + yOffset);
  }

  if (xPercent || yPercent) {
    //The SVG spec doesn't support percentage-based translation in the "transform" attribute, so we merge it into the translation to simulate it.
    temp = target.getBBox();
    tx = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(tx + xPercent / 100 * temp.width);
    ty = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_round"])(ty + yPercent / 100 * temp.height);
  }

  temp = "matrix(" + a11 + "," + a21 + "," + a12 + "," + a22 + "," + tx + "," + ty + ")";
  target.setAttribute("transform", temp);

  if (forceCSS) {
    //some browsers prioritize CSS transforms over the transform attribute. When we sense that the user has CSS transforms applied, we must overwrite them this way (otherwise some browser simply won't render the  transform attribute changes!)
    target.style[_transformProp] = temp;
  }
},
    _addRotationalPropTween = function _addRotationalPropTween(plugin, target, property, startNum, endValue, relative) {
  var cap = 360,
      isString = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isString"])(endValue),
      endNum = parseFloat(endValue) * (isString && ~endValue.indexOf("rad") ? _RAD2DEG : 1),
      change = relative ? endNum * relative : endNum - startNum,
      finalValue = startNum + change + "deg",
      direction,
      pt;

  if (isString) {
    direction = endValue.split("_")[1];

    if (direction === "short") {
      change %= cap;

      if (change !== change % (cap / 2)) {
        change += change < 0 ? cap : -cap;
      }
    }

    if (direction === "cw" && change < 0) {
      change = (change + cap * _bigNum) % cap - ~~(change / cap) * cap;
    } else if (direction === "ccw" && change > 0) {
      change = (change - cap * _bigNum) % cap - ~~(change / cap) * cap;
    }
  }

  plugin._pt = pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, target, property, startNum, change, _renderPropWithEnd);
  pt.e = finalValue;
  pt.u = "deg";

  plugin._props.push(property);

  return pt;
},
    _addRawTransformPTs = function _addRawTransformPTs(plugin, transforms, target) {
  //for handling cases where someone passes in a whole transform string, like transform: "scale(2, 3) rotate(20deg) translateY(30em)"
  var style = _tempDivStyler.style,
      startCache = target._gsap,
      endCache,
      p,
      startValue,
      endValue,
      startNum,
      endNum,
      startUnit,
      endUnit;
  style.cssText = getComputedStyle(target).cssText + ";position:absolute;display:block;"; //%-based translations will fail unless we set the width/height to match the original target (and padding/borders can affect it)

  style[_transformProp] = transforms;

  _doc.body.appendChild(_tempDivStyler);

  endCache = _parseTransform(_tempDivStyler, 1);

  for (p in _transformProps) {
    startValue = startCache[p];
    endValue = endCache[p];

    if (startValue !== endValue && p !== "perspective") {
      //tweening to no perspective gives very unintuitive results - just keep the same perspective in that case.
      startUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(startValue);
      endUnit = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["getUnit"])(endValue);
      startNum = startUnit !== endUnit ? _convertToUnit(target, p, startValue, endUnit) : parseFloat(startValue);
      endNum = parseFloat(endValue);
      plugin._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](plugin._pt, startCache, p, startNum, endNum - startNum, _renderCSSProp);
      plugin._pt.u = endUnit;

      plugin._props.push(p);
    }
  }

  _doc.body.removeChild(_tempDivStyler);
};

var CSSPlugin = {
  name: "css",
  register: _initCore,
  targetTest: function targetTest(target) {
    return target.style && target.nodeType;
  },
  init: function init(target, vars, tween, index, targets) {
    var props = this._props,
        style = target.style,
        startValue,
        endValue,
        endNum,
        startNum,
        type,
        specialProp,
        p,
        startUnit,
        endUnit,
        relative,
        isTransformRelated,
        transformPropTween,
        cache,
        smooth,
        hasPriority;

    if (!_pluginInitted) {
      _initCore();
    }

    for (p in vars) {
      if (p === "autoRound") {
        continue;
      }

      endValue = vars[p];

      if (_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_plugins"][p] && Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_checkPlugin"])(p, vars, tween, index, target, targets)) {
        //plugins
        continue;
      }

      type = _typeof(endValue);
      specialProp = _specialProps[p];

      if (type === "function") {
        endValue = endValue.call(tween, index, target, targets);
        type = _typeof(endValue);
      }

      if (type === "string" && ~endValue.indexOf("random(")) {
        endValue = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_replaceRandom"])(endValue);
      }

      if (specialProp) {
        if (specialProp(this, target, p, endValue, tween)) {
          hasPriority = 1;
        }
      } else if (p.substr(0, 2) === "--") {
        //CSS variable
        this.add(style, "setProperty", getComputedStyle(target).getPropertyValue(p) + "", endValue + "", index, targets, 0, 0, p);
      } else {
        startValue = _get(target, p);
        startNum = parseFloat(startValue);
        relative = type === "string" && endValue.charAt(1) === "=" ? +(endValue.charAt(0) + "1") : 0;

        if (relative) {
          endValue = endValue.substr(2);
        }

        endNum = parseFloat(endValue);

        if (p in _propertyAliases) {
          if (p === "autoAlpha") {
            //special case where we control the visibility along with opacity. We still allow the opacity value to pass through and get tweened.
            if (startNum === 1 && _get(target, "visibility") === "hidden" && endNum) {
              //if visibility is initially set to "hidden", we should interpret that as intent to make opacity 0 (a convenience)
              startNum = 0;
            }

            _addNonTweeningPT(this, style, "visibility", startNum ? "inherit" : "hidden", endNum ? "inherit" : "hidden", !endNum);
          }

          if (p !== "scale") {
            p = _propertyAliases[p];

            if (~p.indexOf(",")) {
              p = p.split(",")[0];
            }
          }
        }

        isTransformRelated = p in _transformProps; //--- TRANSFORM-RELATED ---

        if (isTransformRelated) {
          if (!transformPropTween) {
            cache = target._gsap;
            smooth = vars.smoothOrigin !== false && cache.smooth;
            transformPropTween = this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, style, _transformProp, 0, 1, cache.renderTransform, cache); //the first time through, create the rendering PropTween so that it runs LAST (in the linked list, we keep adding to the beginning)

            transformPropTween.dep = 1; //flag it as dependent so that if things get killed/overwritten and this is the only PropTween left, we can safely kill the whole tween.
          }

          if (p === "scale") {
            this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, target, "scale", startNum, relative ? relative * endNum : endNum - startNum, 0, 0, _setterScale);
            props.push("scale");
            continue;
          } else if (p === "transformOrigin") {
            endValue = _convertKeywordsToPercentages(endValue); //in case something like "left top" or "bottom right" is passed in. Convert to percentages.

            if (cache.svg) {
              _applySVGOrigin(target, endValue, 0, smooth, 0, this);
            } else {
              endUnit = parseFloat(endValue.split(" ")[2]); //handle the zOrigin separately!

              if (endUnit !== cache.zOrigin) {
                _addNonTweeningPT(this, cache, "zOrigin", cache.zOrigin, endUnit);
              }

              _addNonTweeningPT(this, style, p, _firstTwoOnly(startValue), _firstTwoOnly(endValue));
            }

            continue;
          } else if (p === "svgOrigin") {
            _applySVGOrigin(target, endValue, 1, smooth, 0, this);

            continue;
          } else if (p in _rotationalProperties) {
            _addRotationalPropTween(this, cache, p, startNum, endValue, relative);

            continue;
          } else if (p === "smoothOrigin") {
            _addNonTweeningPT(this, cache, "smooth", cache.smooth, endValue);

            continue;
          } else if (p === "force3D") {
            cache[p] = endValue;
            continue;
          } else if (p === "transform") {
            _addRawTransformPTs(this, endValue, target);

            continue;
          }
        }

        if (isTransformRelated || (endNum || endNum === 0) && (startNum || startNum === 0) && !_complexExp.test(endValue) && p in style) {
          startUnit = (startValue + "").substr((startNum + "").length);
          endUnit = (endValue + "").substr((endNum + "").length) || (p in _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units ? _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[p] : startUnit);

          if (startUnit !== endUnit) {
            startNum = _convertToUnit(target, p, startValue, endUnit);
          }

          this._pt = new _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["PropTween"](this._pt, isTransformRelated ? cache : style, p, startNum, relative ? relative * endNum : endNum - startNum, endUnit === "px" && vars.autoRound !== false && !isTransformRelated ? _renderRoundedCSSProp : _renderCSSProp);
          this._pt.u = endUnit || 0;

          if (startUnit !== endUnit) {
            //when the tween goes all the way back to the beginning, we need to revert it to the OLD/ORIGINAL value (with those units). We record that as a "b" (beginning) property and point to a render method that handles that. (performance optimization)
            this._pt.b = startValue;
            this._pt.r = _renderCSSPropWithBeginning;
          }
        } else if (!(p in style)) {
          if (p in target) {
            //maybe it's not a style - it could be a property added directly to an element in which case we'll try to animate that.
            this.add(target, p, target[p], endValue, index, targets);
          } else {
            Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_missingPlugin"])("Invalid " + p + " tween " + endValue + ". Missing plugin? gsap.registerPlugin()");

            continue;
          }
        } else {
          _tweenComplexCSSString.call(this, target, p, startValue, endValue);
        }

        props.push(p);
      }
    }

    if (hasPriority) {
      Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_sortPropTweensByPriority"])(this);
    }
  },
  get: _get,
  aliases: _propertyAliases,
  getSetter: function getSetter(target, property, plugin) {
    //returns a setter function that accepts target, property, value and applies it accordingly. Remember, properties like "x" aren't as simple as target.style.property = value because they've got to be applied to a proxy object and then merged into a transform string in a renderer.
    return property in _transformProps && property !== _transformOriginProp && (target._gsap.x || _get(target, "x")) ? plugin && _recentSetterPlugin === plugin ? property === "scale" ? _setterScale : _setterTransform : (_recentSetterPlugin = plugin || {}) && (property === "scale" ? _setterScaleWithRender : _setterTransformWithRender) : target.style && !Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_isUndefined"])(target.style[property]) ? _setterCSSStyle : ~property.indexOf("-") ? _setterCSSProp : Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_getSetter"])(target, property);
  }
};
_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].utils.checkPrefix = _checkPropPrefix;

(function (positionAndScale, rotation, others, aliases) {
  var all = Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(positionAndScale + "," + rotation + "," + others, function (name) {
    _transformProps[name] = 1;
  });

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(rotation, function (name) {
    _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "deg";
    _rotationalProperties[name] = 1;
  });

  _propertyAliases[all[13]] = positionAndScale + "," + rotation;

  Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])(aliases, function (name) {
    var split = name.split(":");
    _propertyAliases[split[1]] = all[split[0]];
  });
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,9:rotateX,10:rotateY");

Object(_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_forEachName"])("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (name) {
  _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["_config"].units[name] = "px";
});

_gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(CSSPlugin);


/***/ }),

/***/ "../node_modules/gsap/gsap-core.js":
/*!*****************************************!*\
  !*** ../node_modules/gsap/gsap-core.js ***!
  \*****************************************/
/*! exports provided: GSCache, Animation, Timeline, Tween, PropTween, gsap, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ, TweenMax, TweenLite, TimelineMax, TimelineLite, default, wrap, wrapYoyo, distribute, random, snap, normalize, getUnit, clamp, splitColor, toArray, mapRange, pipe, unitize, interpolate, _getProperty, _numExp, _isString, _isUndefined, _renderComplexString, _relExp, _setDefaults, _removeLinkedListItem, _forEachName, _sortPropTweensByPriority, _colorStringFilter, _replaceRandom, _checkPlugin, _plugins, _ticker, _config, _roundModifier, _round, _missingPlugin, _getSetter, _getCache */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GSCache", function() { return GSCache; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Animation", function() { return Animation; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Timeline", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Tween", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropTween", function() { return PropTween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return Power0; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return Power1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return Power2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return Power3; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return Power4; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return Linear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return Quad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return Cubic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return Quart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return Quint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return Strong; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return Elastic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return Back; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return SteppedEase; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return Bounce; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return Sine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return Expo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return Circ; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return Tween; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return Timeline; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrap", function() { return wrap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wrapYoyo", function() { return wrapYoyo; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "distribute", function() { return distribute; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "random", function() { return random; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "snap", function() { return snap; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "normalize", function() { return normalize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUnit", function() { return getUnit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "clamp", function() { return clamp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitColor", function() { return splitColor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mapRange", function() { return mapRange; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pipe", function() { return pipe; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unitize", function() { return unitize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "interpolate", function() { return interpolate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getProperty", function() { return _getProperty; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_numExp", function() { return _numExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isString", function() { return _isString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_isUndefined", function() { return _isUndefined; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_renderComplexString", function() { return _renderComplexString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_relExp", function() { return _relExp; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_setDefaults", function() { return _setDefaults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_removeLinkedListItem", function() { return _removeLinkedListItem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_forEachName", function() { return _forEachName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_sortPropTweensByPriority", function() { return _sortPropTweensByPriority; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_colorStringFilter", function() { return _colorStringFilter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_replaceRandom", function() { return _replaceRandom; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_checkPlugin", function() { return _checkPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_plugins", function() { return _plugins; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_ticker", function() { return _ticker; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_config", function() { return _config; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_roundModifier", function() { return _roundModifier; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_round", function() { return _round; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_missingPlugin", function() { return _missingPlugin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getSetter", function() { return _getSetter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_getCache", function() { return _getCache; });
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}
/*!
 * GSAP 3.0.1
 * https://greensock.com
 *
 * @license Copyright 2008-2019, GreenSock. All rights reserved.
 * Subject to the terms at https://greensock.com/standard-license or for
 * Club GreenSock members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/

/* eslint-disable */


var _config = {
  autoSleep: 120,
  force3D: "auto",
  nullTargetWarn: 1,
  units: {
    lineHeight: ""
  }
},
    _defaults = {
  duration: .5,
  overwrite: false,
  delay: 0
},
    _bigNum = 1e8,
    _tinyNum = 1 / _bigNum,
    _2PI = Math.PI * 2,
    _HALF_PI = _2PI / 4,
    _gsID = 0,
    _sqrt = Math.sqrt,
    _cos = Math.cos,
    _sin = Math.sin,
    _isString = function _isString(value) {
  return typeof value === "string";
},
    _isFunction = function _isFunction(value) {
  return typeof value === "function";
},
    _isNumber = function _isNumber(value) {
  return typeof value === "number";
},
    _isUndefined = function _isUndefined(value) {
  return typeof value === "undefined";
},
    _isObject = function _isObject(value) {
  return _typeof(value) === "object";
},
    _isNotFalse = function _isNotFalse(value) {
  return value !== false;
},
    _windowExists = function _windowExists() {
  return typeof window !== "undefined";
},
    _isFuncOrString = function _isFuncOrString(value) {
  return _isFunction(value) || _isString(value);
},
    _isArray = Array.isArray,
    _strictNumExp = /(?:-?\.?\d|\.)+/gi,
    //only numbers (including negatives and decimals) but NOT relative values.
_numExp = /[-+=\.]*\d+[\.e\-\+]*\d*[e\-\+]*\d*/gi,
    //finds any numbers, including ones that start with += or -=, negative numbers, and ones in scientific notation like 1e-8.
_complexStringNumExp = /[-+=\.]*\d+(?:\.|e-|e)*\d*/gi,
    //duplicate so that while we're looping through matches from exec(), it doesn't contaminate the lastIndex of _numExp which we use to search for colors too.
_parenthesesExp = /\(([^()]+)\)/i,
    //finds the string between parentheses.
_relExp = /[\+-]=-?[\.\d]+/,
    _delimitedValueExp = /[#\-+\.]*\b[a-z\d-=+%.]+/gi,
    _globalTimeline,
    _win,
    _coreInitted,
    _doc,
    _globals = {},
    _installScope = {},
    _coreReady,
    _install = function _install(scope) {
  return (_installScope = _merge(scope, _globals)) && gsap;
},
    _missingPlugin = function _missingPlugin(property, value) {
  return console.warn("Invalid", property, "tween of", value, "Missing plugin? gsap.registerPlugin()");
},
    _warn = function _warn(message, suppress) {
  return !suppress && console.warn(message);
},
    _addGlobal = function _addGlobal(name, obj) {
  return name && (_globals[name] = obj) && _installScope && (_installScope[name] = obj) || _globals;
},
    _emptyFunc = function _emptyFunc() {
  return 0;
},
    _reservedProps = {},
    _lazyTweens = [],
    _lazyLookup = {},
    _plugins = {},
    _effects = {},
    _nextGCFrame = 30,
    _harnessPlugins = [],
    _callbackNames = "onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt",
    _harness = function _harness(targets) {
  var target = targets[0],
      harnessPlugin,
      i;

  if (!_isObject(target) && !_isFunction(target)) {
    return _isArray(targets) ? targets : [targets];
  }

  if (!(harnessPlugin = (target._gsap || {}).harness)) {
    i = _harnessPlugins.length;

    while (i-- && !_harnessPlugins[i].targetTest(target)) {}

    harnessPlugin = _harnessPlugins[i];
  }

  i = targets.length;

  while (i--) {
    targets[i]._gsap || (targets[i]._gsap = new GSCache(targets[i], harnessPlugin));
  }

  return targets;
},
    _getCache = function _getCache(target) {
  return target._gsap || _harness(toArray(target))[0]._gsap;
},
    _getProperty = function _getProperty(target, property) {
  var currentValue = target[property];
  return _isFunction(currentValue) ? target[property]() : _isUndefined(currentValue) && target.getAttribute(property) || currentValue;
},
    _forEachName = function _forEachName(names, func) {
  return (names = names.split(",")).forEach(func) || names;
},
    //split a comma-delimited list of names into an array, then run a forEach() function and return the split array (this is just a way to consolidate/shorten some code).
_round = function _round(value) {
  return Math.round(value * 10000) / 10000;
},
    _arrayContainsAny = function _arrayContainsAny(toSearch, toFind) {
  //searches one array to find matches for any of the items in the toFind array. As soon as one is found, it returns true. It does NOT return all the matches; it's simply a boolean search.
  var l = toFind.length,
      i = 0;

  for (; toSearch.indexOf(toFind[i]) < 0 && ++i < l;) {}

  return i < l;
},
    _parseVars = function _parseVars(params, type, parent) {
  //reads the arguments passed to one of the key methods and figures out if the user is defining things with the OLD/legacy syntax where the duration is the 2nd parameter, and then it adjusts things accordingly and spits back the corrected vars object (with the duration added if necessary, as well as runBackwards or startAt or immediateRender). type 0 = to()/staggerTo(), 1 = from()/staggerFrom(), 2 = fromTo()/staggerFromTo()
  var isLegacy = _isNumber(params[1]),
      varsIndex = (isLegacy ? 2 : 1) + (type < 2 ? 0 : 1),
      vars = params[varsIndex],
      i;

  if (isLegacy) {
    vars.duration = params[1];
  }

  if (type === 1) {
    vars.runBackwards = 1;
    vars.immediateRender = _isNotFalse(vars.immediateRender);
  } else if (type === 2) {
    i = params[varsIndex - 1]; //"from" vars

    vars.startAt = i;
    vars.immediateRender = _isNotFalse(vars.immediateRender);
  }

  vars.parent = parent;
  return vars;
},
    _lazyRender = function _lazyRender() {
  var l = _lazyTweens.length,
      a = _lazyTweens.slice(0),
      i,
      tween;

  _lazyLookup = {};
  _lazyTweens.length = 0;

  for (i = 0; i < l; i++) {
    tween = a[i];

    if (tween && tween._lazy) {
      tween.render(tween._lazy[0], tween._lazy[1], true)._lazy = 0;
    }
  }
},
    _lazySafeRender = function _lazySafeRender(animation, time, suppressEvents, force) {
  if (_lazyTweens.length) {
    _lazyRender();
  }

  animation.render(time, suppressEvents, force);

  if (_lazyTweens.length) {
    //in case rendering caused any tweens to lazy-init, we should render them because typically when someone calls seek() or time() or progress(), they expect an immediate render.
    _lazyRender();
  }
},
    _numericIfPossible = function _numericIfPossible(value) {
  var n = parseFloat(value);
  return n || n === 0 ? n : value;
},
    _passThrough = function _passThrough(p) {
  return p;
},
    _setDefaults = function _setDefaults(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj)) {
      obj[p] = defaults[p];
    }
  }

  return obj;
},
    _setKeyframeDefaults = function _setKeyframeDefaults(obj, defaults) {
  for (var p in defaults) {
    if (!(p in obj) && p !== "duration" && p !== "ease") {
      obj[p] = defaults[p];
    }
  }
},
    _merge = function _merge(base, toMerge) {
  for (var p in toMerge) {
    base[p] = toMerge[p];
  }

  return base;
},
    _mergeDeep = function _mergeDeep(base, toMerge) {
  for (var p in toMerge) {
    base[p] = _isObject(toMerge[p]) ? _mergeDeep(base[p] || (base[p] = {}), toMerge[p]) : toMerge[p];
  }

  return base;
},
    _copyExcluding = function _copyExcluding(obj, excluding) {
  var copy = {},
      p;

  for (p in obj) {
    if (!(p in excluding)) {
      copy[p] = obj[p];
    }
  }

  return copy;
},
    _inheritDefaults = function _inheritDefaults(vars) {
  var parent = vars.parent || _globalTimeline,
      func = vars.keyframes ? _setKeyframeDefaults : _setDefaults;

  if (_isNotFalse(vars.inherit)) {
    while (parent) {
      func(vars, parent.vars.defaults);
      parent = parent.parent;
    }
  }

  return vars;
},
    _arraysMatch = function _arraysMatch(a1, a2) {
  var i = a1.length,
      match = i === a2.length;

  while (match && i-- && a1[i] === a2[i]) {}

  return i < 0;
},
    _addLinkedListItem = function _addLinkedListItem(parent, child, firstProp, lastProp, sortBy) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = parent[lastProp],
      t;

  if (sortBy) {
    t = child[sortBy];

    while (prev && prev[sortBy] > t) {
      prev = prev._prev;
    }
  }

  if (prev) {
    child._next = prev._next;
    prev._next = child;
  } else {
    child._next = parent[firstProp];
    parent[firstProp] = child;
  }

  if (child._next) {
    child._next._prev = child;
  } else {
    parent[lastProp] = child;
  }

  child._prev = prev;
  child.parent = parent;
  return child;
},
    _removeLinkedListItem = function _removeLinkedListItem(parent, child, firstProp, lastProp) {
  if (firstProp === void 0) {
    firstProp = "_first";
  }

  if (lastProp === void 0) {
    lastProp = "_last";
  }

  var prev = child._prev,
      next = child._next;

  if (prev) {
    prev._next = next;
  } else if (parent[firstProp] === child) {
    parent[firstProp] = next;
  }

  if (next) {
    next._prev = prev;
  } else if (parent[lastProp] === child) {
    parent[lastProp] = prev;
  }

  child._dp = parent; //record the parent as _dp just so we can revert if necessary. But parent should be null to indicate the item isn't in a linked list.

  child._next = child._prev = child.parent = null;
},
    _removeFromParent = function _removeFromParent(child, onlyIfParentHasAutoRemove) {
  if (child.parent && (!onlyIfParentHasAutoRemove || child.parent.autoRemoveChildren)) {
    child.parent.remove(child);
  }

  child._act = 0;
},
    _uncache = function _uncache(animation) {
  var a = animation;

  while (a) {
    a._dirty = 1;
    a = a.parent;
  }

  return animation;
},
    _recacheAncestors = function _recacheAncestors(animation) {
  var parent = animation.parent;

  while (parent && parent.parent) {
    //sometimes we must force a re-sort of all children and update the duration/totalDuration of all ancestor timelines immediately in case, for example, in the middle of a render loop, one tween alters another tween's timeScale which shoves its startTime before 0, forcing the parent timeline to shift around and shiftChildren() which could affect that next tween's render (startTime). Doesn't matter for the root timeline though.
    parent._dirty = 1;
    parent.totalDuration();
    parent = parent.parent;
  }

  return animation;
},
    _hasNoPausedAncestors = function _hasNoPausedAncestors(animation) {
  return !animation || animation._ts && _hasNoPausedAncestors(animation.parent);
},
    _elapsedCycleDuration = function _elapsedCycleDuration(animation) {
  var cycleDuration;
  return animation._repeat ? (cycleDuration = animation.duration() + animation._rDelay) * ~~(animation._tTime / cycleDuration) : 0;
},
    _parentToChildTotalTime = function _parentToChildTotalTime(parentTime, child) {
  return child._ts > 0 ? (parentTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (parentTime - child._start) * child._ts;
},

/*
_totalTimeToTime = (clampedTotalTime, duration, repeat, repeatDelay, yoyo) => {
	let cycleDuration = duration + repeatDelay,
		time = _round(clampedTotalTime % cycleDuration);
	if (time > duration) {
		time = duration;
	}
	return (yoyo && (~~(clampedTotalTime / cycleDuration) & 1)) ? duration - time : time;
},
*/
_addToTimeline = function _addToTimeline(timeline, child, position) {
  child.parent && _removeFromParent(child);
  child._start = position + child._delay;
  child._end = child._start + (child.totalDuration() / child._ts || 0);

  _addLinkedListItem(timeline, child, "_first", "_last", timeline._sort ? "_start" : 0);

  timeline._recent = child;

  if (child._time || !child._dur && child._initted) {
    //in case, for example, the _start is moved on a tween that has already rendered. Imagine it's at its end state, then the startTime is moved WAY later (after the end of this timeline), it should render at its beginning.
    var curTime = (timeline.rawTime() - child._start) * child._ts;

    if (!child._dur || _clamp(0, child.totalDuration(), curTime) - child._tTime > _tinyNum) {
      child.render(curTime, true);
    }
  }

  _uncache(timeline); //if the timeline has already ended but the inserted tween/timeline extends the duration, we should enable this timeline again so that it renders properly. We should also align the playhead with the parent timeline's when appropriate.


  if (timeline._dp && timeline._time >= timeline._dur && timeline._ts && timeline._dur < timeline.duration()) {
    //in case any of the ancestors had completed but should now be enabled...
    var tl = timeline;

    while (tl._dp) {
      tl.totalTime(tl._tTime, true); //moves the timeline (shifts its startTime) if necessary, and also enables it.

      tl = tl._dp;
    }
  }

  return timeline;
},
    _attemptInitTween = function _attemptInitTween(tween, totalTime, force, suppressEvents) {
  _initTween(tween, totalTime);

  if (!tween._initted) {
    return 1;
  }

  if (!force && tween._pt && tween.vars.lazy) {
    _lazyTweens.push(tween);

    tween._lazy = [totalTime, suppressEvents];
    return 1;
  }
},
    _renderZeroDurationTween = function _renderZeroDurationTween(tween, totalTime, suppressEvents, force) {
  var prevRatio = tween._zTime < 0 ? 0 : 1,
      ratio = totalTime < 0 ? 0 : 1,
      repeatDelay = tween._rDelay,
      tTime = 0,
      pt,
      iteration,
      prevIteration;

  if (repeatDelay && tween._repeat) {
    //in case there's a zero-duration tween that has a repeat with a repeatDelay
    tTime = _clamp(0, tween._tDur, totalTime);
    iteration = ~~(tTime / repeatDelay);

    if (iteration && iteration === tTime / repeatDelay) {
      iteration--;
    }

    prevIteration = ~~(tween._tTime / repeatDelay);

    if (prevIteration && prevIteration === tween._tTime / repeatDelay) {
      prevIteration--;
    }

    if (iteration !== prevIteration) {
      prevRatio = 1 - ratio;

      if (tween.vars.repeatRefresh) {
        tween.invalidate();
      }
    }
  }

  if (!tween._initted && _attemptInitTween(tween, totalTime, force, suppressEvents)) {
    //if we render the very beginning (time == 0) of a fromTo(), we must force the render (normal tweens wouldn't need to render at a time of 0 when the prevTime was also 0). This is also mandatory to make sure overwriting kicks in immediately.
    return;
  }

  if (ratio !== prevRatio || force) {
    if (!suppressEvents || totalTime) {
      //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration tween, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
      tween._zTime = totalTime;
    }

    tween.ratio = ratio;

    if (tween._from) {
      ratio = 1 - ratio;
    }

    tween._time = 0;
    tween._tTime = tTime;

    if (!suppressEvents) {
      _callback(tween, "onStart");
    }

    pt = tween._pt;

    while (pt) {
      pt.r(ratio, pt.d);
      pt = pt._next;
    }

    if (!ratio && tween._startAt && !tween._onUpdate && tween._start) {
      //if the tween is positioned at the VERY beginning (_start 0) of its parent timeline, it's illegal for the playhead to go back further, so we should not render the recorded startAt values.
      tween._startAt.render(totalTime, true, force);
    }

    if (tween._onUpdate && !suppressEvents) {
      _callback(tween, "onUpdate");
    }

    if (tTime && tween._repeat && !suppressEvents && tween.parent) {
      _callback(tween, "onRepeat");
    }

    if ((totalTime >= tween._tDur || totalTime < 0) && tween.ratio === ratio) {
      tween.ratio && _removeFromParent(tween, 1);

      if (!suppressEvents) {
        _callback(tween, tween.ratio ? "onComplete" : "onReverseComplete", true);

        tween._prom && tween.ratio && tween._prom();
      }
    }
  }
},
    _findNextPauseTween = function _findNextPauseTween(animation, prevTime, time) {
  var child;

  if (time > prevTime) {
    child = animation._first;

    while (child && child._start <= time) {
      if (!child._dur && child.data === "isPause" && child._start > prevTime) {
        return child;
      }

      child = child._next;
    }
  } else {
    child = animation._last;

    while (child && child._start >= time) {
      if (!child._dur && child.data === "isPause" && child._start < prevTime) {
        return child;
      }

      child = child._prev;
    }
  }
},
    _onUpdateTotalDuration = function _onUpdateTotalDuration(animation) {
  if (animation instanceof Timeline) {
    return _uncache(animation);
  }

  var repeat = animation._repeat;
  animation._tDur = !repeat ? animation._dur : repeat < 0 ? 1e20 : _round(animation._dur * (repeat + 1) + animation._rDelay * repeat);

  _uncache(animation.parent); //if the tween's duration changed, the parent timeline's duration may have changed, so flag it as "dirty"


  return animation;
},
    _zeroPosition = {
  _start: 0,
  endTime: _emptyFunc
},
    _parsePosition = function _parsePosition(animation, position, useBuildFrom) {
  var labels = animation.labels,
      recent = animation._recent || _zeroPosition,
      clippedDuration = animation.duration() >= _bigNum ? recent.endTime(false) : animation._dur,
      //in case there's a child that infinitely repeats, users almost never intend for the insertion point of a new child to be based on a SUPER long value like that so we clip it and assume the most recently-added child's endTime should be used instead.
  //buildFrom = useBuildFrom ? animation._build : "auto",
  i,
      offset;

  if (_isString(position) && (isNaN(position) || position in labels)) {
    //if the string is a number like "1", check to see if there's a label with that name, otherwise interpret it as a number (absolute value).
    i = position.charAt(0);

    if (i === "<" || i === ">") {
      return (i === "<" ? recent._start : recent.endTime(recent._repeat >= 0)) + (parseFloat(position.substr(1)) || 0);
    }

    i = position.indexOf("=");

    if (i < 0) {
      if (!(position in labels)) {
        labels[position] = clippedDuration;
      }

      return labels[position];
    }

    offset = +(position.charAt(i - 1) + position.substr(i + 1));
    return i > 1 ? _parsePosition(animation, position.substr(0, i - 1)) + offset : clippedDuration + offset;
  }

  return position == null ? clippedDuration : +position; //return (position == null) ? (isNaN(buildFrom) ? clippedDuration : buildFrom) : (buildFrom === ">>" ? clippedDuration : +buildFrom || 0) + (+position);
},
    _conditionalReturn = function _conditionalReturn(value, func) {
  return value || value === 0 ? func(value) : func;
},
    _clamp = function _clamp(min, max, value) {
  return value < min ? min : value > max ? max : value;
},
    getUnit = function getUnit(value) {
  return (value + "").substr((parseFloat(value) + "").length);
},
    clamp = function clamp(min, max, value) {
  return _conditionalReturn(value, function (v) {
    return _clamp(min, max, v);
  });
},
    _slice = [].slice,
    _isArrayLike = function _isArrayLike(value) {
  return _isObject(value) && "length" in value && value.length - 1 in value && _isObject(value[0]) && value !== _win;
},
    _flatten = function _flatten(ar, leaveStrings, accumulator) {
  if (accumulator === void 0) {
    accumulator = [];
  }

  return ar.forEach(function (value) {
    var _accumulator;

    return _isString(value) && !leaveStrings || _isArrayLike(value) ? (_accumulator = accumulator).push.apply(_accumulator, toArray(value)) : accumulator.push(value);
  }) || accumulator;
},
    toArray = function toArray(value, leaveStrings) {
  //takes any value and returns an array. If it's a string (and leaveStrings isn't true), it'll use document.querySelectorAll() and convert that to an array. It'll also accept iterables like jQuery objects.
  return _isString(value) && !leaveStrings && (_coreInitted || !_wake()) ? _slice.call(_doc.querySelectorAll(value), 0) : _isArray(value) ? _flatten(value, leaveStrings) : _isArrayLike(value) ? _slice.call(value, 0) : value ? [value] : [];
},
    //for distributing values across an array. Can accept a number, a function or (most commonly) a function which can contain the following properties: {base, amount, from, ease, grid, axis, length, each}. Returns a function that expects the following parameters: index, target, array. Recognizes the following
distribute = function distribute(v) {
  if (_isFunction(v)) {
    return v;
  }

  var vars = _isObject(v) ? v : {
    each: v
  },
      //n:1 is just to indicate v was a number; we leverage that later to set v according to the length we get. If a number is passed in, we treat it like the old stagger value where 0.1, for example, would mean that things would be distributed with 0.1 between each element in the array rather than a total "amount" that's chunked out among them all.
  ease = _parseEase(vars.ease),
      from = vars.from || 0,
      base = parseFloat(vars.base) || 0,
      cache = {},
      isDecimal = from > 0 && from < 1,
      ratios = isNaN(from) || isDecimal,
      axis = vars.axis,
      ratioX = from,
      ratioY = from;

  if (_isString(from)) {
    ratioX = ratioY = {
      center: .5,
      edges: .5,
      end: 1
    }[from] || 0;
  } else if (!isDecimal && ratios) {
    ratioX = from[0];
    ratioY = from[1];
  }

  return function (i, target, a) {
    var l = (a || vars).length,
        distances = cache[l],
        originX,
        originY,
        x,
        y,
        d,
        j,
        max,
        min,
        wrapAt;

    if (!distances) {
      wrapAt = vars.grid === "auto" ? 0 : (vars.grid || [1, _bigNum])[1];

      if (!wrapAt) {
        max = -_bigNum;

        while (max < (max = a[wrapAt++].getBoundingClientRect().left) && wrapAt < l) {}

        wrapAt--;
      }

      distances = cache[l] = [];
      originX = ratios ? Math.min(wrapAt, l) * ratioX - .5 : from % wrapAt;
      originY = ratios ? l * ratioY / wrapAt - .5 : from / wrapAt | 0;
      max = 0;
      min = _bigNum;

      for (j = 0; j < l; j++) {
        x = j % wrapAt - originX;
        y = originY - (j / wrapAt | 0);
        distances[j] = d = !axis ? _sqrt(x * x + y * y) : Math.abs(axis === "y" ? y : x);

        if (d > max) {
          max = d;
        }

        if (d < min) {
          min = d;
        }
      }

      distances.max = max - min;
      distances.min = min;
      distances.v = l = (parseFloat(vars.amount) || parseFloat(vars.each) * (wrapAt > l ? l - 1 : !axis ? Math.max(wrapAt, l / wrapAt) : axis === "y" ? l / wrapAt : wrapAt) || 0) * (from === "edges" ? -1 : 1);
      distances.b = l < 0 ? base - l : base;
      distances.u = getUnit(vars.amount || vars.each) || 0; //unit

      ease = ease && l < 0 ? _invertEase(ease) : ease;
    }

    l = (distances[i] - distances.min) / distances.max || 0;
    return _round(distances.b + (ease ? ease(l) : l) * distances.v) + distances.u; //round in order to work around floating point errors
  };
},
    _roundModifier = function _roundModifier(v) {
  //pass in 0.1 get a function that'll round to the nearest tenth, or 5 to round to the closest 5, or 0.001 to the closest 1000th, etc.
  var p = v < 1 ? Math.pow(10, (v + "").length - 2) : 1; //to avoid floating point math errors (like 24 * 0.1 == 2.4000000000000004), we chop off at a specific number of decimal places (much faster than toFixed()

  return function (raw) {
    return ~~(Math.round(parseFloat(raw) / v) * v * p) / p + (_isNumber(raw) ? 0 : getUnit(raw));
  };
},
    snap = function snap(snapTo, value) {
  var isArray = _isArray(snapTo),
      radius,
      is2D;

  if (!isArray && _isObject(snapTo)) {
    radius = isArray = snapTo.radius || _bigNum;
    snapTo = toArray(snapTo.values);

    if (is2D = !_isNumber(snapTo[0])) {
      radius *= radius; //performance optimization so we don't have to Math.sqrt() in the loop.
    }
  }

  return _conditionalReturn(value, !isArray ? _roundModifier(snapTo) : function (raw) {
    var x = parseFloat(is2D ? raw.x : raw),
        y = parseFloat(is2D ? raw.y : 0),
        min = _bigNum,
        closest = 0,
        i = snapTo.length,
        dx,
        dy;

    while (i--) {
      if (is2D) {
        dx = snapTo[i].x - x;
        dy = snapTo[i].y - y;
        dx = dx * dx + dy * dy;
      } else {
        dx = Math.abs(snapTo[i] - x);
      }

      if (dx < min) {
        min = dx;
        closest = i;
      }
    }

    closest = !radius || min <= radius ? snapTo[closest] : raw;
    return is2D || closest === raw || _isNumber(raw) ? closest : closest + getUnit(raw);
  });
},
    random = function random(min, max, roundingIncrement, returnFunction) {
  return _conditionalReturn(_isArray(min) ? !max : !returnFunction, function () {
    return _isArray(min) ? min[~~(Math.random() * min.length)] : (roundingIncrement = roundingIncrement || 1e-5) && (returnFunction = roundingIncrement < 1 ? Math.pow(10, (roundingIncrement + "").length - 2) : 1) && ~~(Math.round((min + Math.random() * (max - min)) / roundingIncrement) * roundingIncrement * returnFunction) / returnFunction;
  });
},
    pipe = function pipe() {
  for (var _len = arguments.length, functions = new Array(_len), _key = 0; _key < _len; _key++) {
    functions[_key] = arguments[_key];
  }

  return function (value) {
    return functions.reduce(function (v, f) {
      return f(v);
    }, value);
  };
},
    unitize = function unitize(func, unit) {
  return function (value) {
    return func(parseFloat(value)) + (unit || getUnit(value));
  };
},
    normalize = function normalize(min, max, value) {
  return mapRange(min, max, 0, 1, value);
},
    _wrapArray = function _wrapArray(a, wrapper, value) {
  return _conditionalReturn(value, function (index) {
    return a[~~wrapper(index)];
  });
},
    wrap = function wrap(min, max, value) {
  // NOTE: wrap() CANNOT be an arrow function! A very odd compiling bug causes problems (unrelated to GSAP).
  var range = max - min;
  return _isArray(min) ? _wrapArray(min, wrap(0, min.length), max) : _conditionalReturn(value, function (value) {
    return (range + (value - min) % range) % range + min;
  });
},
    wrapYoyo = function wrapYoyo(min, max, value) {
  var range = max - min,
      total = range * 2;
  return _isArray(min) ? _wrapArray(min, wrapYoyo(0, min.length - 1), max) : _conditionalReturn(value, function (value) {
    value = (total + (value - min) % total) % total;
    return min + (value > range ? total - value : value);
  });
},
    _replaceRandom = function _replaceRandom(value) {
  //replaces all occurrences of random(...) in a string with the calculated random value. can be a range like random(-100, 100, 5) or an array like random([0, 100, 500])
  var prev = 0,
      s = "",
      i,
      nums,
      end,
      isArray;

  while (~(i = value.indexOf("random(", prev))) {
    end = value.indexOf(")", i);
    isArray = value.charAt(i + 7) === "[";
    nums = value.substr(i + 7, end - i - 7).match(isArray ? _delimitedValueExp : _strictNumExp);
    s += value.substr(prev, i - prev) + random(isArray ? nums : +nums[0], +nums[1], +nums[2] || 1e-5);
    prev = end + 1;
  }

  return s + value.substr(prev, value.length - prev);
},
    mapRange = function mapRange(inMin, inMax, outMin, outMax, value) {
  var inRange = inMax - inMin,
      outRange = outMax - outMin;
  return _conditionalReturn(value, function (value) {
    return outMin + (value - inMin) / inRange * outRange;
  });
},
    interpolate = function interpolate(start, end, progress, mutate) {
  var func = isNaN(start + end) ? 0 : function (p) {
    return (1 - p) * start + p * end;
  };

  if (!func) {
    var isString = _isString(start),
        master = {},
        p,
        i,
        interpolators,
        l,
        il;

    progress === true && (mutate = 1) && (progress = null);

    if (isString) {
      start = {
        p: start
      };
      end = {
        p: end
      };
    } else if (_isArray(start) && !_isArray(end)) {
      interpolators = [];
      l = start.length;
      il = l - 2;

      for (i = 1; i < l; i++) {
        interpolators.push(interpolate(start[i - 1], start[i])); //build the interpolators up front as a performance optimization so that when the function is called many times, it can just reuse them.
      }

      l--;

      func = function func(p) {
        p *= l;
        var i = Math.min(il, ~~p);
        return interpolators[i](p - i);
      };

      progress = end;
    } else if (!mutate) {
      start = _merge(_isArray(start) ? [] : {}, start);
    }

    if (!interpolators) {
      for (p in end) {
        _addPropTween.call(master, start, p, "get", end[p]);
      }

      func = function func(p) {
        return _renderPropTweens(p, master) || (isString ? start.p : start);
      };
    }
  }

  return _conditionalReturn(progress, func);
},
    _getLabelInDirection = function _getLabelInDirection(timeline, fromTime, backward) {
  //used for nextLabel() and previousLabel()
  var labels = timeline.labels,
      min = _bigNum,
      p,
      distance,
      label;

  for (p in labels) {
    distance = labels[p] - fromTime;

    if (distance < 0 === !!backward && distance && min > (distance = Math.abs(distance))) {
      label = p;
      min = distance;
    }
  }

  return label;
},
    _callback = function _callback(animation, type, executeLazyFirst) {
  var v = animation.vars,
      callback = v[type],
      params,
      scope;

  if (!callback) {
    return;
  }

  params = v[type + "Params"];
  scope = v.callbackScope || animation;

  if (executeLazyFirst && _lazyTweens.length) {
    //in case rendering caused any tweens to lazy-init, we should render them because typically when a timeline finishes, users expect things to have rendered fully. Imagine an onUpdate on a timeline that reports/checks tweened values.
    _lazyRender();
  }

  return params ? callback.apply(scope, params) : callback.call(scope, animation);
},
    _interrupt = function _interrupt(animation) {
  _removeFromParent(animation);

  if (animation.progress() < 1) {
    _callback(animation, "onInterrupt");
  }

  return animation;
},
    _quickTween,
    _createPlugin = function _createPlugin(config) {
  config = !config.name && config["default"] || config; //UMD packaging wraps things oddly, so for example MotionPathHelper becomes {MotionPathHelper:MotionPathHelper, default:MotionPathHelper}.

  var name = config.name,
      isFunc = _isFunction(config),
      Plugin = name && !isFunc && config.init ? function () {
    this._props = [];
  } : config,
      //in case someone passes in an object that's not a plugin, like CustomEase
  instanceDefaults = {
    init: _emptyFunc,
    render: _renderPropTweens,
    add: _addPropTween,
    kill: _killPropTweensOf,
    modifier: _addPluginModifier,
    rawVars: 0
  },
      statics = {
    targetTest: 0,
    get: 0,
    getSetter: _getSetter,
    aliases: {},
    register: 0
  };

  _wake();

  if (config !== Plugin) {
    if (_plugins[name]) {
      return;
    }

    _setDefaults(Plugin, _setDefaults(_copyExcluding(config, instanceDefaults), statics)); //static methods


    _merge(Plugin.prototype, _merge(instanceDefaults, _copyExcluding(config, statics))); //instance methods


    _plugins[Plugin.prop = name] = Plugin;

    if (config.targetTest) {
      _harnessPlugins.push(Plugin);

      _reservedProps[name] = 1;
    }

    name = (name === "css" ? "CSS" : name.charAt(0).toUpperCase() + name.substr(1)) + "Plugin"; //for the global name. "motionPath" should become MotionPathPlugin
  }

  _addGlobal(name, Plugin);

  if (config.register) {
    config.register(gsap, Plugin, PropTween);
  }
},

/*
 * --------------------------------------------------------------------------------------
 * COLORS
 * --------------------------------------------------------------------------------------
 */
_255 = 255,
    _colorLookup = {
  aqua: [0, _255, _255],
  lime: [0, _255, 0],
  silver: [192, 192, 192],
  black: [0, 0, 0],
  maroon: [128, 0, 0],
  teal: [0, 128, 128],
  blue: [0, 0, _255],
  navy: [0, 0, 128],
  white: [_255, _255, _255],
  olive: [128, 128, 0],
  yellow: [_255, _255, 0],
  orange: [_255, 165, 0],
  gray: [128, 128, 128],
  purple: [128, 0, 128],
  green: [0, 128, 0],
  red: [_255, 0, 0],
  pink: [_255, 192, 203],
  cyan: [0, _255, _255],
  transparent: [_255, _255, _255, 0]
},
    _hue = function _hue(h, m1, m2) {
  h = h < 0 ? h + 1 : h > 1 ? h - 1 : h;
  return (h * 6 < 1 ? m1 + (m2 - m1) * h * 6 : h < .5 ? m2 : h * 3 < 2 ? m1 + (m2 - m1) * (2 / 3 - h) * 6 : m1) * _255 + .5 | 0;
},
    splitColor = function splitColor(v, toHSL) {
  var a = !v ? _colorLookup.black : _isNumber(v) ? [v >> 16, v >> 8 & _255, v & _255] : 0,
      r,
      g,
      b,
      h,
      s,
      l,
      max,
      min,
      d,
      wasHSL;

  if (!a) {
    if (v.substr(-1) === ",") {
      //sometimes a trailing comma is included and we should chop it off (typically from a comma-delimited list of values like a textShadow:"2px 2px 2px blue, 5px 5px 5px rgb(255,0,0)" - in this example "blue," has a trailing comma. We could strip it out inside parseComplex() but we'd need to do it to the beginning and ending values plus it wouldn't provide protection from other potential scenarios like if the user passes in a similar value.
      v = v.substr(0, v.length - 1);
    }

    if (_colorLookup[v]) {
      a = _colorLookup[v];
    } else if (v.charAt(0) === "#") {
      if (v.length === 4) {
        //for shorthand like #9F0
        r = v.charAt(1);
        g = v.charAt(2);
        b = v.charAt(3);
        v = "#" + r + r + g + g + b + b;
      }

      v = parseInt(v.substr(1), 16);
      a = [v >> 16, v >> 8 & _255, v & _255];
    } else if (v.substr(0, 3) === "hsl") {
      a = wasHSL = v.match(_strictNumExp);

      if (!toHSL) {
        h = +a[0] % 360 / 360;
        s = +a[1] / 100;
        l = +a[2] / 100;
        g = l <= .5 ? l * (s + 1) : l + s - l * s;
        r = l * 2 - g;

        if (a.length > 3) {
          a[3] *= 1; //cast as number
        }

        a[0] = _hue(h + 1 / 3, r, g);
        a[1] = _hue(h, r, g);
        a[2] = _hue(h - 1 / 3, r, g);
      } else if (~v.indexOf("=")) {
        //if relative values are found, just return the raw strings with the relative prefixes in place.
        return v.match(_numExp);
      }
    } else {
      a = v.match(_strictNumExp) || _colorLookup.transparent;
    }

    a = a.map(Number);
  }

  if (toHSL && !wasHSL) {
    r = a[0] / _255;
    g = a[1] / _255;
    b = a[2] / _255;
    max = Math.max(r, g, b);
    min = Math.min(r, g, b);
    l = (max + min) / 2;

    if (max === min) {
      h = s = 0;
    } else {
      d = max - min;
      s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
      h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
      h *= 60;
    }

    a[0] = h + .5 | 0;
    a[1] = s * 100 + .5 | 0;
    a[2] = l * 100 + .5 | 0;
  }

  return a;
},
    _formatColors = function _formatColors(s, toHSL) {
  var colors = (s + "").match(_colorExp),
      charIndex = 0,
      parsed = "",
      i,
      color,
      temp;

  if (!colors) {
    return s;
  }

  for (i = 0; i < colors.length; i++) {
    color = colors[i];
    temp = s.substr(charIndex, s.indexOf(color, charIndex) - charIndex);
    charIndex += temp.length + color.length;
    color = splitColor(color, toHSL);

    if (color.length === 3) {
      color.push(1);
    }

    parsed += temp + (toHSL ? "hsla(" + color[0] + "," + color[1] + "%," + color[2] + "%," + color[3] : "rgba(" + color.join(",")) + ")";
  }

  return parsed + s.substr(charIndex);
},
    _colorExp = function () {
  var s = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3}){1,2}\\b",
      //we'll dynamically build this Regular Expression to conserve file size. After building it, it will be able to find rgb(), rgba(), # (hexadecimal), and named color values like red, blue, purple, etc.,
  p;

  for (p in _colorLookup) {
    s += "|" + p + "\\b";
  }

  return new RegExp(s + ")", "gi");
}(),
    _hslExp = /hsl[a]?\(/,
    _colorStringFilter = function _colorStringFilter(a) {
  var combined = a.join(" "),
      toHSL;
  _colorExp.lastIndex = 0;

  if (_colorExp.test(combined)) {
    toHSL = _hslExp.test(combined);
    a[0] = _formatColors(a[0], toHSL);
    a[1] = _formatColors(a[1], toHSL);
  }
},

/*
 * --------------------------------------------------------------------------------------
 * TICKER
 * --------------------------------------------------------------------------------------
 */
_tickerActive,
    _ticker = function () {
  var _getTime = Date.now,
      _lagThreshold = 500,
      _adjustedLag = 33,
      _startTime = _getTime(),
      _lastUpdate = _startTime,
      _gap = 1 / 60,
      _nextTime = _gap,
      _listeners = [],
      _id,
      _req,
      _raf,
      _self,
      _tick = function _tick(v) {
    var elapsed = _getTime() - _lastUpdate,
        manual = v === true,
        overlap,
        dispatch;

    if (elapsed > _lagThreshold) {
      _startTime += elapsed - _adjustedLag;
    }

    _lastUpdate += elapsed;
    _self.time = (_lastUpdate - _startTime) / 1000;
    overlap = _self.time - _nextTime;

    if (overlap > 0 || manual) {
      _self.frame++;
      _nextTime += overlap + (overlap >= _gap ? 0.004 : _gap - overlap);
      dispatch = 1;
    }

    if (!manual) {
      //make sure the request is made before we dispatch the "tick" event so that timing is maintained. Otherwise, if processing the "tick" requires a bunch of time (like 15ms) and we're using a setTimeout() that's based on 16.7ms, it'd technically take 31.7ms between frames otherwise.
      _id = _req(_tick);
    }

    if (dispatch) {
      _listeners.forEach(function (l) {
        return l(_self.time, elapsed, _self.frame, v);
      });
    }
  };

  _self = {
    time: 0,
    frame: 0,
    tick: function tick() {
      _tick(true);
    },
    wake: function wake() {
      if (_coreReady) {
        if (!_coreInitted && _windowExists()) {
          _win = _coreInitted = window;
          _doc = _win.document || {};
          _globals.gsap = gsap;
          (_win.gsapVersions || (_win.gsapVersions = [])).push(gsap.version);

          _install(_installScope || _win.GreenSockGlobals || !_win.gsap && _win || {});

          _raf = _win.requestAnimationFrame;
        }

        _id && _self.sleep();

        _req = _raf || function (f) {
          return setTimeout(f, (_nextTime - _self.time) * 1000 + 1 | 0);
        };

        _tickerActive = 1;

        _tick(2);
      }
    },
    sleep: function sleep() {
      (_raf ? _win.cancelAnimationFrame : clearTimeout)(_id);
      _tickerActive = 0;
      _req = _emptyFunc;
    },
    lagSmoothing: function lagSmoothing(threshold, adjustedLag) {
      _lagThreshold = threshold || 1 / _tinyNum; //zero should be interpreted as basically unlimited

      _adjustedLag = Math.min(adjustedLag, _lagThreshold, 0);
    },
    fps: function fps(_fps) {
      _gap = 1 / (_fps || 60);
      _nextTime = _self.time + _gap;
    },
    add: function add(callback) {
      _listeners.indexOf(callback) < 0 && _listeners.push(callback);

      _wake();
    },
    remove: function remove(callback) {
      var i;
      ~(i = _listeners.indexOf(callback)) && _listeners.splice(i, 1);
    },
    _listeners: _listeners
  };
  return _self;
}(),
    _wake = function _wake() {
  return !_tickerActive && _ticker.wake();
},
    //also ensures the core classes are initialized.

/*
* -------------------------------------------------
* EASING
* -------------------------------------------------
*/
_easeMap = {},
    _customEaseExp = /^[\d.\-M][\d.\-,\s]/,
    _quotesExp = /["']/g,
    _parseObjectInString = function _parseObjectInString(value) {
  //takes a string like "{wiggles:10, type:anticipate})" and turns it into a real object. Notice it ends in ")" and includes the {} wrappers. This is because we only use this function for parsing ease configs and prioritized optimization rather than reusability.
  var obj = {},
      split = value.substr(1, value.length - 3).split(":"),
      key = split[0],
      i = 1,
      l = split.length,
      index,
      val,
      parsedVal;

  for (; i < l; i++) {
    val = split[i];
    index = i !== l - 1 ? val.lastIndexOf(",") : val.length;
    parsedVal = val.substr(0, index);
    obj[key] = isNaN(parsedVal) ? parsedVal.replace(_quotesExp, "").trim() : +parsedVal;
    key = val.substr(index + 1).trim();
  }

  return obj;
},
    _configEaseFromString = function _configEaseFromString(name) {
  //name can be a string like "elastic.out(1,0.5)", and pass in _easeMap as obj and it'll parse it out and call the actual function like _easeMap.Elastic.easeOut.config(1,0.5). It will also parse custom ease strings as long as CustomEase is loaded and registered (internally as _easeMap._CE).
  var split = (name + "").split("("),
      ease = _easeMap[split[0]];
  return ease && split.length > 1 && ease.config ? ease.config.apply(null, ~name.indexOf("{") ? [_parseObjectInString(split[1])] : _parenthesesExp.exec(name)[1].split(",").map(_numericIfPossible)) : _easeMap._CE && _customEaseExp.test(name) ? _easeMap._CE("", name) : ease;
},
    _invertEase = function _invertEase(ease) {
  return function (p) {
    return 1 - ease(1 - p);
  };
},
    // potential future feature - allow yoyoEase to be set in children and have those affected when the parent/ancestor timeline yoyos. Not sure it's worth the kb.
// _propagateYoyoEase = (timeline, isYoyo) => {
// 	let child = timeline._first, ease;
// 	while (child) {
// 		if (child instanceof Timeline) {
// 			_propagateYoyoEase(child, isYoyo);
// 		} else if (child.vars.yoyoEase && (!child._yoyo || !child._repeat) && child._yoyo !== isYoyo) {
// 			if (child.timeline) {
// 				_propagateYoyoEase(child.timeline, isYoyo);
// 			} else {
// 				ease = child._ease;
// 				child._ease = child._yEase;
// 				child._yEase = ease;
// 				child._yoyo = isYoyo;
// 			}
// 		}
// 		child = child._next;
// 	}
// },
_parseEase = function _parseEase(ease, defaultEase) {
  return !ease ? defaultEase : (_isFunction(ease) ? ease : _easeMap[ease] || _configEaseFromString(ease)) || defaultEase;
},
    _insertEase = function _insertEase(names, easeIn, easeOut, easeInOut) {
  if (easeOut === void 0) {
    easeOut = function easeOut(p) {
      return 1 - easeIn(1 - p);
    };
  }

  if (easeInOut === void 0) {
    easeInOut = function easeInOut(p) {
      return p < .5 ? easeIn(p * 2) / 2 : 1 - easeIn((1 - p) * 2) / 2;
    };
  }

  var ease = {
    easeIn: easeIn,
    easeOut: easeOut,
    easeInOut: easeInOut
  },
      lowercaseName;

  _forEachName(names, function (name) {
    _easeMap[name] = _globals[name] = ease;
    _easeMap[lowercaseName = name.toLowerCase()] = easeOut;

    for (var p in ease) {
      _easeMap[lowercaseName + (p === "easeIn" ? ".in" : p === "easeOut" ? ".out" : ".inOut")] = _easeMap[name + "." + p] = ease[p];
    }
  });

  return ease;
},
    _easeInOutFromOut = function _easeInOutFromOut(easeOut) {
  return function (p) {
    return p < .5 ? (1 - easeOut(1 - p * 2)) / 2 : .5 + easeOut((p - .5) * 2) / 2;
  };
},
    _configElastic = function _configElastic(type, amplitude, period) {
  var p1 = amplitude >= 1 ? amplitude : 1,
      //note: if amplitude is < 1, we simply adjust the period for a more natural feel. Otherwise the math doesn't work right and the curve starts at 1.
  p2 = (period || (type ? .3 : .45)) / (amplitude < 1 ? amplitude : 1),
      p3 = p2 / _2PI * (Math.asin(1 / p1) || 0),
      easeOut = function easeOut(p) {
    return p === 1 ? 1 : p1 * Math.pow(2, -10 * p) * _sin((p - p3) * p2) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  p2 = _2PI / p2; //precalculate to optimize

  ease.config = function (amplitude, period) {
    return _configElastic(type, amplitude, period);
  };

  return ease;
},
    _configBack = function _configBack(type, overshoot) {
  if (overshoot === void 0) {
    overshoot = 1.70158;
  }

  var easeOut = function easeOut(p) {
    return --p * p * ((overshoot + 1) * p + overshoot) + 1;
  },
      ease = type === "out" ? easeOut : type === "in" ? function (p) {
    return 1 - easeOut(1 - p);
  } : _easeInOutFromOut(easeOut);

  ease.config = function (overshoot) {
    return _configBack(type, overshoot);
  };

  return ease;
}; // a cheaper (kb and cpu) but more mild way to get a parameterized weighted ease by feeding in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEase = ratio => {
// 	let y = 0.5 + ratio / 2;
// 	return p => (2 * (1 - p) * p * y + p * p);
// },
// a stronger (but more expensive kb/cpu) parameterized weighted ease that lets you feed in a value between -1 (easeIn) and 1 (easeOut) where 0 is linear.
// _weightedEaseStrong = ratio => {
// 	ratio = .5 + ratio / 2;
// 	let o = 1 / 3 * (ratio < .5 ? ratio : 1 - ratio),
// 		b = ratio - o,
// 		c = ratio + o;
// 	return p => p === 1 ? p : 3 * b * (1 - p) * (1 - p) * p + 3 * c * (1 - p) * p * p + p * p * p;
// };


_forEachName("Linear,Quad,Cubic,Quart,Quint,Strong", function (name, i) {
  var power = i < 5 ? i + 1 : i;

  _insertEase(name + ",Power" + (power - 1), i ? function (p) {
    return Math.pow(p, power);
  } : function (p) {
    return p;
  }, function (p) {
    return 1 - Math.pow(1 - p, power);
  }, function (p) {
    return p < .5 ? Math.pow(p * 2, power) / 2 : 1 - Math.pow((1 - p) * 2, power) / 2;
  });
});

_easeMap.Linear.easeNone = _easeMap.none = _easeMap.Linear.easeIn;

_insertEase("Elastic", _configElastic("in"), _configElastic("out"), _configElastic());

(function (n, c) {
  var n1 = 1 / c,
      n2 = 2 * n1,
      n3 = 2.5 * n1,
      easeOut = function easeOut(p) {
    return p < n1 ? n * p * p : p < n2 ? n * Math.pow(p - 1.5 / c, 2) + .75 : p < n3 ? n * (p -= 2.25 / c) * p + .9375 : n * Math.pow(p - 2.625 / c, 2) + .984375;
  };

  _insertEase("Bounce", function (p) {
    return 1 - easeOut(1 - p);
  }, easeOut);
})(7.5625, 2.75);

_insertEase("Expo", function (p) {
  return p ? Math.pow(2, 10 * (p - 1)) : 0;
});

_insertEase("Circ", function (p) {
  return -(_sqrt(1 - p * p) - 1);
});

_insertEase("Sine", function (p) {
  return -_cos(p * _HALF_PI) + 1;
});

_insertEase("Back", _configBack("in"), _configBack("out"), _configBack());

_easeMap.SteppedEase = _easeMap.steps = _globals.SteppedEase = {
  config: function config(steps, immediateStart) {
    if (steps === void 0) {
      steps = 1;
    }

    var p1 = 1 / steps,
        p2 = steps + (immediateStart ? 0 : 1),
        p3 = immediateStart ? 1 : 0,
        max = 1 - _tinyNum;
    return function (p) {
      return ((p2 * _clamp(0, max, p) | 0) + p3) * p1;
    };
  }
};
_defaults.ease = _easeMap["quad.out"];
/*
 * --------------------------------------------------------------------------------------
 * CACHE
 * --------------------------------------------------------------------------------------
 */

var GSCache = function GSCache(target, harness) {
  this.id = _gsID++;
  target._gsap = this;
  this.target = target;
  this.harness = harness;
  this.get = harness ? harness.get : _getProperty;
  this.set = harness ? harness.getSetter : _getSetter;
};
/*
 * --------------------------------------------------------------------------------------
 * ANIMATION
 * --------------------------------------------------------------------------------------
 */

var Animation =
/*#__PURE__*/
function () {
  function Animation(vars, time) {
    var parent = vars.parent || _globalTimeline;
    this.vars = vars;
    this._dur = this._tDur = +vars.duration || 0;
    this._delay = +vars.delay || 0;

    if (this._repeat = vars.repeat || 0) {
      this._rDelay = vars.repeatDelay || 0;
      this._yoyo = !!vars.yoyo || !!vars.yoyoEase;

      _onUpdateTotalDuration(this);
    }

    this._ts = 1;
    this.data = vars.data;

    if (!_tickerActive) {
      _ticker.wake();
    }

    if (parent) {
      _addToTimeline(parent, this, time || time === 0 ? time : parent._time);
    }

    if (vars.reversed) {
      this.reversed(true);
    }

    if (vars.paused) {
      this.paused(true);
    }
  }

  var _proto = Animation.prototype;

  _proto.delay = function delay(value) {
    if (value || value === 0) {
      this._delay = value;
      return this;
    }

    return this._delay;
  };

  _proto.duration = function duration(value) {
    var isSetter = arguments.length,
        repeat = this._repeat,
        repeatCycles = repeat > 0 ? repeat * ((isSetter ? value : this._dur) + this._rDelay) : 0;
    return isSetter ? this.totalDuration(repeat < 0 ? value : value + repeatCycles) : this.totalDuration() && this._dur;
  };

  _proto.totalDuration = function totalDuration(value) {
    if (!arguments.length) {
      return this._tDur;
    }

    var repeat = this._repeat,
        isInfinite = (value || this._rDelay) && repeat < 0;
    this._tDur = isInfinite ? 1e20 : value;
    this._dur = isInfinite ? value : (value - repeat * this._rDelay) / (repeat + 1);
    this._dirty = 0;

    _uncache(this.parent);

    return this;
  };

  _proto.totalTime = function totalTime(_totalTime, suppressEvents) {
    _wake();

    if (!arguments.length) {
      return this._tTime;
    }

    var parent = this.parent || this._dp,
        start;

    if (parent && parent.smoothChildTiming && this._ts) {
      start = this._start; // if (!parent._dp && parent._time === parent._dur) { // if a root timeline completes...and then a while later one of its children resumes, we must shoot the playhead forward to where it should be raw-wise, otherwise the child will jump to the end. Down side: this assumes it's using the _ticker.time as a reference.
      // 	parent._time = _ticker.time - parent._start;
      // }

      this._start = parent._time - (this._ts > 0 ? _totalTime / this._ts : ((this._dirty ? this.totalDuration() : this._tDur) - _totalTime) / -this._ts);
      this._end += this._start - start;

      if (!parent._dirty) {
        //for performance improvement. If the parent's cache is already dirty, it already took care of marking the ancestors as dirty too, so skip the function call here.
        _uncache(parent);
      } //in case any of the ancestor timelines had completed but should now be enabled, we should reset their totalTime() which will also ensure that they're lined up properly and enabled. Skip for animations that are on the root (wasteful). Example: a TimelineLite.exportRoot() is performed when there's a paused tween on the root, the export will not complete until that tween is unpaused, but imagine a child gets restarted later, after all [unpaused] tweens have completed. The start of that child would get pushed out, but one of the ancestors may have completed.


      while (parent.parent) {
        if (parent.parent._time !== parent._start + (parent._ts > 0 ? parent._tTime / parent._ts : (parent.totalDuration() - parent._tTime) / -parent._ts)) {
          parent.totalTime(parent._tTime, true);
        }

        parent = parent.parent;
      }

      if (!this.parent) {
        //if the animation doesn't have a parent, put it back into its last parent (recorded as _dp for exactly cases like this).
        _addToTimeline(this._dp, this, this._start - this._delay);
      }
    }

    if (this._tTime !== _totalTime || !this._dur) {
      _lazySafeRender(this, _totalTime, suppressEvents);
    }

    return this;
  };

  _proto.time = function time(value, suppressEvents) {
    return arguments.length ? this.totalTime(value + _elapsedCycleDuration(this), suppressEvents) : this._time;
  };

  _proto.totalProgress = function totalProgress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.totalDuration() * value, suppressEvents) : this._tTime / this.totalDuration();
  };

  _proto.progress = function progress(value, suppressEvents) {
    return arguments.length ? this.totalTime(this.duration() * value + _elapsedCycleDuration(this), suppressEvents) : this.duration() ? this._time / this._dur : this.ratio;
  };

  _proto.iteration = function iteration(value, suppressEvents) {
    var cycleDuration = this.duration() + this._rDelay;

    return arguments.length ? this.totalTime(this._time + (value - 1) * cycleDuration, suppressEvents) : this._repeat ? ~~(this._tTime / cycleDuration) + 1 : 1;
  };

  _proto.timeScale = function timeScale(value) {
    var prevTS = this._ts;

    if (!arguments.length) {
      return prevTS || this._pauseTS;
    }

    if (!prevTS) {
      this._pauseTS = value;
      return this;
    } //don't allow a zero _ts, otherwise we can't resume() properly. For example, gsap.fromTo(tween, {timeScale:0}, {timeScale:1}) wouldn't work because the timeScale:0 would of course pause, and we'd record _pauseTS as 0...and then when resuming we'd copy that back to _ts...which would still keep it paused.


    this._end = this._start + this._tDur / (this._ts = value || _tinyNum);
    return _recacheAncestors(this).totalTime(this._tTime, true);
  };

  _proto.paused = function paused(value) {
    var isPaused = !this._ts;

    if (!arguments.length) {
      return isPaused;
    }

    if (isPaused !== value) {
      if (value) {
        this._pauseTS = this._ts;
        this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()); // if the pause occurs during the delay phase, make sure that's factored in when resuming.

        this._ts = this._act = 0; //we use a timeScale of 0 to indicate a paused state, but we record the old "real" timeScale as _pauseTS so we can revert when unpaused.
      } else {
        this._ts = this._pauseTS;
        value = this._tTime || this._pTime; //only defer to _pTime (pauseTime) if tTime is zero. Remember, someone could pause() an animation, then scrub the playhead and resume().

        if (this.progress() === 1) {
          // edge case: animation.progress(1).pause().play() wouldn't render again because the playhead is already at the end, but the call to totalTime() below will add it back to its parent...and not remove it again (since removing only happens upon rendering at a new time). Offsetting the _tTime slightly is done simply to cause the final render in totalTime() that'll pop it off its timeline (if autoRemoveChildren is true, of course).
          this._tTime -= _tinyNum;
        }

        this.totalTime(value, true);
      }
    }

    return this;
  };

  _proto.startTime = function startTime(value) {
    if (arguments.length) {
      if (this.parent && this.parent._sort) {
        _addToTimeline(this.parent, this, value - this._delay);
      }

      return this;
    }

    return this._start;
  };

  _proto.endTime = function endTime(includeRepeats) {
    return this._start + (_isNotFalse(includeRepeats) ? this.totalDuration() : this.duration()) / Math.abs(this._ts);
  };

  _proto.rawTime = function rawTime(wrapRepeats) {
    var parent = this.parent || this._dp; // _dp = detatched parent

    return !parent ? this._tTime : wrapRepeats && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : !this._ts ? this._tTime : _parentToChildTotalTime(parent.rawTime(wrapRepeats), this);
  } // globalTime(rawTime) {
  // 	let animation = this,
  // 		time = arguments.length ? rawTime : animation.rawTime();
  // 	while (animation) {
  // 		time = animation._start + time / (animation._ts || 1);
  // 		animation = animation.parent;
  // 	}
  // 	return time;
  // }
  ;

  _proto.repeat = function repeat(value) {
    if (arguments.length) {
      this._repeat = value;
      return _onUpdateTotalDuration(this);
    }

    return this._repeat;
  };

  _proto.repeatDelay = function repeatDelay(value) {
    if (arguments.length) {
      this._rDelay = value;
      return _onUpdateTotalDuration(this);
    }

    return this._rDelay;
  };

  _proto.yoyo = function yoyo(value) {
    if (arguments.length) {
      this._yoyo = value;
      return this;
    }

    return this._yoyo;
  };

  _proto.seek = function seek(position, suppressEvents) {
    return this.totalTime(_parsePosition(this, position), _isNotFalse(suppressEvents));
  };

  _proto.restart = function restart(includeDelay, suppressEvents) {
    return this.play().totalTime(includeDelay ? -this._delay : 0, _isNotFalse(suppressEvents));
  };

  _proto.play = function play(from, suppressEvents) {
    if (from != null) {
      this.seek(from, suppressEvents);
    }

    return this.reversed(false).paused(false);
  };

  _proto.reverse = function reverse(from, suppressEvents) {
    if (from != null) {
      this.seek(from || this.totalDuration(), suppressEvents);
    }

    return this.reversed(true).paused(false);
  };

  _proto.pause = function pause(atTime, suppressEvents) {
    if (atTime != null) {
      this.seek(atTime, suppressEvents);
    }

    return this.paused(true);
  };

  _proto.resume = function resume() {
    return this.paused(false);
  };

  _proto.reversed = function reversed(value) {
    var ts = this._ts || this._pauseTS;

    if (arguments.length) {
      if (value !== this.reversed()) {
        this[this._ts ? "_ts" : "_pauseTS"] = Math.abs(ts) * (value ? -1 : 1);
        this.totalTime(this._tTime, true);
      }

      return this;
    }

    return ts < 0;
  };

  _proto.invalidate = function invalidate() {
    this._initted = 0;
    return this;
  };

  _proto.isActive = function isActive() {
    var parent = this.parent || this._dp,
        start = this._start,
        rawTime;
    return !parent || this._ts && this._initted && parent.isActive() && (rawTime = parent.rawTime(true)) >= start && rawTime < this.endTime(true) - _tinyNum;
  };

  _proto.eventCallback = function eventCallback(type, callback, params) {
    var vars = this.vars;

    if (arguments.length > 1) {
      if (!callback) {
        delete vars[type];
      } else {
        vars[type] = callback;

        if (params) {
          vars[type + "Params"] = params;
        }

        if (type === "onUpdate") {
          this._onUpdate = callback;
        }
      }

      return this;
    }

    return vars[type];
  };

  _proto.then = function then(onFulfilled) {
    var _this = this;

    if (onFulfilled === void 0) {
      onFulfilled = _emptyFunc;
    }

    return new Promise(function (resolve) {
      _this._prom = function () {
        onFulfilled(_this);
        resolve();
      };
    });
  };

  _proto.kill = function kill() {
    _interrupt(this);
  };

  return Animation;
}();

_setDefaults(Animation.prototype, {
  _time: 0,
  _start: 0,
  _end: 0,
  _tTime: 0,
  _tDur: 0,
  _dirty: 0,
  _repeat: 0,
  _yoyo: false,
  parent: 0,
  _rDelay: 0,
  _ts: 1,
  _dp: 0,
  ratio: 0,
  _zTime: -_tinyNum,
  _prom: 0
});
/*
 * -------------------------------------------------
 * TIMELINE
 * -------------------------------------------------
 */


var Timeline =
/*#__PURE__*/
function (_Animation) {
  _inheritsLoose(Timeline, _Animation);

  function Timeline(vars, time) {
    var _this2;

    if (vars === void 0) {
      vars = {};
    }

    _this2 = _Animation.call(this, vars, time) || this;
    _this2.labels = {};
    _this2.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);
    _this2.autoRemoveChildren = !!vars.autoRemoveChildren;
    _this2._sort = _isNotFalse(vars.sortChildren);
    return _this2;
  }

  var _proto2 = Timeline.prototype;

  _proto2.to = function to(targets, vars, position) {
    new Tween(targets, _parseVars(arguments, 0, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
    return this;
  };

  _proto2.from = function from(targets, vars, position) {
    new Tween(targets, _parseVars(arguments, 1, this), _parsePosition(this, _isNumber(vars) ? arguments[3] : position));
    return this;
  };

  _proto2.fromTo = function fromTo(targets, fromVars, toVars, position) {
    new Tween(targets, _parseVars(arguments, 2, this), _parsePosition(this, _isNumber(fromVars) ? arguments[4] : position));
    return this;
  };

  _proto2.set = function set(targets, vars, position) {
    vars.duration = 0;
    vars.parent = this;

    if (!vars.repeatDelay) {
      vars.repeat = 0;
    }

    vars.immediateRender = !!vars.immediateRender;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.call = function call(callback, params, position) {
    return _addToTimeline(this, Tween.delayedCall(0, callback, params), _parsePosition(this, position));
  } //ONLY for backward compatibility! Maybe delete?
  ;

  _proto2.staggerTo = function staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.duration = duration;
    vars.stagger = vars.stagger || stagger;
    vars.onComplete = onCompleteAll;
    vars.onCompleteParams = onCompleteAllParams;
    vars.parent = this;
    new Tween(targets, vars, _parsePosition(this, position));
    return this;
  };

  _proto2.staggerFrom = function staggerFrom(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams) {
    vars.runBackwards = 1;
    vars.immediateRender = _isNotFalse(vars.immediateRender);
    return this.staggerTo(targets, duration, vars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.staggerFromTo = function staggerFromTo(targets, duration, fromVars, toVars, stagger, position, onCompleteAll, onCompleteAllParams) {
    toVars.startAt = fromVars;
    toVars.immediateRender = _isNotFalse(toVars.immediateRender);
    return this.staggerTo(targets, duration, toVars, stagger, position, onCompleteAll, onCompleteAllParams);
  };

  _proto2.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._dirty ? this.totalDuration() : this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 && this !== _globalTimeline ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        crossingStart = this._zTime < 0 !== totalTime < 0 && this._initted,
        time,
        child,
        next,
        iteration,
        cycleDuration,
        prevPaused,
        pauseTween,
        timeScale,
        prevStart,
        prevIteration,
        yoyo,
        isYoyo;

    if (tTime !== this._tTime || force || crossingStart) {
      if (crossingStart) {
        if (!dur) {
          prevTime = this._zTime;
        }

        if (totalTime || !suppressEvents) {
          //when the playhead arrives at EXACTLY time 0 (right on top) of a zero-duration timeline, we need to discern if events are suppressed so that when the playhead moves again (next time), it'll trigger the callback. If events are NOT suppressed, obviously the callback would be triggered in this render. Basically, the callback should fire either when the playhead ARRIVES or LEAVES this exact spot, not both. Imagine doing a timeline.seek(0) and there's a callback that sits at 0. Since events are suppressed on that seek() by default, nothing will fire, but when the playhead moves off of that position, the callback should fire. This behavior is what people intuitively expect.
          this._zTime = totalTime;
        }
      }

      time = tTime;
      prevStart = this._start;
      timeScale = this._ts;
      prevPaused = timeScale === 0;

      if (prevTime !== this._time && dur) {
        //if totalDuration() finds a child with a negative startTime and smoothChildTiming is true, things get shifted around internally so we need to adjust the time accordingly. For example, if a tween starts at -30 we must shift EVERYTHING forward 30 seconds and move this timeline's startTime backward by 30 seconds so that things align with the playhead (no jump).
        time += this._time - prevTime;
      }

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        yoyo = this._yoyo;
        cycleDuration = dur + this._rDelay;
        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (time > dur || tDur === tTime) {
          time = dur;
        }

        iteration = ~~(tTime / cycleDuration);

        if (iteration && iteration === tTime / cycleDuration) {
          time = dur;
          iteration--;
        }

        prevIteration = ~~(this._tTime / cycleDuration);

        if (prevIteration && prevIteration === this._tTime / cycleDuration) {
          prevIteration--;
        }

        if (yoyo && iteration & 1) {
          time = dur - time;
          isYoyo = 1;
        }
        /*
        make sure children at the end/beginning of the timeline are rendered properly. If, for example,
        a 3-second long timeline rendered at 2.9 seconds previously, and now renders at 3.2 seconds (which
        would get translated to 2.8 seconds if the timeline yoyos or 0.2 seconds if it just repeats), there
        could be a callback or a short tween that's at 2.95 or 3 seconds in which wouldn't render. So
        we need to push the timeline to the end (and/or beginning depending on its yoyo value). Also we must
        ensure that zero-duration tweens at the very beginning or end of the Timeline work.
        */


        if (iteration !== prevIteration && !this._lock) {
          var rewinding = yoyo && prevIteration & 1,
              doesWrap = rewinding === (yoyo && iteration & 1);

          if (iteration < prevIteration) {
            rewinding = !rewinding;
          }

          prevTime = rewinding ? 0 : dur;
          this._lock = 1;
          this.render(prevTime, suppressEvents, !dur)._lock = 0;

          if (!suppressEvents && this.parent) {
            _callback(this, "onRepeat");
          }

          if (prevTime !== this._time || prevPaused !== !this._ts) {
            return this;
          }

          if (doesWrap) {
            this._lock = 2;
            prevTime = rewinding ? dur + 0.0001 : -0.0001;
            this.render(prevTime, true);
          }

          this._lock = 0;

          if (!this._ts && !prevPaused) {
            return this;
          } //in order for yoyoEase to work properly when there's a stagger, we must swap out the ease in each sub-tween.
          //_propagateYoyoEase(this, isYoyo);

        }
      }

      if (this._hasPause && !this._forcing && this._lock < 2) {
        pauseTween = _findNextPauseTween(this, _round(prevTime), _round(time));

        if (pauseTween) {
          tTime -= time - (time = pauseTween._start);
        }
      }

      this._tTime = tTime;
      this._time = time;
      this._act = !timeScale; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

      if (!this._initted) {
        this._onUpdate = this.vars.onUpdate;
        this._initted = 1;
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");
      }

      if (time >= prevTime && totalTime >= 0) {
        child = this._first;

        while (child) {
          next = child._next;

          if ((child._act || time >= child._start) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (time - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (time - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              break;
            }
          }

          child = next;
        }
      } else {
        child = this._last;
        var adjustedTime = totalTime < 0 ? totalTime : time; //when the playhead goes backward beyond the start of this timeline, we must pass that information down to the child animations so that zero-duration tweens know whether to render their starting or ending values.

        while (child) {
          next = child._prev;

          if ((child._act || adjustedTime <= child._end) && child._ts && pauseTween !== child) {
            if (child.parent !== this) {
              // an extreme edge case - the child's render could do something like kill() the "next" one in the linked list, or reparent it. In that case we must re-initiate the whole render to be safe.
              return this.render(totalTime, suppressEvents, force);
            }

            child.render(child._ts > 0 ? (adjustedTime - child._start) * child._ts : (child._dirty ? child.totalDuration() : child._tDur) + (adjustedTime - child._start) * child._ts, suppressEvents, force);

            if (time !== this._time || !this._ts && !prevPaused) {
              //in case a tween pauses or seeks the timeline when rendering, like inside of an onUpdate/onComplete
              pauseTween = 0;
              break;
            }
          }

          child = next;
        }
      }

      if (pauseTween && !suppressEvents) {
        this.pause();
        pauseTween.render(time >= prevTime ? 0 : -_tinyNum)._zTime = time >= prevTime ? 1 : -1;

        if (this._ts) {
          //the callback resumed playback! So since we may have held back the playhead due to where the pause is positioned, go ahead and jump to where it's SUPPOSED to be (if no pause happened).
          this._start = prevStart; //if the pause was at an earlier time and the user resumed in the callback, it could reposition the timeline (changing its startTime), throwing things off slightly, so we make sure the _start doesn't shift.

          return this.render(totalTime, suppressEvents, force);
        }
      }

      if (this._onUpdate && !suppressEvents) {
        _callback(this, "onUpdate", true);
      }

      if (tTime === tDur || !tTime && this._ts < 0) if (prevStart === this._start || Math.abs(timeScale) !== Math.abs(this._ts)) if (!time || tDur >= this.totalDuration()) {
        (totalTime || !dur) && _removeFromParent(this, 1);

        if (!suppressEvents && !(totalTime < 0 && !prevTime)) {
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && tTime === tDur && this._prom();
        }
      }
    }

    return this;
  };

  _proto2.add = function add(child, position) {
    var _this3 = this;

    if (!_isNumber(position)) {
      position = _parsePosition(this, position);
    }

    if (!(child instanceof Animation)) {
      if (_isArray(child)) {
        child.forEach(function (obj) {
          return _this3.add(obj, position);
        });
        return _uncache(this);
      }

      if (_isString(child)) {
        return this.addLabel(child, position);
      }

      if (_isFunction(child)) {
        child = Tween.delayedCall(0, child);
      } else {
        return this;
      }
    }

    return this !== child ? _addToTimeline(this, child, position) : this; //don't allow a timeline to be added to itself as a child!
  } // buildFrom(position, absolute) {
  // 	this._build = (position === ">>" || position === "auto") ? position : (position === "<<") ? 0 : _parsePosition(this, position, !absolute);
  // 	return this;
  // }
  ;

  _proto2.getChildren = function getChildren(nested, tweens, timelines, ignoreBeforeTime) {
    if (nested === void 0) {
      nested = true;
    }

    if (tweens === void 0) {
      tweens = true;
    }

    if (timelines === void 0) {
      timelines = true;
    }

    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = -_bigNum;
    }

    var a = [],
        child = this._first;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        if (child instanceof Tween) {
          if (tweens) {
            a.push(child);
          }
        } else {
          if (timelines) {
            a.push(child);
          }

          if (nested) {
            a.push.apply(a, child.getChildren(true, tweens, timelines));
          }
        }
      }

      child = child._next;
    }

    return a;
  };

  _proto2.getById = function getById(id) {
    var animations = this.getChildren(1, 1, 1),
        i = animations.length;

    while (i--) {
      if (animations[i].vars.id === id) {
        return animations[i];
      }
    }
  };

  _proto2.remove = function remove(child) {
    if (_isString(child)) {
      return this.removeLabel(child);
    }

    if (_isFunction(child)) {
      return this.killTweensOf(child);
    }

    _removeLinkedListItem(this, child);

    if (child === this._recent) {
      this._recent = this._last;
    }

    return _uncache(this);
  };

  _proto2.totalTime = function totalTime(_totalTime2, suppressEvents) {
    if (!arguments.length) {
      return this._tTime;
    }

    this._forcing = 1;

    if (!this.parent && !this._dp && this._ts) {
      //special case for the global timeline (or any other that has no parent or detached parent).
      this._start = _ticker.time - (this._ts > 0 ? _totalTime2 / this._ts : (this.totalDuration() - _totalTime2) / -this._ts);
    }

    _Animation.prototype.totalTime.call(this, _totalTime2, suppressEvents);

    this._forcing = 0;
    return this;
  };

  _proto2.addLabel = function addLabel(label, position) {
    this.labels[label] = _parsePosition(this, position);
    return this;
  };

  _proto2.removeLabel = function removeLabel(label) {
    delete this.labels[label];
    return this;
  };

  _proto2.addPause = function addPause(position, callback, params) {
    var t = Tween.delayedCall(0, callback || _emptyFunc, params);
    t.data = "isPause";
    this._hasPause = 1;
    return _addToTimeline(this, t, _parsePosition(this, position));
  };

  _proto2.removePause = function removePause(position) {
    var child = this._first;
    position = _parsePosition(this, position);

    while (child) {
      if (child._start === position && child.data === "isPause") {
        _removeFromParent(child);
      }

      child = child._next;
    }
  };

  _proto2.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    var tweens = this.getTweensOf(targets, onlyActive),
        i = tweens.length;

    while (i--) {
      tweens[i].kill(targets, props);
    }

    return this;
  };

  _proto2.getTweensOf = function getTweensOf(targets, onlyActive) {
    var a = [],
        parsedTargets = toArray(targets),
        child = this._first,
        children;

    while (child) {
      if (child instanceof Tween) {
        if (_arrayContainsAny(child._targets, parsedTargets) && (!onlyActive || child.isActive())) {
          a.push(child);
        }
      } else if ((children = child.getTweensOf(parsedTargets, onlyActive)).length) {
        a.push.apply(a, children);
      }

      child = child._next;
    }

    return a;
  };

  _proto2.tweenTo = function tweenTo(position, vars) {
    var tl = this,
        endTime = _parsePosition(tl, position),
        startAt = vars && vars.startAt,
        tween = Tween.to(tl, _setDefaults({
      ease: "none",
      lazy: false,
      time: endTime,
      duration: Math.abs(endTime - (startAt && "time" in startAt ? startAt.time : tl._time)) / tl.timeScale() || _tinyNum,
      onStart: function onStart() {
        tl.pause();
        var duration = Math.abs(endTime - tl._time) / tl.timeScale();

        if (tween._dur !== duration) {
          tween._dur = duration;
          tween.render(tween._time, true, true);
        }

        if (vars && vars.onStart) {
          //in case the user had an onStart in the vars - we don't want to overwrite it.
          vars.onStart.apply(tween, vars.onStartParams || []);
        }
      }
    }, vars));

    return tween;
  };

  _proto2.tweenFromTo = function tweenFromTo(fromPosition, toPosition, vars) {
    return this.tweenTo(toPosition, _setDefaults({
      startAt: {
        time: _parsePosition(this, fromPosition)
      }
    }, vars));
  };

  _proto2.recent = function recent() {
    return this._recent;
  };

  _proto2.nextLabel = function nextLabel(afterTime) {
    if (afterTime === void 0) {
      afterTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, afterTime));
  };

  _proto2.previousLabel = function previousLabel(beforeTime) {
    if (beforeTime === void 0) {
      beforeTime = this._time;
    }

    return _getLabelInDirection(this, _parsePosition(this, beforeTime), 1);
  };

  _proto2.currentLabel = function currentLabel(value) {
    return arguments.length ? this.seek(value, true) : this.previousLabel(this._time + _tinyNum);
  };

  _proto2.shiftChildren = function shiftChildren(amount, adjustLabels, ignoreBeforeTime) {
    if (ignoreBeforeTime === void 0) {
      ignoreBeforeTime = 0;
    }

    var child = this._first,
        labels = this.labels,
        p;

    while (child) {
      if (child._start >= ignoreBeforeTime) {
        child._start += amount;
      }

      child = child._next;
    }

    if (adjustLabels) {
      for (p in labels) {
        if (labels[p] >= ignoreBeforeTime) {
          labels[p] += amount;
        }
      }
    }

    return _uncache(this);
  };

  _proto2.invalidate = function invalidate() {
    var child = this._first;
    this._lock = 0;

    while (child) {
      child.invalidate();
      child = child._next;
    }

    return _Animation.prototype.invalidate.call(this);
  };

  _proto2.clear = function clear(includeLabels) {
    if (includeLabels === void 0) {
      includeLabels = true;
    }

    var child = this._first,
        next;

    while (child) {
      next = child._next;
      this.remove(child);
      child = next;
    }

    this._time = this._tTime = 0;

    if (includeLabels) {
      this.labels = {};
    }

    return _uncache(this);
  };

  _proto2.totalDuration = function totalDuration(value) {
    var max = 0,
        self = this,
        child = self._last,
        prevStart = _bigNum,
        repeat = self._repeat,
        repeatCycles = repeat * self._rDelay || 0,
        isInfinite = repeat < 0,
        prev,
        end;

    if (!arguments.length) {
      if (self._dirty) {
        while (child) {
          prev = child._prev; //record it here in case the tween changes position in the sequence...

          if (child._dirty) {
            child.totalDuration(); //could change the tween._startTime, so make sure the animation's cache is clean before analyzing it.
          }

          if (child._start > prevStart && self._sort && child._ts && !self._lock) {
            //in case one of the tweens shifted out of order, it needs to be re-inserted into the correct position in the sequence
            self._lock = 1; //prevent endless recursive calls - there are methods that get triggered that check duration/totalDuration when we add().

            _addToTimeline(self, child, child._start - child._delay);

            self._lock = 0;
          } else {
            prevStart = child._start;
          }

          if (child._start < 0 && child._ts) {
            //children aren't allowed to have negative startTimes unless smoothChildTiming is true, so adjust here if one is found.
            max -= child._start;

            if (!self.parent && !self._dp || self.parent && self.parent.smoothChildTiming) {
              self._start += child._start / self._ts;
              self._time -= child._start;
              self._tTime -= child._start;
            }

            self.shiftChildren(-child._start, false, -_bigNum);
            prevStart = 0;
          }

          end = child._end = child._start + child._tDur / Math.abs(child._ts || child._pauseTS);

          if (end > max && child._ts) {
            max = _round(end);
          }

          child = prev;
        }

        self._dur = self === _globalTimeline && self._time > max ? self._time : Math.min(_bigNum, max);
        self._tDur = isInfinite && (self._dur || repeatCycles) ? 1e20 : Math.min(_bigNum, max * (repeat + 1) + repeatCycles);
        self._end = self._start + (self._tDur / Math.abs(self._ts || self._pauseTS) || 0);
        self._dirty = 0;
      }

      return self._tDur;
    }

    return isInfinite ? self : self.timeScale(self.totalDuration() / value);
  };

  Timeline.updateRoot = function updateRoot(time) {
    if (_globalTimeline._ts) {
      _lazySafeRender(_globalTimeline, _parentToChildTotalTime(time, _globalTimeline));
    }

    if (_ticker.frame >= _nextGCFrame) {
      _nextGCFrame += _config.autoSleep || 120;
      var child = _globalTimeline._first;
      if (!child || !child._ts) if (_config.autoSleep && _ticker._listeners.length < 2) {
        while (child && !child._ts) {
          child = child._next;
        }

        if (!child) {
          _ticker.sleep();
        }
      }
    }
  };

  return Timeline;
}(Animation);

_setDefaults(Timeline.prototype, {
  _lock: 0,
  _hasPause: 0,
  _forcing: 0
});

var _addComplexStringPropTween = function _addComplexStringPropTween(target, prop, start, end, setter, stringFilter, funcParam) {
  //note: we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.
  var pt = new PropTween(this._pt, target, prop, 0, 1, _renderComplexString, null, setter),
      index = 0,
      matchIndex = 0,
      result,
      startNums,
      color,
      endNum,
      chunk,
      startNum,
      hasRandom,
      a;
  pt.b = start;
  pt.e = end;
  start += ""; //ensure values are strings

  end += "";

  if (hasRandom = ~end.indexOf("random(")) {
    end = _replaceRandom(end);
  }

  if (stringFilter) {
    a = [start, end];
    stringFilter(a, target, prop); //pass an array with the starting and ending values and let the filter do whatever it needs to the values.

    start = a[0];
    end = a[1];
  }

  startNums = start.match(_complexStringNumExp) || [];

  while (result = _complexStringNumExp.exec(end)) {
    endNum = result[0];
    chunk = end.substring(index, result.index);

    if (color) {
      color = (color + 1) % 5;
    } else if (chunk.substr(-5) === "rgba(") {
      color = 1;
    }

    if (endNum !== startNums[matchIndex++]) {
      startNum = parseFloat(startNums[matchIndex - 1]); //these nested PropTweens are handled in a special way - we'll never actually call a render or setter method on them. We'll just loop through them in the parent complex string PropTween's render method.

      pt._pt = {
        _next: pt._pt,
        p: chunk || matchIndex === 1 ? chunk : ",",
        //note: SVG spec allows omission of comma/space when a negative sign is wedged between two numbers, like 2.5-5.3 instead of 2.5,-5.3 but when tweening, the negative value may switch to positive, so we insert the comma just in case.
        s: startNum,
        c: endNum.charAt(1) === "=" ? parseFloat(endNum.substr(2)) * (endNum.charAt(0) === "-" ? -1 : 1) : parseFloat(endNum) - startNum,
        m: color && color < 4 ? Math.round : 0
      };
      index = _complexStringNumExp.lastIndex;
    }
  }

  pt.c = index < end.length ? end.substring(index, end.length) : ""; //we use the "c" of the PropTween to store the final part of the string (after the last number)

  pt.fp = funcParam;

  if (_relExp.test(end) || hasRandom) {
    pt.e = 0; //if the end string contains relative values or dynamic random(...) values, delete the end it so that on the final render we don't actually set it to the string with += or -= characters (forces it to use the calculated value).
  }

  this._pt = pt; //start the linked list with this new PropTween. Remember, we call _addComplexStringPropTween.call(tweenInstance...) to ensure that it's scoped properly. We may call it from within a plugin too, thus "this" would refer to the plugin.

  return pt;
},
    _addPropTween = function _addPropTween(target, prop, start, end, index, targets, modifier, stringFilter, funcParam) {
  if (_isFunction(end)) {
    end = end(index || 0, target, targets);
  }

  var currentValue = target[prop],
      parsedStart = start !== "get" ? start : !_isFunction(currentValue) ? currentValue : funcParam ? target[prop.indexOf("set") || !_isFunction(target["get" + prop.substr(3)]) ? prop : "get" + prop.substr(3)](funcParam) : target[prop](),
      setter = !_isFunction(currentValue) ? _setterPlain : funcParam ? _setterFuncWithParam : _setterFunc,
      pt;

  if (_isString(end)) {
    if (~end.indexOf("random(")) {
      end = _replaceRandom(end);
    }

    if (end.charAt(1) === "=") {
      end = parseFloat(parsedStart) + parseFloat(end.substr(2)) * (end.charAt(0) === "-" ? -1 : 1) + getUnit(parsedStart);
    }
  }

  if (parsedStart !== end) {
    if (!isNaN(parsedStart + end)) {
      pt = new PropTween(this._pt, target, prop, +parsedStart || 0, end - (parsedStart || 0), typeof currentValue === "boolean" ? _renderBoolean : _renderPlain, 0, setter);

      if (funcParam) {
        pt.fp = funcParam;
      }

      if (modifier) {
        pt.modifier(modifier, this, target);
      }

      return this._pt = pt;
    }

    !currentValue && !(prop in target) && _missingPlugin(prop, end);
    return _addComplexStringPropTween.call(this, target, prop, parsedStart, end, setter, stringFilter || _config.stringFilter, funcParam);
  }
},
    //creates a copy of the vars object and processes any function-based values (putting the resulting values directly into the copy) as well as strings with "random()" in them. It does NOT process relative values.
_processVars = function _processVars(vars, index, target, targets, tween) {
  if (_isFunction(vars)) {
    vars = _parseFuncOrString(vars, tween, index, target, targets);
  }

  if (!_isObject(vars) || vars.style && vars.nodeType || _isArray(vars)) {
    return _isString(vars) ? _parseFuncOrString(vars, tween, index, target, targets) : vars;
  }

  var copy = {},
      p;

  for (p in vars) {
    copy[p] = _parseFuncOrString(vars[p], tween, index, target, targets);
  }

  return copy;
},
    _checkPlugin = function _checkPlugin(property, vars, tween, index, target, targets) {
  var plugin, pt, ptLookup, i;

  if (_plugins[property] && (plugin = new _plugins[property]()).init(target, plugin.rawVars ? vars[property] : _processVars(vars[property], index, target, targets, tween), tween, index, targets) !== false) {
    tween._pt = pt = new PropTween(tween._pt, target, property, 0, 1, plugin.render, plugin, 0, plugin.priority);

    if (tween !== _quickTween) {
      ptLookup = tween._ptLookup[tween._targets.indexOf(target)]; //note: we can't use tween._ptLookup[index] because for staggered tweens, the index from the fullTargets array won't match what it is in each individual tween that spawns from the stagger.

      i = plugin._props.length;

      while (i--) {
        ptLookup[plugin._props[i]] = pt;
      }
    }
  }

  return plugin;
},
    _overwritingTween,
    //store a reference temporarily so we can avoid overwriting itself.
_initTween = function _initTween(tween, time) {
  var vars = tween.vars,
      ease = vars.ease,
      startAt = vars.startAt,
      immediateRender = vars.immediateRender,
      lazy = vars.lazy,
      onUpdate = vars.onUpdate,
      onUpdateParams = vars.onUpdateParams,
      callbackScope = vars.callbackScope,
      runBackwards = vars.runBackwards,
      yoyoEase = vars.yoyoEase,
      keyframes = vars.keyframes,
      autoRevert = vars.autoRevert,
      dur = tween._dur,
      prevStartAt = tween._startAt,
      targets = tween._targets,
      parent = tween.parent,
      fullTargets = parent && parent.data === "nested" ? parent.parent._targets : targets,
      autoOverwrite = tween._overwrite === "auto",
      tl = tween.timeline,
      cleanVars,
      i,
      p,
      pt,
      target,
      hasPriority,
      gsData,
      harness,
      plugin,
      ptLookup,
      index,
      harnessVars;

  if (tl && (!keyframes || !ease)) {
    ease = "none";
  }

  tween._ease = _parseEase(ease, _defaults.ease);
  tween._yEase = yoyoEase ? _invertEase(_parseEase(yoyoEase === true ? ease : yoyoEase, _defaults.ease)) : 0;

  if (yoyoEase && tween._yoyo && !tween._repeat) {
    //there must have been a parent timeline with yoyo:true that is currently in its yoyo phase, so flip the eases.
    yoyoEase = tween._yEase;
    tween._yEase = tween._ease;
    tween._ease = yoyoEase;
  }

  if (!tl) {
    //if there's an internal timeline, skip all the parsing because we passed that task down the chain.
    if (prevStartAt) {
      prevStartAt.render(-1, true).kill();
    }

    if (startAt) {
      _removeFromParent(tween._startAt = Tween.set(targets, _setDefaults({
        data: "isStart",
        overwrite: false,
        parent: parent,
        immediateRender: true,
        lazy: _isNotFalse(lazy),
        startAt: null,
        delay: 0,
        onUpdate: onUpdate,
        onUpdateParams: onUpdateParams,
        callbackScope: callbackScope,
        stagger: 0
      }, startAt))); //copy the properties/values into a new object to avoid collisions, like var to = {x:0}, from = {x:500}; timeline.fromTo(e, from, to).fromTo(e, to, from);


      if (immediateRender) {
        if (time > 0) {
          !autoRevert && (tween._startAt = 0); //tweens that render immediately (like most from() and fromTo() tweens) shouldn't revert when their parent timeline's playhead goes backward past the startTime because the initial render could have happened anytime and it shouldn't be directly correlated to this tween's startTime. Imagine setting up a complex animation where the beginning states of various objects are rendered immediately but the tween doesn't happen for quite some time - if we revert to the starting values as soon as the playhead goes backward past the tween's startTime, it will throw things off visually. Reversion should only happen in Timeline instances where immediateRender was false or when autoRevert is explicitly set to true.
        } else if (dur) {
          return; //we skip initialization here so that overwriting doesn't occur until the tween actually begins. Otherwise, if you create several immediateRender:true tweens of the same target/properties to drop into a Timeline, the last one created would overwrite the first ones because they didn't get placed into the timeline yet before the first render occurs and kicks in overwriting.
        }
      }
    } else if (runBackwards && dur) {
      //from() tweens must be handled uniquely: their beginning values must be rendered but we don't want overwriting to occur yet (when time is still 0). Wait until the tween actually begins before doing all the routines like overwriting. At that time, we should render at the END of the tween to ensure that things initialize correctly (remember, from() tweens go backwards)
      if (prevStartAt) {
        !autoRevert && (tween._startAt = 0);
      } else {
        if (time) {
          //in rare cases (like if a from() tween runs and then is invalidate()-ed), immediateRender could be true but the initial forced-render gets skipped, so there's no need to force the render in this context when the _time is greater than 0
          immediateRender = false;
        }

        _removeFromParent(tween._startAt = Tween.set(targets, _merge(_copyExcluding(vars, _reservedProps), {
          overwrite: false,
          data: "isFromStart",
          //we tag the tween with as "isFromStart" so that if [inside a plugin] we need to only do something at the very END of a tween, we have a way of identifying this tween as merely the one that's setting the beginning values for a "from()" tween. For example, clearProps in CSSPlugin should only get applied at the very END of a tween and without this tag, from(...{height:100, clearProps:"height", delay:1}) would wipe the height at the beginning of the tween and after 1 second, it'd kick back in.
          lazy: immediateRender && _isNotFalse(lazy),
          immediateRender: immediateRender,
          //zero-duration tweens render immediately by default, but if we're not specifically instructed to render this tween immediately, we should skip this and merely _init() to record the starting values (rendering them immediately would push them to completion which is wasteful in that case - we'd have to render(-1) immediately after)
          stagger: 0,
          parent: parent //ensures that nested tweens that had a stagger are handled properly, like gsap.from(".class", {y:gsap.utils.cycle([-100,100])})

        })));

        if (!immediateRender) {
          _initTween(tween._startAt, time); //ensures that the initial values are recorded


          if (immediateRender) {
            !autoRevert && (tween._startAt = 0);
          }
        } else if (!time) {
          return;
        }
      }
    }

    cleanVars = _copyExcluding(vars, _reservedProps);
    tween._pt = 0;
    harness = targets[0] ? _getCache(targets[0]).harness : 0;
    harnessVars = harness && vars[harness.prop]; //someone may need to specify CSS-specific values AND non-CSS values, like if the element has an "x" property plus it's a standard DOM element. We allow people to distinguish by wrapping plugin-specific stuff in a css:{} object for example.

    for (i = 0; i < targets.length; i++) {
      target = targets[i];
      gsData = target._gsap || _harness(targets)[i]._gsap;
      tween._ptLookup[i] = ptLookup = {};

      if (_lazyLookup[gsData.id]) {
        _lazyRender(); //if other tweens of the same target have recently initted but haven't rendered yet, we've got to force the render so that the starting values are correct (imagine populating a timeline with a bunch of sequential tweens and then jumping to the end)

      }

      index = fullTargets === targets ? i : fullTargets.indexOf(target);

      if (harness && (plugin = new harness()).init(target, harnessVars || cleanVars, tween, index, fullTargets) !== false) {
        tween._pt = pt = new PropTween(tween._pt, target, plugin.name, 0, 1, plugin.render, plugin, 0, plugin.priority);

        plugin._props.forEach(function (name) {
          ptLookup[name] = pt;
        });

        if (plugin.priority) {
          hasPriority = 1;
        }
      }

      if (!harness || harnessVars) {
        for (p in cleanVars) {
          if (_plugins[p] && (plugin = _checkPlugin(p, cleanVars, tween, index, target, fullTargets))) {
            if (plugin.priority) {
              hasPriority = 1;
            }
          } else {
            ptLookup[p] = pt = _addPropTween.call(tween, target, p, "get", cleanVars[p], index, fullTargets, 0, vars.stringFilter);
          }
        }
      }

      if (tween._op && tween._op[i]) {
        tween.kill(target, tween._op[i]);
      }

      if (autoOverwrite) {
        _overwritingTween = tween;

        _globalTimeline.killTweensOf(target, ptLookup, true); //Also make sure the overwriting doesn't overwrite THIS tween!!!


        _overwritingTween = 0;
      }

      if (tween._pt && (_isNotFalse(lazy) && dur || lazy && !dur)) {
        _lazyLookup[gsData.id] = 1;
      }
    }

    if (hasPriority) {
      _sortPropTweensByPriority(tween);
    }

    if (tween._onInit) {
      //plugins like RoundProps must wait until ALL of the PropTweens are instantiated. In the plugin's init() function, it sets the _onInit on the tween instance. May not be pretty/intuitive, but it's fast and keeps file size down.
      tween._onInit(tween);
    }
  }

  tween._from = !tl && !!vars.runBackwards; //nested timelines should never run backwards - the backwards-ness is in the child tweens.

  tween._onUpdate = onUpdate;
  tween._initted = 1;
},
    _addAliasesToVars = function _addAliasesToVars(targets, vars) {
  var harness = targets[0] ? _getCache(targets[0]).harness : 0,
      propertyAliases = harness && harness.aliases,
      copy,
      p,
      i,
      aliases;

  if (!propertyAliases) {
    return vars;
  }

  copy = _merge({}, vars);

  for (p in propertyAliases) {
    if (p in copy) {
      aliases = propertyAliases[p].split(",");
      i = aliases.length;

      while (i--) {
        copy[aliases[i]] = copy[p];
      }
    }
  }

  return copy;
},
    _parseFuncOrString = function _parseFuncOrString(value, tween, i, target, targets) {
  return _isFunction(value) ? value.call(tween, i, target, targets) : _isString(value) && ~value.indexOf("random(") ? _replaceRandom(value) : value;
},
    _staggerTweenProps = _callbackNames + ",repeat,repeatDelay,yoyo,yoyoEase",
    _staggerPropsToSkip = (_staggerTweenProps + ",id,stagger,delay,duration").split(",");
/*
 * --------------------------------------------------------------------------------------
 * TWEEN
 * --------------------------------------------------------------------------------------
 */


var Tween =
/*#__PURE__*/
function (_Animation2) {
  _inheritsLoose(Tween, _Animation2);

  function Tween(targets, vars, time) {
    var _this4;

    if (typeof vars === "number") {
      time.duration = vars;
      vars = time;
      time = null;
    }

    _this4 = _Animation2.call(this, _inheritDefaults(vars), time) || this;
    var _this4$vars = _this4.vars,
        duration = _this4$vars.duration,
        delay = _this4$vars.delay,
        immediateRender = _this4$vars.immediateRender,
        stagger = _this4$vars.stagger,
        overwrite = _this4$vars.overwrite,
        keyframes = _this4$vars.keyframes,
        defaults = _this4$vars.defaults,
        parsedTargets = toArray(targets),
        tl,
        i,
        copy,
        l,
        p,
        curTarget,
        staggerFunc,
        staggerVarsToMerge;
    _this4._targets = parsedTargets.length ? _harness(parsedTargets) : _warn("GSAP target " + targets + " not found. https://greensock.com", !_config.nullTargetWarn) || [{}];
    _this4._ptLookup = []; //PropTween lookup. An array containing an object for each target, having keys for each tweening property

    _this4._overwrite = overwrite;

    if (keyframes || stagger || _isFuncOrString(duration) || _isFuncOrString(delay)) {
      vars = _this4.vars;
      tl = _this4.timeline = new Timeline({
        data: "nested",
        defaults: defaults || {}
      });
      tl.kill();
      tl.parent = _assertThisInitialized(_this4);

      if (keyframes) {
        _setDefaults(tl.vars.defaults, {
          ease: "none"
        });

        keyframes.forEach(function (frame) {
          return tl.to(parsedTargets, frame, ">");
        });
      } else {
        l = parsedTargets.length;
        staggerFunc = stagger ? distribute(stagger) : _emptyFunc;

        if (_isObject(stagger)) {
          //users can pass in callbacks like onStart/onComplete in the stagger object. These should fire with each individual tween.
          for (p in stagger) {
            if (~_staggerTweenProps.indexOf(p)) {
              if (!staggerVarsToMerge) {
                staggerVarsToMerge = {};
              }

              staggerVarsToMerge[p] = stagger[p];
            }
          }
        }

        for (i = 0; i < l; i++) {
          copy = {};

          for (p in vars) {
            if (_staggerPropsToSkip.indexOf(p) < 0) {
              copy[p] = vars[p];
            }
          }

          copy.stagger = 0;

          if (staggerVarsToMerge) {
            _merge(copy, staggerVarsToMerge);
          }

          if (vars.yoyoEase && !vars.repeat) {
            //so that propagation works properly when a ancestor timeline yoyos
            copy.yoyoEase = vars.yoyoEase;
          }

          curTarget = parsedTargets[i]; //don't just copy duration or delay because if they're a string or function, we'd end up in an infinite loop because _isFuncOrString() would evaluate as true in the child tweens, entering this loop, etc. So we parse the value straight from vars and default to 0.

          copy.duration = +_parseFuncOrString(duration, _assertThisInitialized(_this4), i, curTarget, parsedTargets);
          copy.delay = (+_parseFuncOrString(delay, _assertThisInitialized(_this4), i, curTarget, parsedTargets) || 0) - _this4._delay;

          if (!stagger && l === 1 && copy.delay) {
            // if someone does delay:"random(1, 5)", repeat:-1, for example, the delay shouldn't be inside the repeat.
            _this4._delay = delay = copy.delay;
            _this4._start += delay;
            copy.delay = 0;
          }

          tl.to(curTarget, copy, staggerFunc(i, curTarget, parsedTargets));
        }

        duration = delay = 0;
      }

      duration || _this4.duration(duration = tl.duration());
    } else {
      _this4.timeline = 0; //speed optimization, faster lookups (no going up the prototype chain)
    }

    if (overwrite === true) {
      _overwritingTween = _assertThisInitialized(_this4);

      _globalTimeline.killTweensOf(parsedTargets);

      _overwritingTween = 0;
    }

    if (immediateRender || !duration && !keyframes && _this4._start === _this4.parent._time && _isNotFalse(immediateRender) && _hasNoPausedAncestors(_assertThisInitialized(_this4)) && _this4.parent.data !== "nested") {
      _this4._tTime = -_tinyNum; //forces a render without having to set the render() "force" parameter to true because we want to allow lazying by default (using the "force" parameter always forces an immediate full render)

      _this4.render(Math.max(0, -delay)); //in case delay is negative

    }

    return _this4;
  }

  var _proto3 = Tween.prototype;

  _proto3.render = function render(totalTime, suppressEvents, force) {
    var prevTime = this._time,
        tDur = this._tDur,
        dur = this._dur,
        tTime = totalTime > tDur - _tinyNum && totalTime >= 0 ? tDur : totalTime < _tinyNum ? 0 : totalTime,
        time,
        pt,
        iteration,
        cycleDuration,
        prevIteration,
        isYoyo,
        ratio,
        timeline,
        yoyoEase;

    if (!dur) {
      _renderZeroDurationTween(this, totalTime, suppressEvents, force);
    } else if (tTime !== this._tTime || force || this._startAt && this._zTime < 0 !== totalTime < 0) {
      //this senses if we're crossing over the start time, in which case we must record _zTime and force the render, but we do it in this lengthy conditional way for performance reasons (usually we can skip the calculations): this._initted && (this._zTime < 0) !== (totalTime < 0)
      time = tTime;
      timeline = this.timeline;

      if (this._repeat) {
        //adjust the time for repeats and yoyos
        cycleDuration = dur + this._rDelay;
        time = _round(tTime % cycleDuration); //round to avoid floating point errors. (4 % 0.8 should be 0 but some browsers report it as 0.79999999!)

        if (time > dur) {
          time = dur;
        }

        iteration = ~~(tTime / cycleDuration);

        if (iteration && iteration === tTime / cycleDuration) {
          time = dur;
          iteration--;
        }

        isYoyo = this._yoyo && iteration & 1;

        if (isYoyo) {
          yoyoEase = this._yEase;
          time = dur - time;
        }

        prevIteration = ~~(this._tTime / cycleDuration);

        if (prevIteration && prevIteration === this._tTime / cycleDuration) {
          prevIteration--;
        }

        if (time === prevTime && !force) {
          //could be during the repeatDelay part. No need to render and fire callbacks.
          return this;
        }

        if (iteration !== prevIteration) {
          //timeline && this._yEase && _propagateYoyoEase(timeline, isYoyo);
          //repeatRefresh functionality
          if (this.vars.repeatRefresh && !this._lock) {
            this._lock = 1;
            this.render(cycleDuration * iteration, true).invalidate()._lock = 0;
          }
        }
      }

      if (!this._initted && _attemptInitTween(this, time, force, suppressEvents)) {
        return this;
      }

      this._tTime = tTime;
      this._time = time;

      if (!this._act && this._ts) {
        this._act = 1; //as long as it's not paused, force it to be active so that if the user renders independent of the parent timeline, it'll be forced to re-render on the next tick.

        this._lazy = 0;
      }

      this.ratio = ratio = (yoyoEase || this._ease)(time / dur);

      if (this._from) {
        this.ratio = ratio = 1 - ratio;
      }

      if (!prevTime && time && !suppressEvents) {
        _callback(this, "onStart");
      }

      pt = this._pt;

      while (pt) {
        pt.r(ratio, pt.d);
        pt = pt._next;
      }

      timeline && timeline.render(totalTime < 0 ? totalTime : !time && isYoyo ? -_tinyNum : timeline._dur * ratio, suppressEvents, force) || this._startAt && (this._zTime = totalTime);

      if (this._onUpdate && !suppressEvents) {
        if (totalTime < 0 && this._startAt) {
          this._startAt.render(totalTime, true, force); //note: for performance reasons, we tuck this conditional logic inside less traveled areas (most tweens don't have an onUpdate). We'd just have it at the end before the onComplete, but the values should be updated before any onUpdate is called, so we ALSO put it here and then if it's not called, we do so later near the onComplete.

        }

        _callback(this, "onUpdate");
      }

      if (this._repeat) if (iteration !== prevIteration && this.vars.onRepeat && !suppressEvents && this.parent) {
        _callback(this, "onRepeat");
      }

      if ((tTime === tDur || !tTime) && this._tTime === tTime) {
        if (totalTime < 0 && this._startAt && !this._onUpdate) {
          this._startAt.render(totalTime, true, force);
        }

        (totalTime || !dur) && (tTime || this._ts < 0) && _removeFromParent(this, 1); // don't remove if we're rendering at exactly a time of 0, as there could be autoRevert values that should get set on the next tick (if the playhead goes backward beyond the startTime, negative totalTime).

        if (!suppressEvents && !(totalTime < 0 && !prevTime)) {
          _callback(this, tTime === tDur ? "onComplete" : "onReverseComplete", true);

          this._prom && tTime === tDur && this._prom();
        }
      }
    }

    return this;
  };

  _proto3.targets = function targets() {
    return this._targets;
  };

  _proto3.invalidate = function invalidate() {
    this._pt = this._op = this._startAt = this._onUpdate = this._act = this._lazy = 0;
    this._ptLookup = [];

    if (this.timeline) {
      this.timeline.invalidate();
    }

    return _Animation2.prototype.invalidate.call(this);
  };

  _proto3.kill = function kill(targets, vars) {
    if (vars === void 0) {
      vars = "all";
    }

    if (_overwritingTween === this) {
      return _overwritingTween;
    }

    if (!targets && (!vars || vars === "all")) {
      if (this.parent) {
        this._lazy = 0;
        return _interrupt(this);
      }
    }

    if (this.timeline) {
      this.timeline.killTweensOf(targets, vars);
      return this;
    }

    var parsedTargets = this._targets,
        killingTargets = targets ? toArray(targets) : parsedTargets,
        propTweenLookup = this._ptLookup,
        firstPT = this._pt,
        overwrittenProps,
        curLookup,
        curOverwriteProps,
        props,
        p,
        pt,
        i;

    if ((!vars || vars === "all") && _arraysMatch(parsedTargets, killingTargets)) {
      return _interrupt(this);
    }

    overwrittenProps = this._op = this._op || [];

    if (vars !== "all") {
      //so people can pass in a comma-delimited list of property names
      if (_isString(vars)) {
        p = {};

        _forEachName(vars, function (name) {
          return p[name] = 1;
        });

        vars = p;
      }

      vars = _addAliasesToVars(parsedTargets, vars);
    }

    i = parsedTargets.length;

    while (i--) {
      if (~killingTargets.indexOf(parsedTargets[i])) {
        curLookup = propTweenLookup[i];

        if (vars === "all") {
          overwrittenProps[i] = vars;
          props = curLookup;
          curOverwriteProps = {};
        } else {
          curOverwriteProps = overwrittenProps[i] = overwrittenProps[i] || {};
          props = vars;
        }

        for (p in props) {
          pt = curLookup && curLookup[p];

          if (pt) {
            if (!("kill" in pt.d) || pt.d.kill(p) === true) {
              _removeLinkedListItem(this, pt, "_pt");

              delete curLookup[p];
            }
          }

          if (curOverwriteProps !== "all") {
            curOverwriteProps[p] = 1;
          }
        }
      }
    }

    if (this._initted && !this._pt && firstPT) {
      //if all tweening properties are killed, kill the tween. Without this line, if there's a tween with multiple targets and then you killTweensOf() each target individually, the tween would technically still remain active and fire its onComplete even though there aren't any more properties tweening.
      _interrupt(this);
    }

    return this;
  };

  Tween.to = function to(targets, vars) {
    return new Tween(targets, vars, arguments[2]);
  };

  Tween.from = function from(targets, vars) {
    return new Tween(targets, _parseVars(arguments, 1));
  };

  Tween.delayedCall = function delayedCall(delay, callback, params, scope) {
    return new Tween(callback, 0, {
      immediateRender: false,
      lazy: false,
      overwrite: false,
      delay: delay,
      onComplete: callback,
      onReverseComplete: callback,
      onCompleteParams: params,
      onReverseCompleteParams: params,
      callbackScope: scope
    });
  };

  Tween.fromTo = function fromTo(targets, fromVars, toVars) {
    return new Tween(targets, _parseVars(arguments, 2));
  };

  Tween.set = function set(targets, vars) {
    vars.duration = 0;

    if (!vars.repeatDelay) {
      vars.repeat = 0;
    }

    return new Tween(targets, vars);
  };

  Tween.killTweensOf = function killTweensOf(targets, props, onlyActive) {
    return _globalTimeline.killTweensOf(targets, props, onlyActive);
  };

  return Tween;
}(Animation);

_setDefaults(Tween.prototype, {
  _targets: [],
  _initted: 0,
  _lazy: 0,
  _startAt: 0,
  _op: 0,
  _onInit: 0
}); //add the pertinent timeline methods to Tween instances so that users can chain conveniently and create a timeline automatically. (removed due to concerns that it'd ultimately add to more confusion especially for beginners)
// _forEachName("to,from,fromTo,set,call,add,addLabel,addPause", name => {
// 	Tween.prototype[name] = function() {
// 		let tl = new Timeline();
// 		return _addToTimeline(tl, this)[name].apply(tl, toArray(arguments));
// 	}
// });
//for backward compatibility. Leverage the timeline calls.


_forEachName("staggerTo,staggerFrom,staggerFromTo", function (name) {
  Tween[name] = function () {
    var tl = new Timeline(),
        params = toArray(arguments);
    params.splice(name === "staggerFromTo" ? 5 : 4, 0, 0);
    return tl[name].apply(tl, params);
  };
});
/*
 * --------------------------------------------------------------------------------------
 * PROPTWEEN
 * --------------------------------------------------------------------------------------
 */


var _setterPlain = function _setterPlain(target, property, value) {
  return target[property] = value;
},
    _setterFunc = function _setterFunc(target, property, value) {
  return target[property](value);
},
    _setterFuncWithParam = function _setterFuncWithParam(target, property, value, data) {
  return target[property](data.fp, value);
},
    _setterAttribute = function _setterAttribute(target, property, value) {
  return target.setAttribute(property, value);
},
    _getSetter = function _getSetter(target, property) {
  return _isFunction(target[property]) ? _setterFunc : _isUndefined(target[property]) && target.setAttribute ? _setterAttribute : _setterPlain;
},
    _renderPlain = function _renderPlain(ratio, data) {
  return data.set(data.t, data.p, ~~((data.s + data.c * ratio) * 10000) / 10000, data);
},
    _renderBoolean = function _renderBoolean(ratio, data) {
  return data.set(data.t, data.p, !!(data.s + data.c * ratio), data);
},
    _renderComplexString = function _renderComplexString(ratio, data) {
  var pt = data._pt,
      s = "";

  if (!ratio && data.b) {
    //b = beginning string
    s = data.b;
  } else if (ratio === 1 && data.e) {
    //e = ending string
    s = data.e;
  } else {
    while (pt) {
      s = pt.p + (pt.m ? pt.m(pt.s + pt.c * ratio) : ~~((pt.s + pt.c * ratio) * 10000) / 10000) + s; //we use the "p" property for the text inbetween (like a suffix). And in the context of a complex string, the modifier (m) is typically just Math.round(), like for RGB colors.

      pt = pt._next;
    }

    s += data.c; //we use the "c" of the PropTween to store the final chunk of non-numeric text.
  }

  data.set(data.t, data.p, s, data);
},
    _renderPropTweens = function _renderPropTweens(ratio, data) {
  var pt = data._pt;

  while (pt) {
    pt.r(ratio, pt.d);
    pt = pt._next;
  }
},
    _addPluginModifier = function _addPluginModifier(modifier, tween, target, property) {
  var pt = this._pt,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property) {
      pt.modifier(modifier, tween, target);
    }

    pt = next;
  }
},
    _killPropTweensOf = function _killPropTweensOf(property) {
  var pt = this._pt,
      hasNonDependentRemaining,
      next;

  while (pt) {
    next = pt._next;

    if (pt.p === property && !pt.op || pt.op === property) {
      _removeLinkedListItem(this, pt, "_pt");
    } else if (!pt.dep) {
      hasNonDependentRemaining = 1;
    }

    pt = next;
  }

  return !hasNonDependentRemaining;
},
    _setterWithModifier = function _setterWithModifier(target, property, value, data) {
  data.mSet(target, property, data.m.call(data.tween, value, data.mt), data);
},
    _sortPropTweensByPriority = function _sortPropTweensByPriority(parent) {
  var pt = parent._pt,
      next,
      pt2,
      first,
      last; //sorts the PropTween linked list in order of priority because some plugins need to do their work after ALL of the PropTweens were created (like RoundPropsPlugin and ModifiersPlugin)

  while (pt) {
    next = pt._next;
    pt2 = first;

    while (pt2 && pt2.pr > pt.pr) {
      pt2 = pt2._next;
    }

    if (pt._prev = pt2 ? pt2._prev : last) {
      pt._prev._next = pt;
    } else {
      first = pt;
    }

    if (pt._next = pt2) {
      pt2._prev = pt;
    } else {
      last = pt;
    }

    pt = next;
  }

  parent._pt = first;
}; //PropTween key: t = target, p = prop, r = renderer, d = data, s = start, c = change, op = overwriteProperty (ONLY populated when it's different than p), pr = priority, _next/_prev for the linked list siblings, set = setter, m = modifier, mSet = modifierSetter (the original setter, before a modifier was added)


var PropTween =
/*#__PURE__*/
function () {
  function PropTween(next, target, prop, start, change, renderer, data, setter, priority) {
    this.t = target;
    this.s = start;
    this.c = change;
    this.p = prop;
    this.r = renderer || _renderPlain;
    this.d = data || this;
    this.set = setter || _setterPlain;
    this.pr = priority || 0;
    this._next = next;

    if (next) {
      next._prev = this;
    }
  }

  var _proto4 = PropTween.prototype;

  _proto4.modifier = function modifier(func, tween, target) {
    this.mSet = this.mSet || this.set; //in case it was already set (a PropTween can only have one modifier)

    this.set = _setterWithModifier;
    this.m = func;
    this.mt = target; //modifier target

    this.tween = tween;
  };

  return PropTween;
}(); //Initialization tasks

_forEachName(_callbackNames + ",parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert", function (name) {
  _reservedProps[name] = 1;
  if (name.substr(0, 2) === "on") _reservedProps[name + "Params"] = 1;
});

_globals.TweenMax = _globals.TweenLite = Tween;
_globals.TimelineLite = _globals.TimelineMax = Timeline;
_globalTimeline = new Timeline({
  sortChildren: false,
  defaults: _defaults,
  autoRemoveChildren: true,
  id: "root"
});
_config.stringFilter = _colorStringFilter;
/*
 * --------------------------------------------------------------------------------------
 * GSAP
 * --------------------------------------------------------------------------------------
 */

var gsap = {
  registerPlugin: function registerPlugin() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    args.forEach(function (config) {
      return _createPlugin(config);
    });
  },
  timeline: function timeline(vars) {
    return new Timeline(vars);
  },
  getTweensOf: function getTweensOf(targets, onlyActive) {
    return _globalTimeline.getTweensOf(targets, onlyActive);
  },
  getProperty: function getProperty(target, property, unit, uncache) {
    if (_isString(target)) {
      //in case selector text or an array is passed in
      target = toArray(target)[0];
    }

    var getter = _getCache(target || {}).get,
        format = unit ? _passThrough : _numericIfPossible;

    if (unit === "native") {
      unit = "";
    }

    return !target ? target : !property ? function (property, unit, uncache) {
      return format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
    } : format((_plugins[property] && _plugins[property].get || getter)(target, property, unit, uncache));
  },
  quickSetter: function quickSetter(target, property, unit) {
    target = toArray(target);

    if (target.length > 1) {
      var setters = target.map(function (t) {
        return gsap.quickSetter(t, property, unit);
      }),
          l = setters.length;
      return function (value) {
        var i = l;

        while (i--) {
          setters[i](value);
        }
      };
    }

    target = target[0] || {};

    var Plugin = _plugins[property],
        cache = _getCache(target),
        setter = Plugin ? function (value) {
      var p = new Plugin();
      _quickTween._pt = 0;
      p.init(target, unit ? value + unit : value, _quickTween, 0, [target]);
      p.render(1, p);
      _quickTween._pt && _renderPropTweens(1, _quickTween);
    } : cache.set(target, property);

    return Plugin ? setter : function (value) {
      return setter(target, property, unit ? value + unit : value, cache, 1);
    };
  },
  isTweening: function isTweening(targets) {
    return _globalTimeline.getTweensOf(targets, true).length > 0;
  },
  defaults: function defaults(value) {
    if (value && value.ease) {
      value.ease = _parseEase(value.ease, _defaults.ease);
    }

    return _mergeDeep(_defaults, value || {});
  },
  config: function config(value) {
    return _mergeDeep(_config, value || {});
  },
  registerEffect: function registerEffect(_ref) {
    var name = _ref.name,
        effect = _ref.effect,
        plugins = _ref.plugins,
        defaults = _ref.defaults,
        extendTimeline = _ref.extendTimeline;
    (plugins || "").split(",").forEach(function (pluginName) {
      return pluginName && !_plugins[pluginName] && !_globals[pluginName] && _warn(name + " effect requires " + pluginName + " plugin.");
    });

    _effects[name] = function (targets, vars) {
      return effect(toArray(targets), _setDefaults(vars || {}, defaults));
    };

    if (extendTimeline) {
      Timeline.prototype[name] = function (targets, vars, position) {
        return this.add(_effects[name](targets, _isObject(vars) ? vars : (position = vars) && {}), position);
      };
    }
  },
  registerEase: function registerEase(name, ease) {
    _easeMap[name] = _parseEase(ease);
  },
  parseEase: function parseEase(ease, defaultEase) {
    return arguments.length ? _parseEase(ease, defaultEase) : _easeMap;
  },
  getById: function getById(id) {
    return _globalTimeline.getById(id);
  },
  exportRoot: function exportRoot(vars, includeDelayedCalls) {
    if (vars === void 0) {
      vars = {};
    }

    var tl = new Timeline(vars),
        child,
        next;
    tl.smoothChildTiming = _isNotFalse(vars.smoothChildTiming);

    _globalTimeline.remove(tl);

    tl._dp = 0; //otherwise it'll get re-activated when adding children and be re-introduced into _globalTimeline's linked list (then added to itself).

    tl._time = tl._tTime = _globalTimeline._time;
    child = _globalTimeline._first;

    while (child) {
      next = child._next;

      if (includeDelayedCalls || !(!child._dur && child instanceof Tween && child.vars.onComplete === child._targets[0])) {
        _addToTimeline(tl, child, child._start - child._delay);
      }

      child = next;
    }

    _addToTimeline(_globalTimeline, tl, 0);

    return tl;
  },
  utils: {
    wrap: wrap,
    wrapYoyo: wrapYoyo,
    distribute: distribute,
    random: random,
    snap: snap,
    normalize: normalize,
    getUnit: getUnit,
    clamp: clamp,
    splitColor: splitColor,
    toArray: toArray,
    mapRange: mapRange,
    pipe: pipe,
    unitize: unitize,
    interpolate: interpolate
  },
  install: _install,
  effects: _effects,
  ticker: _ticker,
  updateRoot: Timeline.updateRoot,
  plugins: _plugins,
  globalTimeline: _globalTimeline,
  core: {
    PropTween: PropTween,
    globals: _addGlobal,
    Tween: Tween,
    Timeline: Timeline,
    Animation: Animation,
    getCache: _getCache
  }
};

_forEachName("to,from,fromTo,delayedCall,set,killTweensOf", function (name) {
  return gsap[name] = Tween[name];
});

_ticker.add(Timeline.updateRoot);

_quickTween = gsap.to({}, {
  duration: 0
}); // ---- EXTRA PLUGINS --------------------------------------------------------

var _addModifiers = function _addModifiers(tween, modifiers) {
  var targets = tween._targets,
      p,
      i,
      pt;

  for (p in modifiers) {
    i = targets.length;

    while (i--) {
      pt = tween._ptLookup[i][p];

      if (pt) {
        if (pt.d.modifier) {
          pt.d.modifier(modifiers[p], tween, targets[i], p);
        }
      }
    }
  }
},
    _buildModifierPlugin = function _buildModifierPlugin(name, modifier) {
  return {
    name: name,
    rawVars: 1,
    //don't pre-process function-based values or "random()" strings.
    init: function init(target, vars, tween) {
      tween._onInit = function (tween) {
        var temp, p;

        if (_isString(vars)) {
          temp = {};

          _forEachName(vars, function (name) {
            return temp[name] = 1;
          }); //if the user passes in a comma-delimited list of property names to roundProps, like "x,y", we round to whole numbers.


          vars = temp;
        }

        if (modifier) {
          temp = {};

          for (p in vars) {
            temp[p] = modifier(vars[p]);
          }

          vars = temp;
        }

        _addModifiers(tween, vars);
      };
    }
  };
}; //register core plugins


gsap.registerPlugin({
  name: "attr",
  init: function init(target, vars, tween, index, targets) {
    for (var p in vars) {
      this.add(target, "setAttribute", (target.getAttribute(p) || 0) + "", vars[p], index, targets, 0, 0, p); //this.add(target, "setAttribute", (target.getAttribute((p in target.dataset ? (p = "data-" + p) : p)) || 0) + "", vars[p], index, targets, 0, 0, p);

      this._props.push(p);
    }
  }
}, {
  name: "endArray",
  init: function init(target, value) {
    var i = value.length;

    while (i--) {
      this.add(target, i, target[i], value[i]);
    }
  }
}, _buildModifierPlugin("roundProps", _roundModifier), _buildModifierPlugin("modifiers"), _buildModifierPlugin("snap", snap));
Tween.version = Timeline.version = gsap.version = "3.0.1";
_coreReady = 1;

if (_windowExists()) {
  _wake();
}

var Power0 = _easeMap.Power0,
    Power1 = _easeMap.Power1,
    Power2 = _easeMap.Power2,
    Power3 = _easeMap.Power3,
    Power4 = _easeMap.Power4,
    Linear = _easeMap.Linear,
    Quad = _easeMap.Quad,
    Cubic = _easeMap.Cubic,
    Quart = _easeMap.Quart,
    Quint = _easeMap.Quint,
    Strong = _easeMap.Strong,
    Elastic = _easeMap.Elastic,
    Back = _easeMap.Back,
    SteppedEase = _easeMap.SteppedEase,
    Bounce = _easeMap.Bounce,
    Sine = _easeMap.Sine,
    Expo = _easeMap.Expo,
    Circ = _easeMap.Circ;

 //export some internal methods/orojects for use in CSSPlugin so that we can externalize that file and allow custom builds that exclude it.



/***/ }),

/***/ "../node_modules/gsap/index.js":
/*!*************************************!*\
  !*** ../node_modules/gsap/index.js ***!
  \*************************************/
/*! exports provided: gsap, default, CSSPlugin, TweenMax, TweenLite, TimelineMax, TimelineLite, Power0, Power1, Power2, Power3, Power4, Linear, Quad, Cubic, Quart, Quint, Strong, Elastic, Back, SteppedEase, Bounce, Sine, Expo, Circ */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "gsap", function() { return gsapWithCSS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return gsapWithCSS; });
/* harmony import */ var _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./gsap-core.js */ "../node_modules/gsap/gsap-core.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenMax", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TweenMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TweenLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TweenLite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineMax", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineMax"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TimelineLite", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["TimelineLite"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power0", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power0"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power1", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power1"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power2", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power2"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power3", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power3"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Power4", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Power4"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Linear", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Linear"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quad", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Cubic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Cubic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quart", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quart"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Quint", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Quint"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Strong", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Strong"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Elastic", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Elastic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Back", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Back"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SteppedEase", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["SteppedEase"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Bounce", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Bounce"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Sine", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Sine"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Expo", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Expo"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Circ", function() { return _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["Circ"]; });

/* harmony import */ var _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./CSSPlugin.js */ "../node_modules/gsap/CSSPlugin.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CSSPlugin", function() { return _CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]; });



var gsapWithCSS = _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"].registerPlugin(_CSSPlugin_js__WEBPACK_IMPORTED_MODULE_1__["CSSPlugin"]) || _gsap_core_js__WEBPACK_IMPORTED_MODULE_0__["gsap"]; // to protect from tree shaking



/***/ }),

/***/ "../node_modules/ieee754/index.js":
/*!****************************************!*\
  !*** ../node_modules/ieee754/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "../node_modules/regenerator-runtime/runtime.js":
/*!******************************************************!*\
  !*** ../node_modules/regenerator-runtime/runtime.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var runtime = function (exports) {
  "use strict";

  var Op = Object.prototype;
  var hasOwn = Op.hasOwnProperty;
  var undefined; // More compressible than void 0.

  var $Symbol = typeof Symbol === "function" ? Symbol : {};
  var iteratorSymbol = $Symbol.iterator || "@@iterator";
  var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
  var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function wrap(innerFn, outerFn, self, tryLocsList) {
    // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
    var generator = Object.create(protoGenerator.prototype);
    var context = new Context(tryLocsList || []); // The ._invoke method unifies the implementations of the .next,
    // .throw, and .return methods.

    generator._invoke = makeInvokeMethod(innerFn, self, context);
    return generator;
  }

  exports.wrap = wrap; // Try/catch helper to minimize deoptimizations. Returns a completion
  // record like context.tryEntries[i].completion. This interface could
  // have been (and was previously) designed to take a closure to be
  // invoked without arguments, but in all the cases we care about we
  // already have an existing method we want to call, so there's no need
  // to create a new function object. We can even get away with assuming
  // the method takes exactly one argument, since that happens to be true
  // in every case, so we don't have to touch the arguments object. The
  // only additional allocation required is the completion record, which
  // has a stable shape and so hopefully should be cheap to allocate.

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  var GenStateSuspendedStart = "suspendedStart";
  var GenStateSuspendedYield = "suspendedYield";
  var GenStateExecuting = "executing";
  var GenStateCompleted = "completed"; // Returning this object from the innerFn has the same effect as
  // breaking out of the dispatch switch statement.

  var ContinueSentinel = {}; // Dummy constructor functions that we use as the .constructor and
  // .constructor.prototype properties for functions that return Generator
  // objects. For full spec compliance, you may wish to configure your
  // minifier not to mangle the names of these two functions.

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {} // This is a polyfill for %IteratorPrototype% for environments that
  // don't natively support it.


  var IteratorPrototype = {};

  IteratorPrototype[iteratorSymbol] = function () {
    return this;
  };

  var getProto = Object.getPrototypeOf;
  var NativeIteratorPrototype = getProto && getProto(getProto(values([])));

  if (NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
    // This environment has a native %IteratorPrototype%; use it instead
    // of the polyfill.
    IteratorPrototype = NativeIteratorPrototype;
  }

  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
  GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
  GeneratorFunctionPrototype.constructor = GeneratorFunction;
  GeneratorFunctionPrototype[toStringTagSymbol] = GeneratorFunction.displayName = "GeneratorFunction"; // Helper for defining the .next, .throw, and .return methods of the
  // Iterator interface in terms of a single ._invoke method.

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      prototype[method] = function (arg) {
        return this._invoke(method, arg);
      };
    });
  }

  exports.isGeneratorFunction = function (genFun) {
    var ctor = typeof genFun === "function" && genFun.constructor;
    return ctor ? ctor === GeneratorFunction || // For the native GeneratorFunction constructor, the best we can
    // do is to check its .name property.
    (ctor.displayName || ctor.name) === "GeneratorFunction" : false;
  };

  exports.mark = function (genFun) {
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
    } else {
      genFun.__proto__ = GeneratorFunctionPrototype;

      if (!(toStringTagSymbol in genFun)) {
        genFun[toStringTagSymbol] = "GeneratorFunction";
      }
    }

    genFun.prototype = Object.create(Gp);
    return genFun;
  }; // Within the body of any async function, `await x` is transformed to
  // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
  // `hasOwn.call(value, "__await")` to determine if the yielded value is
  // meant to be awaited.


  exports.awrap = function (arg) {
    return {
      __await: arg
    };
  };

  function AsyncIterator(generator) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if (record.type === "throw") {
        reject(record.arg);
      } else {
        var result = record.arg;
        var value = result.value;

        if (value && _typeof(value) === "object" && hasOwn.call(value, "__await")) {
          return Promise.resolve(value.__await).then(function (value) {
            invoke("next", value, resolve, reject);
          }, function (err) {
            invoke("throw", err, resolve, reject);
          });
        }

        return Promise.resolve(value).then(function (unwrapped) {
          // When a yielded Promise is resolved, its final value becomes
          // the .value of the Promise<{value,done}> result for the
          // current iteration.
          result.value = unwrapped;
          resolve(result);
        }, function (error) {
          // If a rejected Promise was yielded, throw the rejection back
          // into the async generator function so it can be handled there.
          return invoke("throw", error, resolve, reject);
        });
      }
    }

    var previousPromise;

    function enqueue(method, arg) {
      function callInvokeWithMethodAndArg() {
        return new Promise(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = // If enqueue has been called before, then we want to wait until
      // all previous Promises have been resolved before calling invoke,
      // so that results are always delivered in the correct order. If
      // enqueue has not been called before, then it is important to
      // call invoke immediately, without waiting on a callback to fire,
      // so that the async generator function has the opportunity to do
      // any necessary setup in a predictable way. This predictability
      // is why the Promise constructor synchronously invokes its
      // executor callback, and why async functions synchronously
      // execute code before the first await. Since we implement simple
      // async functions in terms of async generators, it is especially
      // important to get this right, even though it requires care.
      previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, // Avoid propagating failures to Promises returned by later
      // invocations of the iterator.
      callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    } // Define the unified helper method that is used to implement .next,
    // .throw, and .return (see defineIteratorMethods).


    this._invoke = enqueue;
  }

  defineIteratorMethods(AsyncIterator.prototype);

  AsyncIterator.prototype[asyncIteratorSymbol] = function () {
    return this;
  };

  exports.AsyncIterator = AsyncIterator; // Note that simple async functions are implemented on top of
  // AsyncIterator objects; they just return a Promise for the value of
  // the final result produced by the iterator.

  exports.async = function (innerFn, outerFn, self, tryLocsList) {
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList));
    return exports.isGeneratorFunction(outerFn) ? iter // If outerFn is a generator, return the full iterator.
    : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  };

  function makeInvokeMethod(innerFn, self, context) {
    var state = GenStateSuspendedStart;
    return function invoke(method, arg) {
      if (state === GenStateExecuting) {
        throw new Error("Generator is already running");
      }

      if (state === GenStateCompleted) {
        if (method === "throw") {
          throw arg;
        } // Be forgiving, per 25.3.3.3.3 of the spec:
        // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume


        return doneResult();
      }

      context.method = method;
      context.arg = arg;

      while (true) {
        var delegate = context.delegate;

        if (delegate) {
          var delegateResult = maybeInvokeDelegate(delegate, context);

          if (delegateResult) {
            if (delegateResult === ContinueSentinel) continue;
            return delegateResult;
          }
        }

        if (context.method === "next") {
          // Setting context._sent for legacy support of Babel's
          // function.sent implementation.
          context.sent = context._sent = context.arg;
        } else if (context.method === "throw") {
          if (state === GenStateSuspendedStart) {
            state = GenStateCompleted;
            throw context.arg;
          }

          context.dispatchException(context.arg);
        } else if (context.method === "return") {
          context.abrupt("return", context.arg);
        }

        state = GenStateExecuting;
        var record = tryCatch(innerFn, self, context);

        if (record.type === "normal") {
          // If an exception is thrown from innerFn, we leave state ===
          // GenStateExecuting and loop back for another invocation.
          state = context.done ? GenStateCompleted : GenStateSuspendedYield;

          if (record.arg === ContinueSentinel) {
            continue;
          }

          return {
            value: record.arg,
            done: context.done
          };
        } else if (record.type === "throw") {
          state = GenStateCompleted; // Dispatch the exception by looping back around to the
          // context.dispatchException(context.arg) call above.

          context.method = "throw";
          context.arg = record.arg;
        }
      }
    };
  } // Call delegate.iterator[context.method](context.arg) and handle the
  // result, either by returning a { value, done } result from the
  // delegate iterator, or by modifying context.method and context.arg,
  // setting context.delegate to null, and returning the ContinueSentinel.


  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (method === undefined) {
      // A .throw or .return when the delegate iterator has no .throw
      // method always terminates the yield* loop.
      context.delegate = null;

      if (context.method === "throw") {
        // Note: ["return"] must be used for ES3 parsing compatibility.
        if (delegate.iterator["return"]) {
          // If the delegate iterator has a return method, give it a
          // chance to clean up.
          context.method = "return";
          context.arg = undefined;
          maybeInvokeDelegate(delegate, context);

          if (context.method === "throw") {
            // If maybeInvokeDelegate(context) changed context.method from
            // "return" to "throw", let that override the TypeError below.
            return ContinueSentinel;
          }
        }

        context.method = "throw";
        context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);

    if (record.type === "throw") {
      context.method = "throw";
      context.arg = record.arg;
      context.delegate = null;
      return ContinueSentinel;
    }

    var info = record.arg;

    if (!info) {
      context.method = "throw";
      context.arg = new TypeError("iterator result is not an object");
      context.delegate = null;
      return ContinueSentinel;
    }

    if (info.done) {
      // Assign the result of the finished delegate to the temporary
      // variable specified by delegate.resultName (see delegateYield).
      context[delegate.resultName] = info.value; // Resume execution at the desired location (see delegateYield).

      context.next = delegate.nextLoc; // If context.method was "throw" but the delegate handled the
      // exception, let the outer generator proceed normally. If
      // context.method was "next", forget context.arg since it has been
      // "consumed" by the delegate iterator. If context.method was
      // "return", allow the original .return call to continue in the
      // outer generator.

      if (context.method !== "return") {
        context.method = "next";
        context.arg = undefined;
      }
    } else {
      // Re-yield the result returned by the delegate method.
      return info;
    } // The delegate iterator is finished, so forget it and continue with
    // the outer generator.


    context.delegate = null;
    return ContinueSentinel;
  } // Define Generator.prototype.{next,throw,return} in terms of the
  // unified ._invoke helper method.


  defineIteratorMethods(Gp);
  Gp[toStringTagSymbol] = "Generator"; // A Generator should always return itself as the iterator object when the
  // @@iterator function is called on it. Some browsers' implementations of the
  // iterator prototype chain incorrectly implement this, causing the Generator
  // object to not be returned from this call. This ensures that doesn't happen.
  // See https://github.com/facebook/regenerator/issues/274 for more details.

  Gp[iteratorSymbol] = function () {
    return this;
  };

  Gp.toString = function () {
    return "[object Generator]";
  };

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };

    if (1 in locs) {
      entry.catchLoc = locs[1];
    }

    if (2 in locs) {
      entry.finallyLoc = locs[2];
      entry.afterLoc = locs[3];
    }

    this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal";
    delete record.arg;
    entry.completion = record;
  }

  function Context(tryLocsList) {
    // The root entry object (effectively a try statement without a catch
    // or a finally block) gives us a place to store values thrown from
    // locations where there is no enclosing try statement.
    this.tryEntries = [{
      tryLoc: "root"
    }];
    tryLocsList.forEach(pushTryEntry, this);
    this.reset(true);
  }

  exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    keys.reverse(); // Rather than returning an object with a next method, we keep
    // things simple and return the next function itself.

    return function next() {
      while (keys.length) {
        var key = keys.pop();

        if (key in object) {
          next.value = key;
          next.done = false;
          return next;
        }
      } // To avoid creating an additional object, we just hang the .value
      // and .done properties off the next function object itself. This
      // also ensures that the minifier will not anonymize the function.


      next.done = true;
      return next;
    };
  };

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];

      if (iteratorMethod) {
        return iteratorMethod.call(iterable);
      }

      if (typeof iterable.next === "function") {
        return iterable;
      }

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          while (++i < iterable.length) {
            if (hasOwn.call(iterable, i)) {
              next.value = iterable[i];
              next.done = false;
              return next;
            }
          }

          next.value = undefined;
          next.done = true;
          return next;
        };

        return next.next = next;
      }
    } // Return an iterator with no values.


    return {
      next: doneResult
    };
  }

  exports.values = values;

  function doneResult() {
    return {
      value: undefined,
      done: true
    };
  }

  Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      this.prev = 0;
      this.next = 0; // Resetting context._sent for legacy support of Babel's
      // function.sent implementation.

      this.sent = this._sent = undefined;
      this.done = false;
      this.delegate = null;
      this.method = "next";
      this.arg = undefined;
      this.tryEntries.forEach(resetTryEntry);

      if (!skipTempReset) {
        for (var name in this) {
          // Not sure about the optimal order of these conditions:
          if (name.charAt(0) === "t" && hasOwn.call(this, name) && !isNaN(+name.slice(1))) {
            this[name] = undefined;
          }
        }
      }
    },
    stop: function stop() {
      this.done = true;
      var rootEntry = this.tryEntries[0];
      var rootRecord = rootEntry.completion;

      if (rootRecord.type === "throw") {
        throw rootRecord.arg;
      }

      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) {
        throw exception;
      }

      var context = this;

      function handle(loc, caught) {
        record.type = "throw";
        record.arg = exception;
        context.next = loc;

        if (caught) {
          // If the dispatched exception was caught by a catch block,
          // then let that catch block handle the exception normally.
          context.method = "next";
          context.arg = undefined;
        }

        return !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        var record = entry.completion;

        if (entry.tryLoc === "root") {
          // Exception thrown outside of any try block that could handle
          // it, so set the completion value of the entire function to
          // throw the exception.
          return handle("end");
        }

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc");
          var hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            } else if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) {
              return handle(entry.catchLoc, true);
            }
          } else if (hasFinally) {
            if (this.prev < entry.finallyLoc) {
              return handle(entry.finallyLoc);
            }
          } else {
            throw new Error("try statement without catch or finally");
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      if (finallyEntry && (type === "break" || type === "continue") && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc) {
        // Ignore the finally entry if control is not jumping to a
        // location outside the try/catch block.
        finallyEntry = null;
      }

      var record = finallyEntry ? finallyEntry.completion : {};
      record.type = type;
      record.arg = arg;

      if (finallyEntry) {
        this.method = "next";
        this.next = finallyEntry.finallyLoc;
        return ContinueSentinel;
      }

      return this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if (record.type === "throw") {
        throw record.arg;
      }

      if (record.type === "break" || record.type === "continue") {
        this.next = record.arg;
      } else if (record.type === "return") {
        this.rval = this.arg = record.arg;
        this.method = "return";
        this.next = "end";
      } else if (record.type === "normal" && afterLoc) {
        this.next = afterLoc;
      }

      return ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.finallyLoc === finallyLoc) {
          this.complete(entry.completion, entry.afterLoc);
          resetTryEntry(entry);
          return ContinueSentinel;
        }
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if (record.type === "throw") {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      } // The context.catch method must only be called with a location
      // argument that corresponds to a known catch block.


      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      };

      if (this.method === "next") {
        // Deliberately forget the last sent value so that we don't
        // accidentally pass it on to the delegate.
        this.arg = undefined;
      }

      return ContinueSentinel;
    }
  }; // Regardless of whether this script is executing as a CommonJS module
  // or not, return the runtime object so that we can declare the variable
  // regeneratorRuntime in the outer scope, which allows this module to be
  // injected easily by `bin/regenerator --include-runtime script.js`.

  return exports;
}( // If this script is executing as a CommonJS module, use module.exports
// as the regeneratorRuntime namespace. Otherwise create a new empty
// object. Either way, the resulting object will be used to initialize
// the regeneratorRuntime variable at the top of this file.
( false ? undefined : _typeof(module)) === "object" ? module.exports : {});

try {
  regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
  // This module should not be running in strict mode, so the above
  // assignment should always work unless something is misconfigured. Just
  // in case runtime.js accidentally runs in strict mode, we can escape
  // strict mode using a global Function call. This could conceivably fail
  // if a Content Security Policy forbids using Function, but in that case
  // the proper solution is to fix the accidental strict mode problem. If
  // you've misconfigured your bundler to force strict mode and applied a
  // CSP to forbid Function, and you're not willing to fix either of those
  // problems, please detail your unique predicament in a GitHub issue.
  Function("r", "regeneratorRuntime = r")(runtime);
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/module.js */ "../node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "../node_modules/source-map/lib/array-set.js":
/*!***************************************************!*\
  !*** ../node_modules/source-map/lib/array-set.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = __webpack_require__(/*! ./util */ "../node_modules/source-map/lib/util.js");

var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";
/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */

function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}
/**
 * Static method for creating ArraySet instances from an existing array.
 */


ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();

  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }

  return set;
};
/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */


ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};
/**
 * Add the given string to this set.
 *
 * @param String aStr
 */


ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;

  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }

  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};
/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */


ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};
/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */


ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);

    if (idx >= 0) {
      return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);

    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};
/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */


ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }

  throw new Error('No element indexed by ' + aIdx);
};
/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */


ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.ArraySet = ArraySet;

/***/ }),

/***/ "../node_modules/source-map/lib/base64-vlq.js":
/*!****************************************************!*\
  !*** ../node_modules/source-map/lib/base64-vlq.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
var base64 = __webpack_require__(/*! ./base64 */ "../node_modules/source-map/lib/base64.js"); // A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011


var VLQ_BASE_SHIFT = 5; // binary: 100000

var VLQ_BASE = 1 << VLQ_BASE_SHIFT; // binary: 011111

var VLQ_BASE_MASK = VLQ_BASE - 1; // binary: 100000

var VLQ_CONTINUATION_BIT = VLQ_BASE;
/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */

function toVLQSigned(aValue) {
  return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
}
/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */


function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative ? -shifted : shifted;
}
/**
 * Returns the base 64 VLQ encoded value.
 */


exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;
  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;

    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }

    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};
/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */


exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));

    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};

/***/ }),

/***/ "../node_modules/source-map/lib/base64.js":
/*!************************************************!*\
  !*** ../node_modules/source-map/lib/base64.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */

exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }

  throw new TypeError("Must be between 0 and 63: " + number);
};
/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */


exports.decode = function (charCode) {
  var bigA = 65; // 'A'

  var bigZ = 90; // 'Z'

  var littleA = 97; // 'a'

  var littleZ = 122; // 'z'

  var zero = 48; // '0'

  var nine = 57; // '9'

  var plus = 43; // '+'

  var slash = 47; // '/'

  var littleOffset = 26;
  var numberOffset = 52; // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ

  if (bigA <= charCode && charCode <= bigZ) {
    return charCode - bigA;
  } // 26 - 51: abcdefghijklmnopqrstuvwxyz


  if (littleA <= charCode && charCode <= littleZ) {
    return charCode - littleA + littleOffset;
  } // 52 - 61: 0123456789


  if (zero <= charCode && charCode <= nine) {
    return charCode - zero + numberOffset;
  } // 62: +


  if (charCode == plus) {
    return 62;
  } // 63: /


  if (charCode == slash) {
    return 63;
  } // Invalid base64 digit.


  return -1;
};

/***/ }),

/***/ "../node_modules/source-map/lib/binary-search.js":
/*!*******************************************************!*\
  !*** ../node_modules/source-map/lib/binary-search.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.GREATEST_LOWER_BOUND = 1;
exports.LEAST_UPPER_BOUND = 2;
/**
 * Recursive implementation of binary search.
 *
 * @param aLow Indices here and lower do not contain the needle.
 * @param aHigh Indices here and higher do not contain the needle.
 * @param aNeedle The element being searched for.
 * @param aHaystack The non-empty array being searched.
 * @param aCompare Function which takes two elements and returns -1, 0, or 1.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 */

function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
  // This function terminates when one of the following is true:
  //
  //   1. We find the exact element we are looking for.
  //
  //   2. We did not find the exact element, but we can return the index of
  //      the next-closest element.
  //
  //   3. We did not find the exact element, and there is no next-closest
  //      element than the one we are searching for, so we return -1.
  var mid = Math.floor((aHigh - aLow) / 2) + aLow;
  var cmp = aCompare(aNeedle, aHaystack[mid], true);

  if (cmp === 0) {
    // Found the element we are looking for.
    return mid;
  } else if (cmp > 0) {
    // Our needle is greater than aHaystack[mid].
    if (aHigh - mid > 1) {
      // The element is in the upper half.
      return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
    } // The exact needle element was not found in this haystack. Determine if
    // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return aHigh < aHaystack.length ? aHigh : -1;
    } else {
      return mid;
    }
  } else {
    // Our needle is less than aHaystack[mid].
    if (mid - aLow > 1) {
      // The element is in the lower half.
      return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
    } // we are in termination case (3) or (2) and return the appropriate thing.


    if (aBias == exports.LEAST_UPPER_BOUND) {
      return mid;
    } else {
      return aLow < 0 ? -1 : aLow;
    }
  }
}
/**
 * This is an implementation of binary search which will always try and return
 * the index of the closest element if there is no exact hit. This is because
 * mappings between original and generated line/col pairs are single points,
 * and there is an implicit region between each of them, so a miss just means
 * that you aren't on the very start of a region.
 *
 * @param aNeedle The element you are looking for.
 * @param aHaystack The array that is being searched.
 * @param aCompare A function which takes the needle and an element in the
 *     array and returns -1, 0, or 1 depending on whether the needle is less
 *     than, equal to, or greater than the element, respectively.
 * @param aBias Either 'binarySearch.GREATEST_LOWER_BOUND' or
 *     'binarySearch.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'binarySearch.GREATEST_LOWER_BOUND'.
 */


exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
  if (aHaystack.length === 0) {
    return -1;
  }

  var index = recursiveSearch(-1, aHaystack.length, aNeedle, aHaystack, aCompare, aBias || exports.GREATEST_LOWER_BOUND);

  if (index < 0) {
    return -1;
  } // We have found either the exact element, or the next-closest element than
  // the one we are searching for. However, there may be more than one such
  // element. Make sure we always return the smallest of these.


  while (index - 1 >= 0) {
    if (aCompare(aHaystack[index], aHaystack[index - 1], true) !== 0) {
      break;
    }

    --index;
  }

  return index;
};

/***/ }),

/***/ "../node_modules/source-map/lib/mapping-list.js":
/*!******************************************************!*\
  !*** ../node_modules/source-map/lib/mapping-list.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = __webpack_require__(/*! ./util */ "../node_modules/source-map/lib/util.js");
/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */


function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}
/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */


function MappingList() {
  this._array = [];
  this._sorted = true; // Serves as infimum

  this._last = {
    generatedLine: -1,
    generatedColumn: 0
  };
}
/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */


MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
  this._array.forEach(aCallback, aThisArg);
};
/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */


MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;

    this._array.push(aMapping);
  } else {
    this._sorted = false;

    this._array.push(aMapping);
  }
};
/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */


MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);

    this._sorted = true;
  }

  return this._array;
};

exports.MappingList = MappingList;

/***/ }),

/***/ "../node_modules/source-map/lib/quick-sort.js":
/*!****************************************************!*\
  !*** ../node_modules/source-map/lib/quick-sort.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
// It turns out that some (most?) JavaScript engines don't self-host
// `Array.prototype.sort`. This makes sense because C++ will likely remain
// faster than JS when doing raw CPU-intensive sorting. However, when using a
// custom comparator function, calling back and forth between the VM's C++ and
// JIT'd JS is rather slow *and* loses JIT type information, resulting in
// worse generated code for the comparator function than would be optimal. In
// fact, when sorting with a comparator, these costs outweigh the benefits of
// sorting in C++. By using our own JS-implemented Quick Sort (below), we get
// a ~3500ms mean speed-up in `bench/bench.html`.

/**
 * Swap the elements indexed by `x` and `y` in the array `ary`.
 *
 * @param {Array} ary
 *        The array.
 * @param {Number} x
 *        The index of the first item.
 * @param {Number} y
 *        The index of the second item.
 */
function swap(ary, x, y) {
  var temp = ary[x];
  ary[x] = ary[y];
  ary[y] = temp;
}
/**
 * Returns a random integer within the range `low .. high` inclusive.
 *
 * @param {Number} low
 *        The lower bound on the range.
 * @param {Number} high
 *        The upper bound on the range.
 */


function randomIntInRange(low, high) {
  return Math.round(low + Math.random() * (high - low));
}
/**
 * The Quick Sort algorithm.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 * @param {Number} p
 *        Start index of the array
 * @param {Number} r
 *        End index of the array
 */


function doQuickSort(ary, comparator, p, r) {
  // If our lower bound is less than our upper bound, we (1) partition the
  // array into two pieces and (2) recurse on each half. If it is not, this is
  // the empty array and our base case.
  if (p < r) {
    // (1) Partitioning.
    //
    // The partitioning chooses a pivot between `p` and `r` and moves all
    // elements that are less than or equal to the pivot to the before it, and
    // all the elements that are greater than it after it. The effect is that
    // once partition is done, the pivot is in the exact place it will be when
    // the array is put in sorted order, and it will not need to be moved
    // again. This runs in O(n) time.
    // Always choose a random pivot so that an input array which is reverse
    // sorted does not cause O(n^2) running time.
    var pivotIndex = randomIntInRange(p, r);
    var i = p - 1;
    swap(ary, pivotIndex, r);
    var pivot = ary[r]; // Immediately after `j` is incremented in this loop, the following hold
    // true:
    //
    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.
    //
    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.

    for (var j = p; j < r; j++) {
      if (comparator(ary[j], pivot) <= 0) {
        i += 1;
        swap(ary, i, j);
      }
    }

    swap(ary, i + 1, j);
    var q = i + 1; // (2) Recurse on each half.

    doQuickSort(ary, comparator, p, q - 1);
    doQuickSort(ary, comparator, q + 1, r);
  }
}
/**
 * Sort the given array in-place with the given comparator function.
 *
 * @param {Array} ary
 *        An array to sort.
 * @param {function} comparator
 *        Function to use to compare two items.
 */


exports.quickSort = function (ary, comparator) {
  doQuickSort(ary, comparator, 0, ary.length - 1);
};

/***/ }),

/***/ "../node_modules/source-map/lib/source-map-consumer.js":
/*!*************************************************************!*\
  !*** ../node_modules/source-map/lib/source-map-consumer.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var util = __webpack_require__(/*! ./util */ "../node_modules/source-map/lib/util.js");

var binarySearch = __webpack_require__(/*! ./binary-search */ "../node_modules/source-map/lib/binary-search.js");

var ArraySet = __webpack_require__(/*! ./array-set */ "../node_modules/source-map/lib/array-set.js").ArraySet;

var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../node_modules/source-map/lib/base64-vlq.js");

var quickSort = __webpack_require__(/*! ./quick-sort */ "../node_modules/source-map/lib/quick-sort.js").quickSort;

function SourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  return sourceMap.sections != null ? new IndexedSourceMapConsumer(sourceMap, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap, aSourceMapURL);
}

SourceMapConsumer.fromSourceMap = function (aSourceMap, aSourceMapURL) {
  return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
};
/**
 * The version of the source mapping spec that we are consuming.
 */


SourceMapConsumer.prototype._version = 3; // `__generatedMappings` and `__originalMappings` are arrays that hold the
// parsed mapping coordinates from the source map's "mappings" attribute. They
// are lazily instantiated, accessed via the `_generatedMappings` and
// `_originalMappings` getters respectively, and we only parse the mappings
// and create these arrays once queried for a source location. We jump through
// these hoops because there can be many thousands of mappings, and parsing
// them is expensive, so we only want to do it if we must.
//
// Each object in the arrays is of the form:
//
//     {
//       generatedLine: The line number in the generated code,
//       generatedColumn: The column number in the generated code,
//       source: The path to the original source file that generated this
//               chunk of code,
//       originalLine: The line number in the original source that
//                     corresponds to this chunk of generated code,
//       originalColumn: The column number in the original source that
//                       corresponds to this chunk of generated code,
//       name: The name of the original symbol which generated this chunk of
//             code.
//     }
//
// All properties except for `generatedLine` and `generatedColumn` can be
// `null`.
//
// `_generatedMappings` is ordered by the generated positions.
//
// `_originalMappings` is ordered by the original positions.

SourceMapConsumer.prototype.__generatedMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_generatedMappings', {
  configurable: true,
  enumerable: true,
  get: function get() {
    if (!this.__generatedMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__generatedMappings;
  }
});
SourceMapConsumer.prototype.__originalMappings = null;
Object.defineProperty(SourceMapConsumer.prototype, '_originalMappings', {
  configurable: true,
  enumerable: true,
  get: function get() {
    if (!this.__originalMappings) {
      this._parseMappings(this._mappings, this.sourceRoot);
    }

    return this.__originalMappings;
  }
});

SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index) {
  var c = aStr.charAt(index);
  return c === ";" || c === ",";
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  throw new Error("Subclasses must implement _parseMappings");
};

SourceMapConsumer.GENERATED_ORDER = 1;
SourceMapConsumer.ORIGINAL_ORDER = 2;
SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
SourceMapConsumer.LEAST_UPPER_BOUND = 2;
/**
 * Iterate over each mapping between an original source/line/column and a
 * generated line/column in this source map.
 *
 * @param Function aCallback
 *        The function that is called with each mapping.
 * @param Object aContext
 *        Optional. If specified, this object will be the value of `this` every
 *        time that `aCallback` is called.
 * @param aOrder
 *        Either `SourceMapConsumer.GENERATED_ORDER` or
 *        `SourceMapConsumer.ORIGINAL_ORDER`. Specifies whether you want to
 *        iterate over the mappings sorted by the generated file's line/column
 *        order or the original's source/line/column order, respectively. Defaults to
 *        `SourceMapConsumer.GENERATED_ORDER`.
 */

SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
  var context = aContext || null;
  var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
  var mappings;

  switch (order) {
    case SourceMapConsumer.GENERATED_ORDER:
      mappings = this._generatedMappings;
      break;

    case SourceMapConsumer.ORIGINAL_ORDER:
      mappings = this._originalMappings;
      break;

    default:
      throw new Error("Unknown order of iteration.");
  }

  var sourceRoot = this.sourceRoot;
  mappings.map(function (mapping) {
    var source = mapping.source === null ? null : this._sources.at(mapping.source);
    source = util.computeSourceURL(sourceRoot, source, this._sourceMapURL);
    return {
      source: source,
      generatedLine: mapping.generatedLine,
      generatedColumn: mapping.generatedColumn,
      originalLine: mapping.originalLine,
      originalColumn: mapping.originalColumn,
      name: mapping.name === null ? null : this._names.at(mapping.name)
    };
  }, this).forEach(aCallback, context);
};
/**
 * Returns all generated line and column information for the original source,
 * line, and column provided. If no column is provided, returns all mappings
 * corresponding to a either the line we are searching for or the next
 * closest line that has any mappings. Otherwise, returns all mappings
 * corresponding to the given line and either the column we are searching for
 * or the next closest column that has any offsets.
 *
 * The only argument is an object with the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number is 1-based.
 *   - column: Optional. the column number in the original source.
 *    The column number is 0-based.
 *
 * and an array of objects is returned, each with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *    line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *    The column number is 0-based.
 */


SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
  var line = util.getArg(aArgs, 'line'); // When there is no exact match, BasicSourceMapConsumer.prototype._findMapping
  // returns the index of the closest mapping less than the needle. By
  // setting needle.originalColumn to 0, we thus find the last mapping for
  // the given line, provided such a mapping exists.

  var needle = {
    source: util.getArg(aArgs, 'source'),
    originalLine: line,
    originalColumn: util.getArg(aArgs, 'column', 0)
  };
  needle.source = this._findSourceIndex(needle.source);

  if (needle.source < 0) {
    return [];
  }

  var mappings = [];

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, binarySearch.LEAST_UPPER_BOUND);

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (aArgs.column === undefined) {
      var originalLine = mapping.originalLine; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we found. Since
      // mappings are sorted, this is guaranteed to find all mappings for
      // the line we found.

      while (mapping && mapping.originalLine === originalLine) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    } else {
      var originalColumn = mapping.originalColumn; // Iterate until either we run out of mappings, or we run into
      // a mapping for a different line than the one we were searching for.
      // Since mappings are sorted, this is guaranteed to find all mappings for
      // the line we are searching for.

      while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
        mappings.push({
          line: util.getArg(mapping, 'generatedLine', null),
          column: util.getArg(mapping, 'generatedColumn', null),
          lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
        });
        mapping = this._originalMappings[++index];
      }
    }
  }

  return mappings;
};

exports.SourceMapConsumer = SourceMapConsumer;
/**
 * A BasicSourceMapConsumer instance represents a parsed source map which we can
 * query for information about the original file positions by giving it a file
 * position in the generated source.
 *
 * The first parameter is the raw source map (either as a JSON string, or
 * already parsed to an object). According to the spec, source maps have the
 * following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - sources: An array of URLs to the original source files.
 *   - names: An array of identifiers which can be referrenced by individual mappings.
 *   - sourceRoot: Optional. The URL root from which all sources are relative.
 *   - sourcesContent: Optional. An array of contents of the original source files.
 *   - mappings: A string of base64 VLQs which contain the actual mappings.
 *   - file: Optional. The generated file this source map is associated with.
 *
 * Here is an example source map, taken from the source map spec[0]:
 *
 *     {
 *       version : 3,
 *       file: "out.js",
 *       sourceRoot : "",
 *       sources: ["foo.js", "bar.js"],
 *       names: ["src", "maps", "are", "fun"],
 *       mappings: "AA,AB;;ABCDE;"
 *     }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit?pli=1#
 */

function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sources = util.getArg(sourceMap, 'sources'); // Sass 3.3 leaves out the 'names' array, so we deviate from the spec (which
  // requires the array) to play nice here.

  var names = util.getArg(sourceMap, 'names', []);
  var sourceRoot = util.getArg(sourceMap, 'sourceRoot', null);
  var sourcesContent = util.getArg(sourceMap, 'sourcesContent', null);
  var mappings = util.getArg(sourceMap, 'mappings');
  var file = util.getArg(sourceMap, 'file', null); // Once again, Sass deviates from the spec and supplies the version as a
  // string rather than a number, so we use loose equality checking here.

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  if (sourceRoot) {
    sourceRoot = util.normalize(sourceRoot);
  }

  sources = sources.map(String) // Some source maps produce relative source paths like "./foo.js" instead of
  // "foo.js".  Normalize these first so that future comparisons will succeed.
  // See bugzil.la/1090768.
  .map(util.normalize) // Always ensure that absolute sources are internally stored relative to
  // the source root, if the source root is absolute. Not doing this would
  // be particularly problematic when the source root is a prefix of the
  // source (valid, but why??). See github issue #199 and bugzil.la/1188982.
  .map(function (source) {
    return sourceRoot && util.isAbsolute(sourceRoot) && util.isAbsolute(source) ? util.relative(sourceRoot, source) : source;
  }); // Pass `true` below to allow duplicate names and sources. While source maps
  // are intended to be compressed and deduplicated, the TypeScript compiler
  // sometimes generates source maps with duplicates in them. See Github issue
  // #72 and bugzil.la/889492.

  this._names = ArraySet.fromArray(names.map(String), true);
  this._sources = ArraySet.fromArray(sources, true);
  this._absoluteSources = this._sources.toArray().map(function (s) {
    return util.computeSourceURL(sourceRoot, s, aSourceMapURL);
  });
  this.sourceRoot = sourceRoot;
  this.sourcesContent = sourcesContent;
  this._mappings = mappings;
  this._sourceMapURL = aSourceMapURL;
  this.file = file;
}

BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
/**
 * Utility function to find the index of a source.  Returns -1 if not
 * found.
 */

BasicSourceMapConsumer.prototype._findSourceIndex = function (aSource) {
  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  if (this._sources.has(relativeSource)) {
    return this._sources.indexOf(relativeSource);
  } // Maybe aSource is an absolute URL as returned by |sources|.  In
  // this case we can't simply undo the transform.


  var i;

  for (i = 0; i < this._absoluteSources.length; ++i) {
    if (this._absoluteSources[i] == aSource) {
      return i;
    }
  }

  return -1;
};
/**
 * Create a BasicSourceMapConsumer from a SourceMapGenerator.
 *
 * @param SourceMapGenerator aSourceMap
 *        The source map that will be consumed.
 * @param String aSourceMapURL
 *        The URL at which the source map can be found (optional)
 * @returns BasicSourceMapConsumer
 */


BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
  var smc = Object.create(BasicSourceMapConsumer.prototype);
  var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
  var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
  smc.sourceRoot = aSourceMap._sourceRoot;
  smc.sourcesContent = aSourceMap._generateSourcesContent(smc._sources.toArray(), smc.sourceRoot);
  smc.file = aSourceMap._file;
  smc._sourceMapURL = aSourceMapURL;
  smc._absoluteSources = smc._sources.toArray().map(function (s) {
    return util.computeSourceURL(smc.sourceRoot, s, aSourceMapURL);
  }); // Because we are modifying the entries (by converting string sources and
  // names to indices into the sources and names ArraySets), we have to make
  // a copy of the entry or else bad things happen. Shared mutable state
  // strikes again! See github issue #191.

  var generatedMappings = aSourceMap._mappings.toArray().slice();

  var destGeneratedMappings = smc.__generatedMappings = [];
  var destOriginalMappings = smc.__originalMappings = [];

  for (var i = 0, length = generatedMappings.length; i < length; i++) {
    var srcMapping = generatedMappings[i];
    var destMapping = new Mapping();
    destMapping.generatedLine = srcMapping.generatedLine;
    destMapping.generatedColumn = srcMapping.generatedColumn;

    if (srcMapping.source) {
      destMapping.source = sources.indexOf(srcMapping.source);
      destMapping.originalLine = srcMapping.originalLine;
      destMapping.originalColumn = srcMapping.originalColumn;

      if (srcMapping.name) {
        destMapping.name = names.indexOf(srcMapping.name);
      }

      destOriginalMappings.push(destMapping);
    }

    destGeneratedMappings.push(destMapping);
  }

  quickSort(smc.__originalMappings, util.compareByOriginalPositions);
  return smc;
};
/**
 * The version of the source mapping spec that we are consuming.
 */


BasicSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(BasicSourceMapConsumer.prototype, 'sources', {
  get: function get() {
    return this._absoluteSources.slice();
  }
});
/**
 * Provide the JIT with a nice shape / hidden class.
 */

function Mapping() {
  this.generatedLine = 0;
  this.generatedColumn = 0;
  this.source = null;
  this.originalLine = null;
  this.originalColumn = null;
  this.name = null;
}
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  var generatedLine = 1;
  var previousGeneratedColumn = 0;
  var previousOriginalLine = 0;
  var previousOriginalColumn = 0;
  var previousSource = 0;
  var previousName = 0;
  var length = aStr.length;
  var index = 0;
  var cachedSegments = {};
  var temp = {};
  var originalMappings = [];
  var generatedMappings = [];
  var mapping, str, segment, end, value;

  while (index < length) {
    if (aStr.charAt(index) === ';') {
      generatedLine++;
      index++;
      previousGeneratedColumn = 0;
    } else if (aStr.charAt(index) === ',') {
      index++;
    } else {
      mapping = new Mapping();
      mapping.generatedLine = generatedLine; // Because each offset is encoded relative to the previous one,
      // many segments often have the same encoding. We can exploit this
      // fact by caching the parsed variable length fields of each segment,
      // allowing us to avoid a second parse if we encounter the same
      // segment again.

      for (end = index; end < length; end++) {
        if (this._charIsMappingSeparator(aStr, end)) {
          break;
        }
      }

      str = aStr.slice(index, end);
      segment = cachedSegments[str];

      if (segment) {
        index += str.length;
      } else {
        segment = [];

        while (index < end) {
          base64VLQ.decode(aStr, index, temp);
          value = temp.value;
          index = temp.rest;
          segment.push(value);
        }

        if (segment.length === 2) {
          throw new Error('Found a source, but no line and column');
        }

        if (segment.length === 3) {
          throw new Error('Found a source and line, but no column');
        }

        cachedSegments[str] = segment;
      } // Generated column.


      mapping.generatedColumn = previousGeneratedColumn + segment[0];
      previousGeneratedColumn = mapping.generatedColumn;

      if (segment.length > 1) {
        // Original source.
        mapping.source = previousSource + segment[1];
        previousSource += segment[1]; // Original line.

        mapping.originalLine = previousOriginalLine + segment[2];
        previousOriginalLine = mapping.originalLine; // Lines are stored 0-based

        mapping.originalLine += 1; // Original column.

        mapping.originalColumn = previousOriginalColumn + segment[3];
        previousOriginalColumn = mapping.originalColumn;

        if (segment.length > 4) {
          // Original name.
          mapping.name = previousName + segment[4];
          previousName += segment[4];
        }
      }

      generatedMappings.push(mapping);

      if (typeof mapping.originalLine === 'number') {
        originalMappings.push(mapping);
      }
    }
  }

  quickSort(generatedMappings, util.compareByGeneratedPositionsDeflated);
  this.__generatedMappings = generatedMappings;
  quickSort(originalMappings, util.compareByOriginalPositions);
  this.__originalMappings = originalMappings;
};
/**
 * Find the mapping that best matches the hypothetical "needle" mapping that
 * we are searching for in the given "haystack" of mappings.
 */


BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
  // To return the position we are searching for, we must first find the
  // mapping for the given position and then return the opposite position it
  // points to. Because the mappings are sorted, we can use binary search to
  // find the best mapping.
  if (aNeedle[aLineName] <= 0) {
    throw new TypeError('Line must be greater than or equal to 1, got ' + aNeedle[aLineName]);
  }

  if (aNeedle[aColumnName] < 0) {
    throw new TypeError('Column must be greater than or equal to 0, got ' + aNeedle[aColumnName]);
  }

  return binarySearch.search(aNeedle, aMappings, aComparator, aBias);
};
/**
 * Compute the last column for each generated mapping. The last column is
 * inclusive.
 */


BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
  for (var index = 0; index < this._generatedMappings.length; ++index) {
    var mapping = this._generatedMappings[index]; // Mappings do not contain a field for the last generated columnt. We
    // can come up with an optimistic estimate, however, by assuming that
    // mappings are contiguous (i.e. given two consecutive mappings, the
    // first mapping ends where the second one starts).

    if (index + 1 < this._generatedMappings.length) {
      var nextMapping = this._generatedMappings[index + 1];

      if (mapping.generatedLine === nextMapping.generatedLine) {
        mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
        continue;
      }
    } // The last mapping for each line spans the entire line.


    mapping.lastGeneratedColumn = Infinity;
  }
};
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */


BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._generatedMappings, "generatedLine", "generatedColumn", util.compareByGeneratedPositionsDeflated, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._generatedMappings[index];

    if (mapping.generatedLine === needle.generatedLine) {
      var source = util.getArg(mapping, 'source', null);

      if (source !== null) {
        source = this._sources.at(source);
        source = util.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
      }

      var name = util.getArg(mapping, 'name', null);

      if (name !== null) {
        name = this._names.at(name);
      }

      return {
        source: source,
        line: util.getArg(mapping, 'originalLine', null),
        column: util.getArg(mapping, 'originalColumn', null),
        name: name
      };
    }
  }

  return {
    source: null,
    line: null,
    column: null,
    name: null
  };
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
  if (!this.sourcesContent) {
    return false;
  }

  return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function (sc) {
    return sc == null;
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  if (!this.sourcesContent) {
    return null;
  }

  var index = this._findSourceIndex(aSource);

  if (index >= 0) {
    return this.sourcesContent[index];
  }

  var relativeSource = aSource;

  if (this.sourceRoot != null) {
    relativeSource = util.relative(this.sourceRoot, relativeSource);
  }

  var url;

  if (this.sourceRoot != null && (url = util.urlParse(this.sourceRoot))) {
    // XXX: file:// URIs and absolute paths lead to unexpected behavior for
    // many users. We can help them out when they expect file:// URIs to
    // behave like it would if they were running a local HTTP server. See
    // https://bugzilla.mozilla.org/show_bug.cgi?id=885597.
    var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");

    if (url.scheme == "file" && this._sources.has(fileUriAbsPath)) {
      return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
    }

    if ((!url.path || url.path == "/") && this._sources.has("/" + relativeSource)) {
      return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
    }
  } // This function is used recursively from
  // IndexedSourceMapConsumer.prototype.sourceContentFor. In that case, we
  // don't want to throw if we can't find the source - we just want to
  // return null, so we provide a flag to exit gracefully.


  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + relativeSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *   - bias: Either 'SourceMapConsumer.GREATEST_LOWER_BOUND' or
 *     'SourceMapConsumer.LEAST_UPPER_BOUND'. Specifies whether to return the
 *     closest element that is smaller than or greater than the one we are
 *     searching for, respectively, if the exact element cannot be found.
 *     Defaults to 'SourceMapConsumer.GREATEST_LOWER_BOUND'.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
  var source = util.getArg(aArgs, 'source');
  source = this._findSourceIndex(source);

  if (source < 0) {
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  }

  var needle = {
    source: source,
    originalLine: util.getArg(aArgs, 'line'),
    originalColumn: util.getArg(aArgs, 'column')
  };

  var index = this._findMapping(needle, this._originalMappings, "originalLine", "originalColumn", util.compareByOriginalPositions, util.getArg(aArgs, 'bias', SourceMapConsumer.GREATEST_LOWER_BOUND));

  if (index >= 0) {
    var mapping = this._originalMappings[index];

    if (mapping.source === needle.source) {
      return {
        line: util.getArg(mapping, 'generatedLine', null),
        column: util.getArg(mapping, 'generatedColumn', null),
        lastColumn: util.getArg(mapping, 'lastGeneratedColumn', null)
      };
    }
  }

  return {
    line: null,
    column: null,
    lastColumn: null
  };
};

exports.BasicSourceMapConsumer = BasicSourceMapConsumer;
/**
 * An IndexedSourceMapConsumer instance represents a parsed source map which
 * we can query for information. It differs from BasicSourceMapConsumer in
 * that it takes "indexed" source maps (i.e. ones with a "sections" field) as
 * input.
 *
 * The first parameter is a raw source map (either as a JSON string, or already
 * parsed to an object). According to the spec for indexed source maps, they
 * have the following attributes:
 *
 *   - version: Which version of the source map spec this map is following.
 *   - file: Optional. The generated file this source map is associated with.
 *   - sections: A list of section definitions.
 *
 * Each value under the "sections" field has two fields:
 *   - offset: The offset into the original specified at which this section
 *       begins to apply, defined as an object with a "line" and "column"
 *       field.
 *   - map: A source map definition. This source map could also be indexed,
 *       but doesn't have to be.
 *
 * Instead of the "map" field, it's also possible to have a "url" field
 * specifying a URL to retrieve a source map from, but that's currently
 * unsupported.
 *
 * Here's an example source map, taken from the source map spec[0], but
 * modified to omit a section which uses the "url" field.
 *
 *  {
 *    version : 3,
 *    file: "app.js",
 *    sections: [{
 *      offset: {line:100, column:10},
 *      map: {
 *        version : 3,
 *        file: "section.js",
 *        sources: ["foo.js", "bar.js"],
 *        names: ["src", "maps", "are", "fun"],
 *        mappings: "AAAA,E;;ABCDE;"
 *      }
 *    }],
 *  }
 *
 * The second parameter, if given, is a string whose value is the URL
 * at which the source map was found.  This URL is used to compute the
 * sources array.
 *
 * [0]: https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit#heading=h.535es3xeprgt
 */

function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
  var sourceMap = aSourceMap;

  if (typeof aSourceMap === 'string') {
    sourceMap = util.parseSourceMapInput(aSourceMap);
  }

  var version = util.getArg(sourceMap, 'version');
  var sections = util.getArg(sourceMap, 'sections');

  if (version != this._version) {
    throw new Error('Unsupported version: ' + version);
  }

  this._sources = new ArraySet();
  this._names = new ArraySet();
  var lastOffset = {
    line: -1,
    column: 0
  };
  this._sections = sections.map(function (s) {
    if (s.url) {
      // The url field will require support for asynchronicity.
      // See https://github.com/mozilla/source-map/issues/16
      throw new Error('Support for url field in sections not implemented.');
    }

    var offset = util.getArg(s, 'offset');
    var offsetLine = util.getArg(offset, 'line');
    var offsetColumn = util.getArg(offset, 'column');

    if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
      throw new Error('Section offsets must be ordered and non-overlapping.');
    }

    lastOffset = offset;
    return {
      generatedOffset: {
        // The offset fields are 0-based, but we use 1-based indices when
        // encoding/decoding from VLQ.
        generatedLine: offsetLine + 1,
        generatedColumn: offsetColumn + 1
      },
      consumer: new SourceMapConsumer(util.getArg(s, 'map'), aSourceMapURL)
    };
  });
}

IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
/**
 * The version of the source mapping spec that we are consuming.
 */

IndexedSourceMapConsumer.prototype._version = 3;
/**
 * The list of original sources.
 */

Object.defineProperty(IndexedSourceMapConsumer.prototype, 'sources', {
  get: function get() {
    var sources = [];

    for (var i = 0; i < this._sections.length; i++) {
      for (var j = 0; j < this._sections[i].consumer.sources.length; j++) {
        sources.push(this._sections[i].consumer.sources[j]);
      }
    }

    return sources;
  }
});
/**
 * Returns the original source, line, and column information for the generated
 * source's line and column positions provided. The only argument is an object
 * with the following properties:
 *
 *   - line: The line number in the generated source.  The line number
 *     is 1-based.
 *   - column: The column number in the generated source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - source: The original source file, or null.
 *   - line: The line number in the original source, or null.  The
 *     line number is 1-based.
 *   - column: The column number in the original source, or null.  The
 *     column number is 0-based.
 *   - name: The original identifier, or null.
 */

IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
  var needle = {
    generatedLine: util.getArg(aArgs, 'line'),
    generatedColumn: util.getArg(aArgs, 'column')
  }; // Find the section containing the generated position we're trying to map
  // to an original position.

  var sectionIndex = binarySearch.search(needle, this._sections, function (needle, section) {
    var cmp = needle.generatedLine - section.generatedOffset.generatedLine;

    if (cmp) {
      return cmp;
    }

    return needle.generatedColumn - section.generatedOffset.generatedColumn;
  });
  var section = this._sections[sectionIndex];

  if (!section) {
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  }

  return section.consumer.originalPositionFor({
    line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
    column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
    bias: aArgs.bias
  });
};
/**
 * Return true if we have the source content for every source in the source
 * map, false otherwise.
 */


IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
  return this._sections.every(function (s) {
    return s.consumer.hasContentsOfAllSources();
  });
};
/**
 * Returns the original source content. The only argument is the url of the
 * original source file. Returns null if no original source content is
 * available.
 */


IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var content = section.consumer.sourceContentFor(aSource, true);

    if (content) {
      return content;
    }
  }

  if (nullOnMissing) {
    return null;
  } else {
    throw new Error('"' + aSource + '" is not in the SourceMap.');
  }
};
/**
 * Returns the generated line and column information for the original source,
 * line, and column positions provided. The only argument is an object with
 * the following properties:
 *
 *   - source: The filename of the original source.
 *   - line: The line number in the original source.  The line number
 *     is 1-based.
 *   - column: The column number in the original source.  The column
 *     number is 0-based.
 *
 * and an object is returned with the following properties:
 *
 *   - line: The line number in the generated source, or null.  The
 *     line number is 1-based. 
 *   - column: The column number in the generated source, or null.
 *     The column number is 0-based.
 */


IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i]; // Only consider this section if the requested source is in the list of
    // sources of the consumer.

    if (section.consumer._findSourceIndex(util.getArg(aArgs, 'source')) === -1) {
      continue;
    }

    var generatedPosition = section.consumer.generatedPositionFor(aArgs);

    if (generatedPosition) {
      var ret = {
        line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
        column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
      };
      return ret;
    }
  }

  return {
    line: null,
    column: null
  };
};
/**
 * Parse the mappings in a string in to a data structure which we can easily
 * query (the ordered arrays in the `this.__generatedMappings` and
 * `this.__originalMappings` properties).
 */


IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
  this.__generatedMappings = [];
  this.__originalMappings = [];

  for (var i = 0; i < this._sections.length; i++) {
    var section = this._sections[i];
    var sectionMappings = section.consumer._generatedMappings;

    for (var j = 0; j < sectionMappings.length; j++) {
      var mapping = sectionMappings[j];

      var source = section.consumer._sources.at(mapping.source);

      source = util.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);

      this._sources.add(source);

      source = this._sources.indexOf(source);
      var name = null;

      if (mapping.name) {
        name = section.consumer._names.at(mapping.name);

        this._names.add(name);

        name = this._names.indexOf(name);
      } // The mappings coming from the consumer for the section have
      // generated positions relative to the start of the section, so we
      // need to offset them to be relative to the start of the concatenated
      // generated file.


      var adjustedMapping = {
        source: source,
        generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
        generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: name
      };

      this.__generatedMappings.push(adjustedMapping);

      if (typeof adjustedMapping.originalLine === 'number') {
        this.__originalMappings.push(adjustedMapping);
      }
    }
  }

  quickSort(this.__generatedMappings, util.compareByGeneratedPositionsDeflated);
  quickSort(this.__originalMappings, util.compareByOriginalPositions);
};

exports.IndexedSourceMapConsumer = IndexedSourceMapConsumer;

/***/ }),

/***/ "../node_modules/source-map/lib/source-map-generator.js":
/*!**************************************************************!*\
  !*** ../node_modules/source-map/lib/source-map-generator.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var base64VLQ = __webpack_require__(/*! ./base64-vlq */ "../node_modules/source-map/lib/base64-vlq.js");

var util = __webpack_require__(/*! ./util */ "../node_modules/source-map/lib/util.js");

var ArraySet = __webpack_require__(/*! ./array-set */ "../node_modules/source-map/lib/array-set.js").ArraySet;

var MappingList = __webpack_require__(/*! ./mapping-list */ "../node_modules/source-map/lib/mapping-list.js").MappingList;
/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */


function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }

  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;
/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */

SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
  var sourceRoot = aSourceMapConsumer.sourceRoot;
  var generator = new SourceMapGenerator({
    file: aSourceMapConsumer.file,
    sourceRoot: sourceRoot
  });
  aSourceMapConsumer.eachMapping(function (mapping) {
    var newMapping = {
      generated: {
        line: mapping.generatedLine,
        column: mapping.generatedColumn
      }
    };

    if (mapping.source != null) {
      newMapping.source = mapping.source;

      if (sourceRoot != null) {
        newMapping.source = util.relative(sourceRoot, newMapping.source);
      }

      newMapping.original = {
        line: mapping.originalLine,
        column: mapping.originalColumn
      };

      if (mapping.name != null) {
        newMapping.name = mapping.name;
      }
    }

    generator.addMapping(newMapping);
  });
  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var sourceRelative = sourceFile;

    if (sourceRoot !== null) {
      sourceRelative = util.relative(sourceRoot, sourceFile);
    }

    if (!generator._sources.has(sourceRelative)) {
      generator._sources.add(sourceRelative);
    }

    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      generator.setSourceContent(sourceFile, content);
    }
  });
  return generator;
};
/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */


SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
  var generated = util.getArg(aArgs, 'generated');
  var original = util.getArg(aArgs, 'original', null);
  var source = util.getArg(aArgs, 'source', null);
  var name = util.getArg(aArgs, 'name', null);

  if (!this._skipValidation) {
    this._validateMapping(generated, original, source, name);
  }

  if (source != null) {
    source = String(source);

    if (!this._sources.has(source)) {
      this._sources.add(source);
    }
  }

  if (name != null) {
    name = String(name);

    if (!this._names.has(name)) {
      this._names.add(name);
    }
  }

  this._mappings.add({
    generatedLine: generated.line,
    generatedColumn: generated.column,
    originalLine: original != null && original.line,
    originalColumn: original != null && original.column,
    source: source,
    name: name
  });
};
/**
 * Set the source content for a source file.
 */


SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
  var source = aSourceFile;

  if (this._sourceRoot != null) {
    source = util.relative(this._sourceRoot, source);
  }

  if (aSourceContent != null) {
    // Add the source content to the _sourcesContents map.
    // Create a new _sourcesContents map if the property is null.
    if (!this._sourcesContents) {
      this._sourcesContents = Object.create(null);
    }

    this._sourcesContents[util.toSetString(source)] = aSourceContent;
  } else if (this._sourcesContents) {
    // Remove the source file from the _sourcesContents map.
    // If the _sourcesContents map is empty, set the property to null.
    delete this._sourcesContents[util.toSetString(source)];

    if (Object.keys(this._sourcesContents).length === 0) {
      this._sourcesContents = null;
    }
  }
};
/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */


SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
  var sourceFile = aSourceFile; // If aSourceFile is omitted, we will use the file property of the SourceMap

  if (aSourceFile == null) {
    if (aSourceMapConsumer.file == null) {
      throw new Error('SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' + 'or the source map\'s "file" property. Both were omitted.');
    }

    sourceFile = aSourceMapConsumer.file;
  }

  var sourceRoot = this._sourceRoot; // Make "sourceFile" relative if an absolute Url is passed.

  if (sourceRoot != null) {
    sourceFile = util.relative(sourceRoot, sourceFile);
  } // Applying the SourceMap can add and remove items from the sources and
  // the names array.


  var newSources = new ArraySet();
  var newNames = new ArraySet(); // Find mappings for the "sourceFile"

  this._mappings.unsortedForEach(function (mapping) {
    if (mapping.source === sourceFile && mapping.originalLine != null) {
      // Check if it can be mapped by the source map, then update the mapping.
      var original = aSourceMapConsumer.originalPositionFor({
        line: mapping.originalLine,
        column: mapping.originalColumn
      });

      if (original.source != null) {
        // Copy mapping
        mapping.source = original.source;

        if (aSourceMapPath != null) {
          mapping.source = util.join(aSourceMapPath, mapping.source);
        }

        if (sourceRoot != null) {
          mapping.source = util.relative(sourceRoot, mapping.source);
        }

        mapping.originalLine = original.line;
        mapping.originalColumn = original.column;

        if (original.name != null) {
          mapping.name = original.name;
        }
      }
    }

    var source = mapping.source;

    if (source != null && !newSources.has(source)) {
      newSources.add(source);
    }

    var name = mapping.name;

    if (name != null && !newNames.has(name)) {
      newNames.add(name);
    }
  }, this);

  this._sources = newSources;
  this._names = newNames; // Copy sourcesContents of applied map.

  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aSourceMapPath != null) {
        sourceFile = util.join(aSourceMapPath, sourceFile);
      }

      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }

      this.setSourceContent(sourceFile, content);
    }
  }, this);
};
/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */


SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
  // When aOriginal is truthy but has empty values for .line and .column,
  // it is most likely a programmer error. In this case we throw a very
  // specific error message to try to guide them the right way.
  // For example: https://github.com/Polymer/polymer-bundler/pull/519
  if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
    throw new Error('original.line and original.column are not numbers -- you probably meant to omit ' + 'the original mapping entirely and only map the generated position. If so, pass ' + 'null for the original mapping instead of an object with empty or null values.');
  }

  if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
    // Case 1.
    return;
  } else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated && aOriginal && 'line' in aOriginal && 'column' in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
    // Cases 2 and 3.
    return;
  } else {
    throw new Error('Invalid mapping: ' + JSON.stringify({
      generated: aGenerated,
      source: aSource,
      original: aOriginal,
      name: aName
    }));
  }
};
/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */


SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
  var previousGeneratedColumn = 0;
  var previousGeneratedLine = 1;
  var previousOriginalColumn = 0;
  var previousOriginalLine = 0;
  var previousName = 0;
  var previousSource = 0;
  var result = '';
  var next;
  var mapping;
  var nameIdx;
  var sourceIdx;

  var mappings = this._mappings.toArray();

  for (var i = 0, len = mappings.length; i < len; i++) {
    mapping = mappings[i];
    next = '';

    if (mapping.generatedLine !== previousGeneratedLine) {
      previousGeneratedColumn = 0;

      while (mapping.generatedLine !== previousGeneratedLine) {
        next += ';';
        previousGeneratedLine++;
      }
    } else {
      if (i > 0) {
        if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
          continue;
        }

        next += ',';
      }
    }

    next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
    previousGeneratedColumn = mapping.generatedColumn;

    if (mapping.source != null) {
      sourceIdx = this._sources.indexOf(mapping.source);
      next += base64VLQ.encode(sourceIdx - previousSource);
      previousSource = sourceIdx; // lines are stored 0-based in SourceMap spec version 3

      next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
      previousOriginalLine = mapping.originalLine - 1;
      next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
      previousOriginalColumn = mapping.originalColumn;

      if (mapping.name != null) {
        nameIdx = this._names.indexOf(mapping.name);
        next += base64VLQ.encode(nameIdx - previousName);
        previousName = nameIdx;
      }
    }

    result += next;
  }

  return result;
};

SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
  return aSources.map(function (source) {
    if (!this._sourcesContents) {
      return null;
    }

    if (aSourceRoot != null) {
      source = util.relative(aSourceRoot, source);
    }

    var key = util.toSetString(source);
    return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
  }, this);
};
/**
 * Externalize the source map.
 */


SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
  var map = {
    version: this._version,
    sources: this._sources.toArray(),
    names: this._names.toArray(),
    mappings: this._serializeMappings()
  };

  if (this._file != null) {
    map.file = this._file;
  }

  if (this._sourceRoot != null) {
    map.sourceRoot = this._sourceRoot;
  }

  if (this._sourcesContents) {
    map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
  }

  return map;
};
/**
 * Render the source map being generated to a string.
 */


SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
  return JSON.stringify(this.toJSON());
};

exports.SourceMapGenerator = SourceMapGenerator;

/***/ }),

/***/ "../node_modules/source-map/lib/source-node.js":
/*!*****************************************************!*\
  !*** ../node_modules/source-map/lib/source-node.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
var SourceMapGenerator = __webpack_require__(/*! ./source-map-generator */ "../node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;

var util = __webpack_require__(/*! ./util */ "../node_modules/source-map/lib/util.js"); // Matches a Windows-style `\r\n` newline or a `\n` newline used by all other
// operating systems these days (capturing the result).


var REGEX_NEWLINE = /(\r?\n)/; // Newline character code for charCodeAt() comparisons

var NEWLINE_CODE = 10; // Private symbol for identifying `SourceNode`s when multiple versions of
// the source-map library are loaded. This MUST NOT CHANGE across
// versions!

var isSourceNode = "$$$isSourceNode$$$";
/**
 * SourceNodes provide a way to abstract over interpolating/concatenating
 * snippets of generated JavaScript source code while maintaining the line and
 * column information associated with the original source code.
 *
 * @param aLine The original line number.
 * @param aColumn The original column number.
 * @param aSource The original source's filename.
 * @param aChunks Optional. An array of strings which are snippets of
 *        generated JS, or other SourceNodes.
 * @param aName The original identifier.
 */

function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
  this.children = [];
  this.sourceContents = {};
  this.line = aLine == null ? null : aLine;
  this.column = aColumn == null ? null : aColumn;
  this.source = aSource == null ? null : aSource;
  this.name = aName == null ? null : aName;
  this[isSourceNode] = true;
  if (aChunks != null) this.add(aChunks);
}
/**
 * Creates a SourceNode from generated code and a SourceMapConsumer.
 *
 * @param aGeneratedCode The generated code
 * @param aSourceMapConsumer The SourceMap for the generated code
 * @param aRelativePath Optional. The path that relative sources in the
 *        SourceMapConsumer should be relative to.
 */


SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
  // The SourceNode we want to fill with the generated code
  // and the SourceMap
  var node = new SourceNode(); // All even indices of this array are one line of the generated code,
  // while all odd indices are the newlines between two adjacent lines
  // (since `REGEX_NEWLINE` captures its match).
  // Processed fragments are accessed by calling `shiftNextLine`.

  var remainingLines = aGeneratedCode.split(REGEX_NEWLINE);
  var remainingLinesIndex = 0;

  var shiftNextLine = function shiftNextLine() {
    var lineContents = getNextLine(); // The last line of a file might not have a newline.

    var newLine = getNextLine() || "";
    return lineContents + newLine;

    function getNextLine() {
      return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : undefined;
    }
  }; // We need to remember the position of "remainingLines"


  var lastGeneratedLine = 1,
      lastGeneratedColumn = 0; // The generate SourceNodes we need a code range.
  // To extract it current and last mapping is used.
  // Here we store the last mapping.

  var lastMapping = null;
  aSourceMapConsumer.eachMapping(function (mapping) {
    if (lastMapping !== null) {
      // We add the code from "lastMapping" to "mapping":
      // First check if there is a new line in between.
      if (lastGeneratedLine < mapping.generatedLine) {
        // Associate first line with "lastMapping"
        addMappingWithCode(lastMapping, shiftNextLine());
        lastGeneratedLine++;
        lastGeneratedColumn = 0; // The remaining code is added without mapping
      } else {
        // There is no new line in between.
        // Associate the code between "lastGeneratedColumn" and
        // "mapping.generatedColumn" with "lastMapping"
        var nextLine = remainingLines[remainingLinesIndex] || '';
        var code = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
        addMappingWithCode(lastMapping, code); // No more remaining code, continue

        lastMapping = mapping;
        return;
      }
    } // We add the generated code until the first mapping
    // to the SourceNode without any mapping.
    // Each line is added as separate string.


    while (lastGeneratedLine < mapping.generatedLine) {
      node.add(shiftNextLine());
      lastGeneratedLine++;
    }

    if (lastGeneratedColumn < mapping.generatedColumn) {
      var nextLine = remainingLines[remainingLinesIndex] || '';
      node.add(nextLine.substr(0, mapping.generatedColumn));
      remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
      lastGeneratedColumn = mapping.generatedColumn;
    }

    lastMapping = mapping;
  }, this); // We have processed all mappings.

  if (remainingLinesIndex < remainingLines.length) {
    if (lastMapping) {
      // Associate the remaining code in the current line with "lastMapping"
      addMappingWithCode(lastMapping, shiftNextLine());
    } // and add the remaining lines without any mapping


    node.add(remainingLines.splice(remainingLinesIndex).join(""));
  } // Copy sourcesContent into SourceNode


  aSourceMapConsumer.sources.forEach(function (sourceFile) {
    var content = aSourceMapConsumer.sourceContentFor(sourceFile);

    if (content != null) {
      if (aRelativePath != null) {
        sourceFile = util.join(aRelativePath, sourceFile);
      }

      node.setSourceContent(sourceFile, content);
    }
  });
  return node;

  function addMappingWithCode(mapping, code) {
    if (mapping === null || mapping.source === undefined) {
      node.add(code);
    } else {
      var source = aRelativePath ? util.join(aRelativePath, mapping.source) : mapping.source;
      node.add(new SourceNode(mapping.originalLine, mapping.originalColumn, source, code, mapping.name));
    }
  }
};
/**
 * Add a chunk of generated JS to this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.add = function SourceNode_add(aChunk) {
  if (Array.isArray(aChunk)) {
    aChunk.forEach(function (chunk) {
      this.add(chunk);
    }, this);
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    if (aChunk) {
      this.children.push(aChunk);
    }
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Add a chunk of generated JS to the beginning of this source node.
 *
 * @param aChunk A string snippet of generated JS code, another instance of
 *        SourceNode, or an array where each member is one of those things.
 */


SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
  if (Array.isArray(aChunk)) {
    for (var i = aChunk.length - 1; i >= 0; i--) {
      this.prepend(aChunk[i]);
    }
  } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
    this.children.unshift(aChunk);
  } else {
    throw new TypeError("Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk);
  }

  return this;
};
/**
 * Walk over the tree of JS snippets in this node and its children. The
 * walking function is called once for each snippet of JS and is passed that
 * snippet and the its original associated source's line/column location.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walk = function SourceNode_walk(aFn) {
  var chunk;

  for (var i = 0, len = this.children.length; i < len; i++) {
    chunk = this.children[i];

    if (chunk[isSourceNode]) {
      chunk.walk(aFn);
    } else {
      if (chunk !== '') {
        aFn(chunk, {
          source: this.source,
          line: this.line,
          column: this.column,
          name: this.name
        });
      }
    }
  }
};
/**
 * Like `String.prototype.join` except for SourceNodes. Inserts `aStr` between
 * each of `this.children`.
 *
 * @param aSep The separator.
 */


SourceNode.prototype.join = function SourceNode_join(aSep) {
  var newChildren;
  var i;
  var len = this.children.length;

  if (len > 0) {
    newChildren = [];

    for (i = 0; i < len - 1; i++) {
      newChildren.push(this.children[i]);
      newChildren.push(aSep);
    }

    newChildren.push(this.children[i]);
    this.children = newChildren;
  }

  return this;
};
/**
 * Call String.prototype.replace on the very right-most source snippet. Useful
 * for trimming whitespace from the end of a source node, etc.
 *
 * @param aPattern The pattern to replace.
 * @param aReplacement The thing to replace the pattern with.
 */


SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
  var lastChild = this.children[this.children.length - 1];

  if (lastChild[isSourceNode]) {
    lastChild.replaceRight(aPattern, aReplacement);
  } else if (typeof lastChild === 'string') {
    this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
  } else {
    this.children.push(''.replace(aPattern, aReplacement));
  }

  return this;
};
/**
 * Set the source content for a source file. This will be added to the SourceMapGenerator
 * in the sourcesContent field.
 *
 * @param aSourceFile The filename of the source file
 * @param aSourceContent The content of the source file
 */


SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
  this.sourceContents[util.toSetString(aSourceFile)] = aSourceContent;
};
/**
 * Walk over the tree of SourceNodes. The walking function is called for each
 * source file content and is passed the filename and source content.
 *
 * @param aFn The traversal function.
 */


SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
  for (var i = 0, len = this.children.length; i < len; i++) {
    if (this.children[i][isSourceNode]) {
      this.children[i].walkSourceContents(aFn);
    }
  }

  var sources = Object.keys(this.sourceContents);

  for (var i = 0, len = sources.length; i < len; i++) {
    aFn(util.fromSetString(sources[i]), this.sourceContents[sources[i]]);
  }
};
/**
 * Return the string representation of this source node. Walks over the tree
 * and concatenates all the various snippets together to one string.
 */


SourceNode.prototype.toString = function SourceNode_toString() {
  var str = "";
  this.walk(function (chunk) {
    str += chunk;
  });
  return str;
};
/**
 * Returns the string representation of this source node along with a source
 * map.
 */


SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
  var generated = {
    code: "",
    line: 1,
    column: 0
  };
  var map = new SourceMapGenerator(aArgs);
  var sourceMappingActive = false;
  var lastOriginalSource = null;
  var lastOriginalLine = null;
  var lastOriginalColumn = null;
  var lastOriginalName = null;
  this.walk(function (chunk, original) {
    generated.code += chunk;

    if (original.source !== null && original.line !== null && original.column !== null) {
      if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
        map.addMapping({
          source: original.source,
          original: {
            line: original.line,
            column: original.column
          },
          generated: {
            line: generated.line,
            column: generated.column
          },
          name: original.name
        });
      }

      lastOriginalSource = original.source;
      lastOriginalLine = original.line;
      lastOriginalColumn = original.column;
      lastOriginalName = original.name;
      sourceMappingActive = true;
    } else if (sourceMappingActive) {
      map.addMapping({
        generated: {
          line: generated.line,
          column: generated.column
        }
      });
      lastOriginalSource = null;
      sourceMappingActive = false;
    }

    for (var idx = 0, length = chunk.length; idx < length; idx++) {
      if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
        generated.line++;
        generated.column = 0; // Mappings end at eol

        if (idx + 1 === length) {
          lastOriginalSource = null;
          sourceMappingActive = false;
        } else if (sourceMappingActive) {
          map.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
      } else {
        generated.column++;
      }
    }
  });
  this.walkSourceContents(function (sourceFile, sourceContent) {
    map.setSourceContent(sourceFile, sourceContent);
  });
  return {
    code: generated.code,
    map: map
  };
};

exports.SourceNode = SourceNode;

/***/ }),

/***/ "../node_modules/source-map/lib/util.js":
/*!**********************************************!*\
  !*** ../node_modules/source-map/lib/util.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* -*- Mode: js; js-indent-level: 2; -*- */

/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}

exports.getArg = getArg;
var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);

  if (!match) {
    return null;
  }

  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}

exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';

  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }

  url += '//';

  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }

  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }

  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port;
  }

  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }

  return url;
}

exports.urlGenerate = urlGenerate;
/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */

function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);

  if (url) {
    if (!url.path) {
      return aPath;
    }

    path = url.path;
  }

  var isAbsolute = exports.isAbsolute(path);
  var parts = path.split(/\/+/);

  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];

    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }

  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }

  return path;
}

exports.normalize = normalize;
/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */

function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  if (aPath === "") {
    aPath = ".";
  }

  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);

  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  } // `join(foo, '//www.example.org')`


  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }

    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  } // `join('http://', 'www.example.com')`


  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/' ? aPath : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }

  return joined;
}

exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};
/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */


function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, ''); // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.

  var level = 0;

  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");

    if (index < 0) {
      return aPath;
    } // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.


    aRoot = aRoot.slice(0, index);

    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  } // Make sure we add a "../" for each component we removed from the root.


  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}

exports.relative = relative;

var supportsNullProto = function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}();

function identity(s) {
  return s;
}
/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */


function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}

exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}

exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9
  /* "__proto__".length */
  ) {
      return false;
    }

  if (s.charCodeAt(length - 1) !== 95
  /* '_' */
  || s.charCodeAt(length - 2) !== 95
  /* '_' */
  || s.charCodeAt(length - 3) !== 111
  /* 'o' */
  || s.charCodeAt(length - 4) !== 116
  /* 't' */
  || s.charCodeAt(length - 5) !== 111
  /* 'o' */
  || s.charCodeAt(length - 6) !== 114
  /* 'r' */
  || s.charCodeAt(length - 7) !== 112
  /* 'p' */
  || s.charCodeAt(length - 8) !== 95
  /* '_' */
  || s.charCodeAt(length - 9) !== 95
  /* '_' */
  ) {
      return false;
    }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36
    /* '$' */
    ) {
        return false;
      }
  }

  return true;
}
/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */


function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByOriginalPositions = compareByOriginalPositions;
/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */

function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}
/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */


function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;

  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;

  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}

exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */

function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}

exports.parseSourceMapInput = parseSourceMapInput;
/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */

function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    } // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   “sources” entry.  This value is prepended to the individual
    //   entries in the “source” field.


    sourceURL = sourceRoot + sourceURL;
  } // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   “sourceRoot”, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).


  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);

    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }

    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');

      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }

    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}

exports.computeSourceURL = computeSourceURL;

/***/ }),

/***/ "../node_modules/source-map/source-map.js":
/*!************************************************!*\
  !*** ../node_modules/source-map/source-map.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * Copyright 2009-2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE.txt or:
 * http://opensource.org/licenses/BSD-3-Clause
 */
exports.SourceMapGenerator = __webpack_require__(/*! ./lib/source-map-generator */ "../node_modules/source-map/lib/source-map-generator.js").SourceMapGenerator;
exports.SourceMapConsumer = __webpack_require__(/*! ./lib/source-map-consumer */ "../node_modules/source-map/lib/source-map-consumer.js").SourceMapConsumer;
exports.SourceNode = __webpack_require__(/*! ./lib/source-node */ "../node_modules/source-map/lib/source-node.js").SourceNode;

/***/ }),

/***/ "../node_modules/terser/dist/bundle.min.js":
/*!*************************************************!*\
  !*** ../node_modules/terser/dist/bundle.min.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, Buffer) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) { return; } var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }

function isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }

function _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }

function _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

!function (e, t) {
  "object" == ( false ? undefined : _typeof(exports)) && "undefined" != typeof module ? t(exports, __webpack_require__(/*! source-map */ "../node_modules/source-map/source-map.js")) :  true ? !(__WEBPACK_AMD_DEFINE_ARRAY__ = [exports, __webpack_require__(/*! source-map */ "../node_modules/source-map/source-map.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (t),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : undefined;
}(this, function (e, t) {
  "use strict";

  function n(e) {
    return e.split("");
  }

  function i(e, t) {
    return t.includes(e);
  }

  t = t && t.hasOwnProperty("default") ? t.default : t;

  var r =
  /*#__PURE__*/
  function (_Error) {
    _inherits(r, _Error);

    function r(e, t) {
      var _this;

      _classCallCheck(this, r);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(r).call(this)), _this.name = "DefaultsError", _this.message = e, _this.defs = t;
      return _this;
    }

    return r;
  }(_wrapNativeSuper(Error));

  function o(e, t, n) {
    !0 === e && (e = {});
    var i = e || {};
    if (n) for (var o in i) {
      if (D(i, o) && !D(t, o)) throw new r("`" + o + "` is not a supported option", t);
    }

    for (var o in t) {
      D(t, o) && (i[o] = e && D(e, o) ? e[o] : t[o]);
    }

    return i;
  }

  function a() {}

  function s() {
    return !1;
  }

  function u() {
    return !0;
  }

  function c() {
    return this;
  }

  function l() {
    return null;
  }

  var f = function () {
    function e(e, o, a) {
      var s,
          u = [],
          c = [];

      function l() {
        var l = o(e[s], s),
            f = l instanceof r;
        return f && (l = l.v), l instanceof n ? (l = l.v) instanceof i ? c.push.apply(c, a ? l.v.slice().reverse() : l.v) : c.push(l) : l !== t && (l instanceof i ? u.push.apply(u, a ? l.v.slice().reverse() : l.v) : u.push(l)), f;
      }

      if (Array.isArray(e)) {
        if (a) {
          for (s = e.length; --s >= 0 && !l();) {
            ;
          }

          u.reverse(), c.reverse();
        } else for (s = 0; s < e.length && !l(); ++s) {
          ;
        }
      } else for (s in e) {
        if (D(e, s) && l()) break;
      }
      return c.concat(u);
    }

    e.at_top = function (e) {
      return new n(e);
    }, e.splice = function (e) {
      return new i(e);
    }, e.last = function (e) {
      return new r(e);
    };
    var t = e.skip = {};

    function n(e) {
      this.v = e;
    }

    function i(e) {
      this.v = e;
    }

    function r(e) {
      this.v = e;
    }

    return e;
  }();

  function p(e, t) {
    e.includes(t) || e.push(t);
  }

  function _(e, t) {
    return e.replace(/{(.+?)}/g, function (e, n) {
      return t && t[n];
    });
  }

  function d(e, t) {
    for (var n = e.length; --n >= 0;) {
      e[n] === t && e.splice(n, 1);
    }
  }

  function m(e, t) {
    if (e.length < 2) return e.slice();
    return function e(n) {
      if (n.length <= 1) return n;
      var i = Math.floor(n.length / 2),
          r = n.slice(0, i),
          o = n.slice(i);
      return function (e, n) {
        for (var i = [], r = 0, o = 0, a = 0; r < e.length && o < n.length;) {
          t(e[r], n[o]) <= 0 ? i[a++] = e[r++] : i[a++] = n[o++];
        }

        return r < e.length && i.push.apply(i, e.slice(r)), o < n.length && i.push.apply(i, n.slice(o)), i;
      }(r = e(r), o = e(o));
    }(e);
  }

  function E(e) {
    return Array.isArray(e) || (e = e.split(" ")), new Set(e);
  }

  function h(e, t, n) {
    e.has(t) ? e.get(t).push(n) : e.set(t, [n]);
  }

  function D(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t);
  }

  function g(e, t) {
    return !0 === e || e instanceof RegExp && e.test(t);
  }

  var S = {
    "\n": "n",
    "\r": "r",
    "\u2028": "u2028",
    "\u2029": "u2029"
  };

  function A(e) {
    return e.replace(/[\n\r\u2028\u2029]/g, function (t, n) {
      return ("\\" == e[n - 1] && ("\\" != e[n - 2] || /(?:^|[^\\])(?:\\{2})*$/.test(e.slice(0, n - 1))) ? "" : "\\") + S[t];
    });
  }

  var v = "gimuy";

  function T(e, t) {
    return e._annotations & t;
  }

  function b(e, t) {
    e._annotations |= t;
  }

  var y = "break case catch class const continue debugger default delete do else export extends finally for function if in instanceof let new return switch throw try typeof var void while with",
      C = "false null true",
      O = "enum implements import interface package private protected public static super this " + C + " " + y,
      F = "return new delete throw else case yield await";
  y = E(y), O = E(O), F = E(F), C = E(C);
  var M = E(n("+-*&%=<>!?|~^")),
      R = /[0-9a-f]/i,
      w = /^0x[0-9a-f]+$/i,
      N = /^0[0-7]+$/,
      x = /^0o[0-7]+$/i,
      k = /^0b[01]+$/i,
      I = /^\d*\.?\d*(?:e[+-]?\d*(?:\d\.?|\.?\d)\d*)?$/i,
      L = /^(0[xob])?[0-9]+n$/i,
      V = E(["in", "instanceof", "typeof", "new", "void", "delete", "++", "--", "+", "-", "!", "~", "&", "|", "^", "*", "**", "/", "%", ">>", "<<", ">>>", "<", ">", "<=", ">=", "==", "===", "!=", "!==", "?", "=", "+=", "-=", "/=", "*=", "**=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&=", "&&", "||"]),
      P = E(n(" \xA0\n\r\t\f\x0B\u200B\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF")),
      B = E(n("\n\r\u2028\u2029")),
      K = E(n(";]),:")),
      U = E(n("[{(,;:")),
      G = E(n("[]{}(),;:")),
      H = {
    ID_Start: /[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    ID_Continue: /[0-9A-Z_a-z\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };

  function X(e, t) {
    var n = e.charAt(t);

    if (z(n)) {
      var i = e.charAt(t + 1);
      if (W(i)) return n + i;
    }

    if (W(n)) {
      var r = e.charAt(t - 1);
      if (z(r)) return r + n;
    }

    return n;
  }

  function z(e) {
    return "string" == typeof e && (e = e.charCodeAt(0)), e >= 55296 && e <= 56319;
  }

  function W(e) {
    return "string" == typeof e && (e = e.charCodeAt(0)), e >= 56320 && e <= 57343;
  }

  function Y(e) {
    return e >= 48 && e <= 57;
  }

  function q(e) {
    var t = e.charCodeAt(0);
    return H.ID_Start.test(e) || 36 == t || 95 == t;
  }

  function $(e) {
    var t = e.charCodeAt(0);
    return H.ID_Continue.test(e) || 36 == t || 95 == t || 8204 == t || 8205 == t;
  }

  function j(e) {
    return /^[a-z_$][a-z0-9_$]*$/i.test(e);
  }

  var Z =
  /*#__PURE__*/
  function (_Error2) {
    _inherits(Z, _Error2);

    function Z(e, t, n, i, r) {
      var _this2;

      _classCallCheck(this, Z);

      _this2 = _possibleConstructorReturn(this, _getPrototypeOf(Z).call(this)), _this2.name = "SyntaxError", _this2.message = e, _this2.filename = t, _this2.line = n, _this2.col = i, _this2.pos = r;
      return _this2;
    }

    return Z;
  }(_wrapNativeSuper(Error));

  function J(e, t, n, i, r) {
    throw new Z(e, t, n, i, r);
  }

  function Q(e, t, n) {
    return e.type == t && (null == n || e.value == n);
  }

  var ee = {};

  function te(e, t, n, i) {
    var r = {
      text: e,
      filename: t,
      pos: 0,
      tokpos: 0,
      line: 1,
      tokline: 0,
      col: 0,
      tokcol: 0,
      newline_before: !1,
      regex_allowed: !1,
      brace_counter: 0,
      template_braces: [],
      comments_before: [],
      directives: {},
      directive_stack: []
    };

    function o() {
      return X(r.text, r.pos);
    }

    function a(e, t) {
      var n = X(r.text, r.pos++);
      if (e && !n) throw ee;
      return B.has(n) ? (r.newline_before = r.newline_before || !t, ++r.line, r.col = 0, "\r" == n && "\n" == o() && (++r.pos, n = "\n")) : (n.length > 1 && (++r.pos, ++r.col), ++r.col), n;
    }

    function s(e) {
      for (; e-- > 0;) {
        a();
      }
    }

    function u(e) {
      return r.text.substr(r.pos, e.length) == e;
    }

    function c(e, t) {
      var n = r.text.indexOf(e, r.pos);
      if (t && -1 == n) throw ee;
      return n;
    }

    function l() {
      r.tokline = r.line, r.tokcol = r.col, r.tokpos = r.pos;
    }

    var f = !1,
        p = null;

    function _(n, i, o) {
      r.regex_allowed = "operator" == n && !ie.has(i) || "keyword" == n && F.has(i) || "punc" == n && U.has(i) || "arrow" == n, "punc" == n && "." == i ? f = !0 : o || (f = !1);
      var a = {
        type: n,
        value: i,
        line: r.tokline,
        col: r.tokcol,
        pos: r.tokpos,
        endline: r.line,
        endcol: r.col,
        endpos: r.pos,
        nlb: r.newline_before,
        file: t
      };
      return /^(?:num|string|regexp)$/i.test(n) && (a.raw = e.substring(a.pos, a.endpos)), o || (a.comments_before = r.comments_before, a.comments_after = r.comments_before = []), r.newline_before = !1, a = new ce(a), o || (p = a), a;
    }

    function d() {
      for (; P.has(o());) {
        a();
      }
    }

    function m(e) {
      J(e, t, r.tokline, r.tokcol, r.tokpos);
    }

    function E(e) {
      var t = !1,
          n = !1,
          i = !1,
          r = "." == e,
          s = !1,
          u = function (e) {
        for (var t, n = "", i = 0; (t = o()) && e(t, i++);) {
          n += a();
        }

        return n;
      }(function (o, a) {
        if (s) return !1;

        switch (o.charCodeAt(0)) {
          case 98:
          case 66:
            return i = !0;

          case 111:
          case 79:
          case 120:
          case 88:
            return !i && (i = !0);

          case 101:
          case 69:
            return !!i || !t && (t = n = !0);

          case 45:
            return n || 0 == a && !e;

          case 43:
            return n;

          case (n = !1, 46):
            return !(r || i || t) && (r = !0);
        }

        return "n" === o ? (s = !0, !0) : R.test(o);
      });

      if (e && (u = e + u), N.test(u) && Q.has_directive("use strict") && m("Legacy octal literals are not allowed in strict mode"), u.endsWith("n")) {
        if (!r && L.test(u)) return _("big_int", u.replace("n", ""));
        m("Invalid or unexpected token");
      }

      var c = function (e) {
        if (w.test(e)) return parseInt(e.substr(2), 16);
        if (N.test(e)) return parseInt(e.substr(1), 8);
        if (x.test(e)) return parseInt(e.substr(2), 8);
        if (k.test(e)) return parseInt(e.substr(2), 2);
        if (I.test(e)) return parseFloat(e);
        var t = parseFloat(e);
        return t == e ? t : void 0;
      }(u);

      if (!isNaN(c)) return _("num", c);
      m("Invalid syntax: " + u);
    }

    function h(e) {
      return e >= "0" && e <= "7";
    }

    function D(e, t, n) {
      var i,
          s = a(!0, e);

      switch (s.charCodeAt(0)) {
        case 110:
          return "\n";

        case 114:
          return "\r";

        case 116:
          return "\t";

        case 98:
          return "\b";

        case 118:
          return "\v";

        case 102:
          return "\f";

        case 120:
          return String.fromCharCode(g(2, t));

        case 117:
          if ("{" == o()) {
            for (a(!0), "}" === o() && m("Expecting hex-character between {}"); "0" == o();) {
              a(!0);
            }

            var u,
                l = c("}", !0) - r.pos;
            return (l > 6 || (u = g(l, t)) > 1114111) && m("Unicode reference out of bounds"), a(!0), (i = u) > 65535 ? (i -= 65536, String.fromCharCode(55296 + (i >> 10)) + String.fromCharCode(i % 1024 + 56320)) : String.fromCharCode(i);
          }

          return String.fromCharCode(g(4, t));

        case 10:
          return "";

        case 13:
          if ("\n" == o()) return a(!0, e), "";
      }

      if (h(s)) {
        if (n && t) {
          "0" === s && !h(o()) || m("Octal escape sequences are not allowed in template strings");
        }

        return function (e, t) {
          var n = o();
          n >= "0" && n <= "7" && (e += a(!0))[0] <= "3" && (n = o()) >= "0" && n <= "7" && (e += a(!0));
          if ("0" === e) return "\0";
          e.length > 0 && Q.has_directive("use strict") && t && m("Legacy octal escape sequences are not allowed in strict mode");
          return String.fromCharCode(parseInt(e, 8));
        }(s, t);
      }

      return s;
    }

    function g(e, t) {
      for (var n = 0; e > 0; --e) {
        if (!t && isNaN(parseInt(o(), 16))) return parseInt(n, 16) || "";
        var i = a(!0);
        isNaN(parseInt(i, 16)) && m("Invalid hex-character pattern in string"), n += i;
      }

      return parseInt(n, 16);
    }

    var S = Z("Unterminated string constant", function () {
      for (var e = a(), t = "";;) {
        var n = a(!0, !0);
        if ("\\" == n) n = D(!0, !0);else if ("\r" == n || "\n" == n) m("Unterminated string constant");else if (n == e) break;
        t += n;
      }

      var i = _("string", t);

      return i.quote = e, i;
    }),
        A = Z("Unterminated template", function (e) {
      e && r.template_braces.push(r.brace_counter);
      var t,
          n,
          i = "",
          s = "";

      for (a(!0, !0); "`" != (t = a(!0, !0));) {
        if ("\r" == t) "\n" == o() && ++r.pos, t = "\n";else if ("$" == t && "{" == o()) return a(!0, !0), r.brace_counter++, (n = _(e ? "template_head" : "template_substitution", i)).raw = s, n;

        if (s += t, "\\" == t) {
          var u = r.pos;
          t = D(!0, !(p && ("name" === p.type || "punc" === p.type && (")" === p.value || "]" === p.value))), !0), s += r.text.substr(u, r.pos - u);
        }

        i += t;
      }

      return r.template_braces.pop(), (n = _(e ? "template_head" : "template_substitution", i)).raw = s, n.end = !0, n;
    });

    function v(e) {
      var t,
          n = r.regex_allowed,
          i = function () {
        for (var e = r.text, t = r.pos, n = r.text.length; t < n; ++t) {
          var i = e[t];
          if (B.has(i)) return t;
        }

        return -1;
      }();

      return -1 == i ? (t = r.text.substr(r.pos), r.pos = r.text.length) : (t = r.text.substring(r.pos, i), r.pos = i), r.col = r.tokcol + (r.pos - r.tokpos), r.comments_before.push(_(e, t, !0)), r.regex_allowed = n, Q;
    }

    var T = Z("Unterminated multiline comment", function () {
      var e = r.regex_allowed,
          t = c("*/", !0),
          n = r.text.substring(r.pos, t).replace(/\r\n|\r|\u2028|\u2029/g, "\n");
      return s(function (e) {
        for (var t = 0, n = 0; n < e.length; n++) {
          z(e.charCodeAt(n)) && W(e.charCodeAt(n + 1)) && (t++, n++);
        }

        return e.length - t;
      }(n) + 2), r.comments_before.push(_("comment2", n, !0)), r.newline_before = r.newline_before || n.includes("\n"), r.regex_allowed = e, Q;
    }),
        b = Z("Unterminated identifier name", function () {
      var e,
          t,
          n = !1,
          i = function i() {
        return n = !0, a(), "u" !== o() && m("Expecting UnicodeEscapeSequence -- uXXXX or u{XXXX}"), D(!1, !0);
      };

      if ("\\" === (e = o())) q(e = i()) || m("First identifier char is an invalid identifier char");else {
        if (!q(e)) return "";
        a();
      }

      for (; null != (t = o());) {
        if ("\\" === (t = o())) $(t = i()) || m("Invalid escaped identifier char");else {
          if (!$(t)) break;
          a();
        }
        e += t;
      }

      return O.has(e) && n && m("Escaped characters are not allowed in keywords"), e;
    }),
        K = Z("Unterminated regular expression", function (e) {
      for (var t, n = !1, i = !1; t = a(!0);) {
        if (B.has(t)) m("Unexpected line terminator");else if (n) e += "\\" + t, n = !1;else if ("[" == t) i = !0, e += t;else if ("]" == t && i) i = !1, e += t;else {
          if ("/" == t && !i) break;
          "\\" == t ? n = !0 : e += t;
        }
      }

      return _("regexp", {
        source: e,
        flags: b()
      });
    });

    function H(e) {
      return _("operator", function e(t) {
        if (!o()) return t;
        var n = t + o();
        return V.has(n) ? (a(), e(n)) : t;
      }(e || a()));
    }

    function j() {
      switch (a(), o()) {
        case "/":
          return a(), v("comment1");

        case "*":
          return a(), T();
      }

      return r.regex_allowed ? K("") : H("/");
    }

    function Z(e, t) {
      return function (n) {
        try {
          return t(n);
        } catch (t) {
          if (t !== ee) throw t;
          m(e);
        }
      };
    }

    function Q(e) {
      if (null != e) return K(e);

      for (i && 0 == r.pos && u("#!") && (l(), s(2), v("comment5"));;) {
        if (d(), l(), n) {
          if (u("\x3c!--")) {
            s(4), v("comment3");
            continue;
          }

          if (u("--\x3e") && r.newline_before) {
            s(3), v("comment4");
            continue;
          }
        }

        var t = o();
        if (!t) return _("eof");
        var c = t.charCodeAt(0);

        switch (c) {
          case 34:
          case 39:
            return S();

          case 46:
            return a(), Y(o().charCodeAt(0)) ? E(".") : "." === o() ? (a(), a(), _("expand", "...")) : _("punc", ".");

          case 47:
            var p = j();
            if (p === Q) continue;
            return p;

          case 61:
            return a(), ">" === o() ? (a(), _("arrow", "=>")) : H("=");

          case 96:
            return A(!0);

          case 123:
            r.brace_counter++;
            break;

          case 125:
            if (r.brace_counter--, r.template_braces.length > 0 && r.template_braces[r.template_braces.length - 1] === r.brace_counter) return A(!1);
        }

        if (Y(c)) return E();
        if (G.has(t)) return _("punc", a());
        if (M.has(t)) return H();
        if (92 == c || q(t)) return h = void 0, h = b(), f ? _("name", h) : C.has(h) ? _("atom", h) : y.has(h) ? V.has(h) ? _("operator", h) : _("keyword", h) : _("name", h);
        break;
      }

      var h;
      m("Unexpected character '" + t + "'");
    }

    return Q.next = a, Q.peek = o, Q.context = function (e) {
      return e && (r = e), r;
    }, Q.add_directive = function (e) {
      r.directive_stack[r.directive_stack.length - 1].push(e), void 0 === r.directives[e] ? r.directives[e] = 1 : r.directives[e]++;
    }, Q.push_directives_stack = function () {
      r.directive_stack.push([]);
    }, Q.pop_directives_stack = function () {
      for (var e = r.directive_stack[r.directive_stack.length - 1], t = 0; t < e.length; t++) {
        r.directives[e[t]]--;
      }

      r.directive_stack.pop();
    }, Q.has_directive = function (e) {
      return r.directives[e] > 0;
    }, Q;
  }

  var ne = E(["typeof", "void", "delete", "--", "++", "!", "~", "-", "+"]),
      ie = E(["--", "++"]),
      re = E(["=", "+=", "-=", "/=", "*=", "**=", "%=", ">>=", "<<=", ">>>=", "|=", "^=", "&="]),
      oe = function (e, t) {
    for (var n = 0; n < e.length; ++n) {
      for (var i = e[n], r = 0; r < i.length; ++r) {
        t[i[r]] = n + 1;
      }
    }

    return t;
  }([["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]], {}),
      ae = E(["atom", "num", "big_int", "string", "regexp", "name"]);

  function se(e, t) {
    var n = new Map();
    t = o(t, {
      bare_returns: !1,
      ecma: 8,
      expression: !1,
      filename: null,
      html5_comments: !0,
      module: !1,
      shebang: !0,
      strict: !1,
      toplevel: null
    }, !0);
    var i = {
      input: "string" == typeof e ? te(e, t.filename, t.html5_comments, t.shebang) : e,
      token: null,
      prev: null,
      peeked: null,
      in_function: 0,
      in_async: -1,
      in_generator: -1,
      in_directives: !0,
      in_loop: 0,
      labels: []
    };

    function r(e, t) {
      return Q(i.token, e, t);
    }

    function a() {
      return i.peeked || (i.peeked = i.input());
    }

    function s() {
      return i.prev = i.token, i.peeked || a(), i.token = i.peeked, i.peeked = null, i.in_directives = i.in_directives && ("string" == i.token.type || r("punc", ";")), i.token;
    }

    function u() {
      return i.prev;
    }

    function c(e, t, n, r) {
      var o = i.input.context();
      J(e, o.filename, null != t ? t : o.tokline, null != n ? n : o.tokcol, null != r ? r : o.tokpos);
    }

    function l(e, t) {
      c(t, e.line, e.col);
    }

    function f(e) {
      null == e && (e = i.token), l(e, "Unexpected token: " + e.type + " (" + e.value + ")");
    }

    function p(e, t) {
      if (r(e, t)) return s();
      l(i.token, "Unexpected token " + i.token.type + " «" + i.token.value + "», expected " + e + " «" + t + "»");
    }

    function _(e) {
      return p("punc", e);
    }

    function d(e) {
      return e.nlb || !e.comments_before.every(function (e) {
        return !e.nlb;
      });
    }

    function m() {
      return !t.strict && (r("eof") || r("punc", "}") || d(i.token));
    }

    function E() {
      return i.in_generator === i.in_function;
    }

    function h() {
      return i.in_async === i.in_function;
    }

    function D(e) {
      r("punc", ";") ? s() : e || m() || f();
    }

    function g() {
      _("(");

      var e = ht(!0);
      return _(")"), e;
    }

    function S(e) {
      return function () {
        var n = i.token,
            r = e.apply(void 0, arguments);
        return r.start = n, r.end = u(), r;
      };
    }

    function A() {
      (r("operator", "/") || r("operator", "/=")) && (i.peeked = null, i.token = i.input(i.token.value.substr(1)));
    }

    i.token = s();
    var v = S(function (e, n, o) {
      switch (A(), i.token.type) {
        case "string":
          if (i.in_directives) {
            var E = a();
            !i.token.raw.includes("\\") && (Q(E, "punc", ";") || Q(E, "punc", "}") || d(E) || Q(E, "eof")) ? i.input.add_directive(i.token.value) : i.in_directives = !1;
          }

          var S = i.in_directives,
              b = T();
          return S && b.body instanceof on ? new _e(b.body) : b;

        case "template_head":
        case "num":
        case "big_int":
        case "regexp":
        case "operator":
        case "atom":
          return T();

        case "name":
          if ("async" == i.token.value && Q(a(), "keyword", "function")) return s(), s(), n && c("functions are not allowed as the body of a loop"), F(Ve, !1, !0, e);

          if ("import" == i.token.value && !Q(a(), "punc", "(")) {
            s();

            var C = function () {
              var e,
                  t,
                  n = u();
              r("name") && (e = fe(qt));
              r("punc", ",") && s();
              ((t = ee(!0)) || e) && p("name", "from");
              var o = i.token;
              "string" !== o.type && f();
              return s(), new ut({
                start: n,
                imported_name: e,
                imported_names: t,
                module_name: new on({
                  start: o,
                  value: o.value,
                  quote: o.quote,
                  end: o
                }),
                end: i.token
              });
            }();

            return D(), C;
          }

          return Q(a(), "punc", ":") ? function () {
            var e = fe(jt);
            "await" === e.name && h() && l(i.prev, "await cannot be used as label inside async function");
            i.labels.some(function (t) {
              return t.name === e.name;
            }) && c("Label " + e.name + " defined twice");
            _(":"), i.labels.push(e);
            var t = v();
            i.labels.pop(), t instanceof ve || e.references.forEach(function (t) {
              t instanceof qe && (t = t.label.start, c("Continue label `" + e.name + "` refers to non-IterationStatement.", t.line, t.col, t.pos));
            });
            return new Ae({
              body: t,
              label: e
            });
          }() : T();

        case "punc":
          switch (i.token.value) {
            case "{":
              return new De({
                start: i.token,
                body: x(),
                end: u()
              });

            case "[":
            case "(":
              return T();

            case ";":
              return i.in_directives = !1, s(), new ge();

            default:
              f();
          }

        case "keyword":
          switch (i.token.value) {
            case "break":
              return s(), y(Ye);

            case "continue":
              return s(), y(qe);

            case "debugger":
              return s(), D(), new pe();

            case "do":
              s();
              var O = wt(v);
              p("keyword", "while");
              var M = g();
              return D(!0), new be({
                body: O,
                condition: M
              });

            case "while":
              return s(), new ye({
                condition: g(),
                body: wt(function () {
                  return v(!1, !0);
                })
              });

            case "for":
              return s(), function () {
                var e = "`for await` invalid in this context",
                    t = i.token;
                "name" == t.type && "await" == t.value ? (h() || l(t, e), s()) : t = !1;

                _("(");

                var n = null;
                if (r("punc", ";")) t && l(t, e);else {
                  n = r("keyword", "var") ? (s(), L(!0)) : r("keyword", "let") ? (s(), V(!0)) : r("keyword", "const") ? (s(), P(!0)) : ht(!0, !0);
                  var o = r("operator", "in"),
                      a = r("name", "of");
                  if (t && !a && l(t, e), o || a) return n instanceof it ? n.definitions.length > 1 && l(n.start, "Only one variable declaration allowed in for..in loop") : He(n) || (n = We(n)) instanceof Pe || l(n.start, "Invalid left-hand side in for..in loop"), s(), o ? function (e) {
                    var t = ht(!0);
                    return _(")"), new Oe({
                      init: e,
                      object: t,
                      body: wt(function () {
                        return v(!1, !0);
                      })
                    });
                  }(n) : function (e, t) {
                    var n = e instanceof it ? e.definitions[0].name : null,
                        i = ht(!0);
                    return _(")"), new Fe({
                      await: t,
                      init: e,
                      name: n,
                      object: i,
                      body: wt(function () {
                        return v(!1, !0);
                      })
                    });
                  }(n, !!t);
                }
                return function (e) {
                  _(";");

                  var t = r("punc", ";") ? null : ht(!0);

                  _(";");

                  var n = r("punc", ")") ? null : ht(!0);
                  return _(")"), new Ce({
                    init: e,
                    condition: t,
                    step: n,
                    body: wt(function () {
                      return v(!1, !0);
                    })
                  });
                }(n);
              }();

            case "class":
              return s(), n && c("classes are not allowed as the body of a loop"), o && c("classes are not allowed as the body of an if"), q(Nt);

            case "function":
              return s(), n && c("functions are not allowed as the body of a loop"), F(Ve, !1, !1, e);

            case "if":
              return s(), function () {
                var e = g(),
                    t = v(!1, !1, !0),
                    n = null;
                r("keyword", "else") && (s(), n = v(!1, !1, !0));
                return new $e({
                  condition: e,
                  body: t,
                  alternative: n
                });
              }();

            case "return":
              0 != i.in_function || t.bare_returns || c("'return' outside of function"), s();
              var w = null;
              return r("punc", ";") ? s() : m() || (w = ht(!0), D()), new Xe({
                value: w
              });

            case "switch":
              return s(), new je({
                expression: g(),
                body: wt(k)
              });

            case "throw":
              s(), d(i.token) && c("Illegal newline after 'throw'");
              w = ht(!0);
              return D(), new ze({
                value: w
              });

            case "try":
              return s(), function () {
                var e = x(),
                    t = null,
                    n = null;

                if (r("keyword", "catch")) {
                  var o = i.token;
                  if (s(), r("punc", "{")) var a = null;else {
                    _("(");

                    a = R(void 0, Yt);

                    _(")");
                  }
                  t = new tt({
                    start: o,
                    argname: a,
                    body: x(),
                    end: u()
                  });
                }

                if (r("keyword", "finally")) {
                  o = i.token;
                  s(), n = new nt({
                    start: o,
                    body: x(),
                    end: u()
                  });
                }

                t || n || c("Missing catch/finally blocks");
                return new et({
                  body: e,
                  bcatch: t,
                  bfinally: n
                });
              }();

            case "var":
              s();
              C = L();
              return D(), C;

            case "let":
              s();
              C = V();
              return D(), C;

            case "const":
              s();
              C = P();
              return D(), C;

            case "with":
              return i.input.has_directive("use strict") && c("Strict mode may not include a with statement"), s(), new Me({
                expression: g(),
                body: v()
              });

            case "export":
              if (!Q(a(), "punc", "(")) {
                s();

                C = function () {
                  var e,
                      t,
                      n,
                      o,
                      c,
                      l = i.token;
                  if (r("keyword", "default")) e = !0, s();else if (t = ee(!1)) {
                    if (r("name", "from")) {
                      s();
                      var p = i.token;
                      return "string" !== p.type && f(), s(), new ct({
                        start: l,
                        is_default: e,
                        exported_names: t,
                        module_name: new on({
                          start: p,
                          value: p.value,
                          quote: p.quote,
                          end: p
                        }),
                        end: u()
                      });
                    }

                    return new ct({
                      start: l,
                      is_default: e,
                      exported_names: t,
                      end: u()
                    });
                  }
                  r("punc", "{") || e && (r("keyword", "class") || r("keyword", "function")) && Q(a(), "punc") ? (o = ht(!1), D()) : (n = v(e)) instanceof it && e ? f(n.start) : n instanceof it || n instanceof xe || n instanceof Nt ? c = n : n instanceof de ? o = n.body : f(n.start);
                  return new ct({
                    start: l,
                    is_default: e,
                    exported_value: o,
                    exported_definition: c,
                    end: u()
                  });
                }();

                return r("punc", ";") && D(), C;
              }

          }

      }

      f();
    });

    function T(e) {
      return new de({
        body: (e = ht(!0), D(), e)
      });
    }

    function y(e) {
      var t,
          n = null;
      m() || (n = fe(en, !0)), null != n ? ((t = i.labels.find(function (e) {
        return e.name === n.name;
      })) || c("Undefined label " + n.name), n.thedef = t) : 0 == i.in_loop && c(e.TYPE + " not inside a loop or switch"), D();
      var r = new e({
        label: n
      });
      return t && t.references.push(r), r;
    }

    var C = function C(e, t, n) {
      d(i.token) && c("Unexpected newline before arrow (=>)"), p("arrow", "=>");
      var o = N(r("punc", "{"), !1, n),
          a = o instanceof Array && o.length ? o[o.length - 1].end : o instanceof Array ? e : o.end;
      return new Le({
        start: e,
        end: a,
        async: n,
        argnames: t,
        body: o
      });
    },
        F = function F(e, t, n, i) {
      var o = e === Ve,
          a = r("operator", "*");
      a && s();
      var c = r("name") ? fe(o ? Gt : Xt) : null;
      o && !c && (i ? e = Ie : f()), !c || e === ke || c instanceof Lt || f(u());
      var l = [],
          p = N(!0, a || t, n, c, l);
      return new e({
        start: l.start,
        end: p.end,
        is_generator: a,
        async: n,
        name: c,
        argnames: l,
        body: p
      });
    };

    function M(e, t) {
      var n = new Set(),
          i = !1,
          r = !1,
          o = !1,
          a = !!t,
          s = {
        add_parameter: function add_parameter(t) {
          if (n.has(t.value)) !1 === i && (i = t), s.check_strict();else if (n.add(t.value), e) switch (t.value) {
            case "arguments":
            case "eval":
            case "yield":
              a && l(t, "Unexpected " + t.value + " identifier as parameter inside strict mode");
              break;

            default:
              O.has(t.value) && f();
          }
        },
        mark_default_assignment: function mark_default_assignment(e) {
          !1 === r && (r = e);
        },
        mark_spread: function mark_spread(e) {
          !1 === o && (o = e);
        },
        mark_strict_mode: function mark_strict_mode() {
          a = !0;
        },
        is_strict: function is_strict() {
          return !1 !== r || !1 !== o || a;
        },
        check_strict: function check_strict() {
          s.is_strict() && !1 !== i && l(i, "Parameter " + i.value + " was used already");
        }
      };
      return s;
    }

    function R(e, t) {
      var n,
          o = !1;
      return void 0 === e && (e = M(!0, i.input.has_directive("use strict"))), r("expand", "...") && (o = i.token, e.mark_spread(i.token), s()), n = w(e, t), r("operator", "=") && !1 === o && (e.mark_default_assignment(i.token), s(), n = new Tt({
        start: n.start,
        left: n,
        operator: "=",
        right: ht(!1),
        end: i.token
      })), !1 !== o && (r("punc", ")") || f(), n = new Ne({
        start: o,
        expression: n,
        end: o
      })), e.check_strict(), n;
    }

    function w(e, t) {
      var n,
          o = [],
          l = !0,
          p = !1,
          d = i.token;

      if (void 0 === e && (e = M(!1, i.input.has_directive("use strict"))), t = void 0 === t ? Ut : t, r("punc", "[")) {
        for (s(); !r("punc", "]");) {
          if (l ? l = !1 : _(","), r("expand", "...") && (p = !0, n = i.token, e.mark_spread(i.token), s()), r("punc")) switch (i.token.value) {
            case ",":
              o.push(new _n({
                start: i.token,
                end: i.token
              }));
              continue;

            case "]":
              break;

            case "[":
            case "{":
              o.push(w(e, t));
              break;

            default:
              f();
          } else r("name") ? (e.add_parameter(i.token), o.push(fe(t))) : c("Invalid function parameter");
          r("operator", "=") && !1 === p && (e.mark_default_assignment(i.token), s(), o[o.length - 1] = new Tt({
            start: o[o.length - 1].start,
            left: o[o.length - 1],
            operator: "=",
            right: ht(!1),
            end: i.token
          })), p && (r("punc", "]") || c("Rest element must be last element"), o[o.length - 1] = new Ne({
            start: n,
            expression: o[o.length - 1],
            end: n
          }));
        }

        return _("]"), e.check_strict(), new Pe({
          start: d,
          names: o,
          is_array: !0,
          end: u()
        });
      }

      if (r("punc", "{")) {
        for (s(); !r("punc", "}");) {
          if (l ? l = !1 : _(","), r("expand", "...") && (p = !0, n = i.token, e.mark_spread(i.token), s()), r("name") && (Q(a(), "punc") || Q(a(), "operator")) && [",", "}", "="].includes(a().value)) {
            e.add_parameter(i.token);
            var m = u(),
                E = fe(t);
            p ? o.push(new Ne({
              start: n,
              expression: E,
              end: E.end
            })) : o.push(new Ot({
              start: m,
              key: E.name,
              value: E,
              end: E.end
            }));
          } else {
            if (r("punc", "}")) continue;
            var h = i.token,
                D = se();
            null === D ? f(u()) : "name" !== u().type || r("punc", ":") ? (_(":"), o.push(new Ot({
              start: h,
              quote: h.quote,
              key: D,
              value: w(e, t),
              end: u()
            }))) : o.push(new Ot({
              start: u(),
              key: D,
              value: new t({
                start: u(),
                name: D,
                end: u()
              }),
              end: u()
            }));
          }

          p ? r("punc", "}") || c("Rest element must be last element") : r("operator", "=") && (e.mark_default_assignment(i.token), s(), o[o.length - 1].value = new Tt({
            start: o[o.length - 1].value.start,
            left: o[o.length - 1].value,
            operator: "=",
            right: ht(!1),
            end: i.token
          }));
        }

        return _("}"), e.check_strict(), new Pe({
          start: d,
          names: o,
          is_array: !1,
          end: u()
        });
      }

      if (r("name")) return e.add_parameter(i.token), fe(t);
      c("Invalid function parameter");
    }

    function N(e, n, o, a, u) {
      var c = i.in_loop,
          l = i.labels,
          p = i.in_generator,
          d = i.in_async;

      if (++i.in_function, n && (i.in_generator = i.in_function), o && (i.in_async = i.in_function), u && function (e) {
        var n = M(!0, i.input.has_directive("use strict"));

        for (_("("); !r("punc", ")");) {
          var o = R(n);
          if (e.push(o), r("punc", ")") || (_(","), r("punc", ")") && t.ecma < 8 && f()), o instanceof Ne) break;
        }

        s();
      }(u), e && (i.in_directives = !0), i.in_loop = 0, i.labels = [], e) {
        i.input.push_directives_stack();
        var m = x();
        a && ce(a), u && u.forEach(ce), i.input.pop_directives_stack();
      } else m = ht(!1);

      return --i.in_function, i.in_loop = c, i.labels = l, i.in_generator = p, i.in_async = d, m;
    }

    function x() {
      _("{");

      for (var e = []; !r("punc", "}");) {
        r("eof") && f(), e.push(v());
      }

      return s(), e;
    }

    function k() {
      _("{");

      for (var e, t = [], n = null, o = null; !r("punc", "}");) {
        r("eof") && f(), r("keyword", "case") ? (o && (o.end = u()), n = [], o = new Qe({
          start: (e = i.token, s(), e),
          expression: ht(!0),
          body: n
        }), t.push(o), _(":")) : r("keyword", "default") ? (o && (o.end = u()), n = [], o = new Je({
          start: (e = i.token, s(), _(":"), e),
          body: n
        }), t.push(o)) : (n || f(), n.push(v()));
      }

      return o && (o.end = u()), s(), t;
    }

    function I(e, t) {
      for (var n, o = [];;) {
        var a = "var" === t ? Vt : "const" === t ? Bt : "let" === t ? Kt : null;
        if (r("punc", "{") || r("punc", "[") ? n = new lt({
          start: i.token,
          name: w(void 0, a),
          value: r("operator", "=") ? (p("operator", "="), ht(!1, e)) : null,
          end: u()
        }) : "import" == (n = new lt({
          start: i.token,
          name: fe(a),
          value: r("operator", "=") ? (s(), ht(!1, e)) : e || "const" !== t ? null : c("Missing initializer in const declaration"),
          end: u()
        })).name.name && c("Unexpected token: import"), o.push(n), !r("punc", ",")) break;
        s();
      }

      return o;
    }

    var L = function L(e) {
      return new rt({
        start: u(),
        definitions: I(e, "var"),
        end: u()
      });
    },
        V = function V(e) {
      return new ot({
        start: u(),
        definitions: I(e, "let"),
        end: u()
      });
    },
        P = function P(e) {
      return new at({
        start: u(),
        definitions: I(e, "const"),
        end: u()
      });
    };

    function B() {
      var e,
          t = i.token;

      switch (t.type) {
        case "name":
          e = ue(Zt);
          break;

        case "num":
          e = new an({
            start: t,
            end: t,
            value: t.value
          });
          break;

        case "big_int":
          e = new sn({
            start: t,
            end: t,
            value: t.value
          });
          break;

        case "string":
          e = new on({
            start: t,
            end: t,
            value: t.value,
            quote: t.quote
          });
          break;

        case "regexp":
          e = new un({
            start: t,
            end: t,
            value: t.value
          });
          break;

        case "atom":
          switch (t.value) {
            case "false":
              e = new En({
                start: t,
                end: t
              });
              break;

            case "true":
              e = new hn({
                start: t,
                end: t
              });
              break;

            case "null":
              e = new ln({
                start: t,
                end: t
              });
          }

      }

      return s(), e;
    }

    function U(e, t, n, i) {
      var r = function r(e, t) {
        return t ? new Tt({
          start: e.start,
          left: e,
          operator: "=",
          right: t,
          end: t.end
        }) : e;
      };

      return e instanceof yt ? r(new Pe({
        start: e.start,
        end: e.end,
        is_array: !1,
        names: e.properties.map(U)
      }), i) : e instanceof Ot ? (e.value = U(e.value, 0, [e.key]), r(e, i)) : e instanceof _n ? e : e instanceof Pe ? (e.names = e.names.map(U), r(e, i)) : e instanceof Zt ? r(new Ut({
        name: e.name,
        start: e.start,
        end: e.end
      }), i) : e instanceof Ne ? (e.expression = U(e.expression), r(e, i)) : e instanceof bt ? r(new Pe({
        start: e.start,
        end: e.end,
        is_array: !0,
        names: e.elements.map(U)
      }), i) : e instanceof vt ? r(U(e.left, void 0, void 0, e.right), i) : e instanceof Tt ? (e.left = U(e.left, 0, [e.left]), e) : void c("Invalid function parameter", e.start.line, e.start.col);
    }

    var G = function G(e, o) {
      var _E$end$comments_after;

      if (r("operator", "new")) return function (e) {
        var n = i.token;
        if (p("operator", "new"), r("punc", ".")) return s(), p("name", "target"), Ee(new It({
          start: n,
          end: u()
        }), e);
        var o,
            a = G(!1);
        r("punc", "(") ? (s(), o = X(")", t.ecma >= 8)) : o = [];
        var c = new pt({
          start: n,
          expression: a,
          args: o,
          end: u()
        });
        return me(c), Ee(c, e);
      }(e);
      var c,
          l = i.token,
          d = r("name", "async") && "[" != (c = a()).value && "arrow" != c.type && B();

      if (r("punc")) {
        switch (i.token.value) {
          case "(":
            if (d && !e) break;

            var m = function (e, n) {
              var o,
                  a,
                  c,
                  l = [];

              for (_("("); !r("punc", ")");) {
                o && f(o), r("expand", "...") ? (o = i.token, n && (a = i.token), s(), l.push(new Ne({
                  start: u(),
                  expression: ht(),
                  end: i.token
                }))) : l.push(ht()), r("punc", ")") || (_(","), r("punc", ")") && (t.ecma < 8 && f(), c = u(), n && (a = c)));
              }

              return _(")"), e && r("arrow", "=>") ? o && c && f(c) : a && f(a), l;
            }(o, !d);

            if (o && r("arrow", "=>")) return C(l, m.map(U), !!d);
            var E = d ? new ft({
              expression: d,
              args: m
            }) : 1 == m.length ? m[0] : new _t({
              expressions: m
            });

            if (E.start) {
              var _E$start$comments_bef;

              var _e2 = l.comments_before.length;

              if (n.set(l, _e2), (_E$start$comments_bef = E.start.comments_before).unshift.apply(_E$start$comments_bef, _toConsumableArray(l.comments_before)), l.comments_before = E.start.comments_before, 0 == _e2 && l.comments_before.length > 0) {
                var h = l.comments_before[0];
                h.nlb || (h.nlb = l.nlb, l.nlb = !1);
              }

              l.comments_after = E.start.comments_after;
            }

            E.start = l;
            var D = u();
            return E.end && (D.comments_before = E.end.comments_before, (_E$end$comments_after = E.end.comments_after).push.apply(_E$end$comments_after, _toConsumableArray(D.comments_after)), D.comments_after = E.end.comments_after), E.end = D, E instanceof ft && me(E), Ee(E, e);

          case "[":
            return Ee(z(), e);

          case "{":
            return Ee(Y(), e);
        }

        d || f();
      }

      if (o && r("name") && Q(a(), "arrow")) {
        var g = new Ut({
          name: i.token.value,
          start: l,
          end: l
        });
        return s(), C(l, [g], !!d);
      }

      if (r("keyword", "function")) {
        s();
        var S = F(Ie, !1, !!d);
        return S.start = l, S.end = u(), Ee(S, e);
      }

      if (d) return Ee(d, e);

      if (r("keyword", "class")) {
        s();
        var A = q(xt);
        return A.start = l, A.end = u(), Ee(A, e);
      }

      return r("template_head") ? Ee(H(), e) : ae.has(i.token.type) ? Ee(B(), e) : void f();
    };

    function H(e) {
      var t = [],
          n = i.token;

      for (t.push(new Ue({
        start: i.token,
        raw: i.token.raw,
        value: i.token.value,
        end: i.token
      })); !i.token.end;) {
        s(), A(), t.push(ht(!0)), Q("template_substitution") || f(), t.push(new Ue({
          start: i.token,
          raw: i.token.raw,
          value: i.token.value,
          end: i.token
        }));
      }

      return s(), new Ke({
        start: n,
        segments: t,
        end: i.token
      });
    }

    function X(e, t, n) {
      for (var o = !0, a = []; !r("punc", e) && (o ? o = !1 : _(","), !t || !r("punc", e));) {
        r("punc", ",") && n ? a.push(new _n({
          start: i.token,
          end: i.token
        })) : r("expand", "...") ? (s(), a.push(new Ne({
          start: u(),
          expression: ht(),
          end: i.token
        }))) : a.push(ht(!1));
      }

      return s(), a;
    }

    var z = S(function () {
      return _("["), new bt({
        elements: X("]", !t.strict, !0)
      });
    }),
        W = S(function (e, t) {
      return F(ke, e, t);
    }),
        Y = S(function () {
      var e = i.token,
          n = !0,
          o = [];

      for (_("{"); !r("punc", "}") && (n ? n = !1 : _(","), t.strict || !r("punc", "}"));) {
        if ("expand" != (e = i.token).type) {
          var a,
              c = se();
          if (r("punc", ":")) null === c ? f(u()) : (s(), a = ht(!1));else {
            var l = $(c, e);

            if (l) {
              o.push(l);
              continue;
            }

            a = new Zt({
              start: u(),
              name: c,
              end: u()
            });
          }
          r("operator", "=") && (s(), a = new vt({
            start: e,
            left: a,
            operator: "=",
            right: ht(!1),
            end: u()
          })), o.push(new Ot({
            start: e,
            quote: e.quote,
            key: c instanceof le ? c : "" + c,
            value: a,
            end: u()
          }));
        } else s(), o.push(new Ne({
          start: e,
          expression: ht(!1),
          end: u()
        }));
      }

      return s(), new yt({
        properties: o
      });
    });

    function q(e) {
      var t,
          n,
          o,
          a,
          c = [];

      for (i.input.push_directives_stack(), i.input.add_directive("use strict"), "name" == i.token.type && "extends" != i.token.value && (o = fe(e === Nt ? zt : Wt)), e !== Nt || o || f(), "extends" == i.token.value && (s(), a = ht(!0)), _("{"); r("punc", ";");) {
        s();
      }

      for (; !r("punc", "}");) {
        for (t = i.token, (n = $(se(), t, !0)) || f(), c.push(n); r("punc", ";");) {
          s();
        }
      }

      return i.input.pop_directives_stack(), s(), new e({
        start: t,
        name: o,
        extends: a,
        properties: c,
        end: u()
      });
    }

    function $(e, t, n) {
      var o = function o(e, t) {
        return "string" == typeof e || "number" == typeof e ? new Ht({
          start: t,
          name: "" + e,
          end: u()
        }) : (null === e && f(), e);
      },
          a = !1,
          s = !1,
          c = !1,
          l = t;

      if (n && "static" === e && !r("punc", "(") && (s = !0, l = i.token, e = se()), "async" !== e || r("punc", "(") || r("punc", ",") || r("punc", "}") || r("operator", "=") || (a = !0, l = i.token, e = se()), null === e && (c = !0, l = i.token, null === (e = se()) && f()), r("punc", "(")) return e = o(e, t), new Rt({
        start: t,
        static: s,
        is_generator: c,
        async: a,
        key: e,
        quote: e instanceof Ht ? l.quote : void 0,
        value: W(c, a),
        end: u()
      });

      if (l = i.token, "get" == e) {
        if (!r("punc") || r("punc", "[")) return e = o(se(), t), new Mt({
          start: t,
          static: s,
          key: e,
          quote: e instanceof Ht ? l.quote : void 0,
          value: W(),
          end: u()
        });
      } else if ("set" == e && (!r("punc") || r("punc", "["))) return e = o(se(), t), new Ft({
        start: t,
        static: s,
        key: e,
        quote: e instanceof Ht ? l.quote : void 0,
        value: W(),
        end: u()
      });
    }

    function j(e) {
      function t(e) {
        return new e({
          name: se(),
          start: u(),
          end: u()
        });
      }

      var n,
          o,
          a = e ? $t : Qt,
          c = e ? qt : Jt,
          l = i.token;
      return e ? n = t(a) : o = t(c), r("name", "as") ? (s(), e ? o = t(c) : n = t(a)) : e ? o = new c(n) : n = new a(o), new st({
        start: l,
        foreign_name: n,
        name: o,
        end: u()
      });
    }

    function Z(e, t) {
      var n,
          r = e ? $t : Qt,
          o = e ? qt : Jt,
          a = i.token,
          s = u();
      return t = t || new o({
        name: "*",
        start: a,
        end: s
      }), n = new r({
        name: "*",
        start: a,
        end: s
      }), new st({
        start: a,
        foreign_name: n,
        name: t,
        end: s
      });
    }

    function ee(e) {
      var t;

      if (r("punc", "{")) {
        for (s(), t = []; !r("punc", "}");) {
          t.push(j(e)), r("punc", ",") && s();
        }

        s();
      } else if (r("operator", "*")) {
        var n;
        s(), e && r("name", "as") && (s(), n = fe(e ? qt : Qt)), t = [Z(e, n)];
      }

      return t;
    }

    function se() {
      var e = i.token;

      switch (e.type) {
        case "punc":
          if ("[" === e.value) {
            s();
            var t = ht(!1);
            return _("]"), t;
          }

          f(e);

        case "operator":
          if ("*" === e.value) return s(), null;
          ["delete", "in", "instanceof", "new", "typeof", "void"].includes(e.value) || f(e);

        case "name":
          "yield" == e.value && (E() ? l(e, "Yield cannot be used as identifier inside generators") : Q(a(), "punc", ":") || Q(a(), "punc", "(") || !i.input.has_directive("use strict") || l(e, "Unexpected yield identifier inside strict mode"));

        case "string":
        case "num":
        case "big_int":
        case "keyword":
        case "atom":
          return s(), e.value;

        default:
          f(e);
      }
    }

    function ue(e) {
      var t = i.token.value;
      return new ("this" == t ? tn : "super" == t ? nn : e)({
        name: String(t),
        start: i.token,
        end: i.token
      });
    }

    function ce(e) {
      var t = e.name;
      E() && "yield" == t && l(e.start, "Yield cannot be used as identifier inside generators"), i.input.has_directive("use strict") && ("yield" == t && l(e.start, "Unexpected yield identifier inside strict mode"), e instanceof Lt && ("arguments" == t || "eval" == t) && l(e.start, "Unexpected " + t + " in strict mode"));
    }

    function fe(e, t) {
      if (!r("name")) return t || c("Name expected"), null;
      var n = ue(e);
      return ce(n), s(), n;
    }

    function me(e) {
      var t = e.start,
          i = t.comments_before;
      var r = n.get(t);

      for (var o = null != r ? r : i.length; --o >= 0;) {
        var a = i[o];

        if (/[@#]__/.test(a.value)) {
          if (/[@#]__PURE__/.test(a.value)) {
            b(e, vn);
            break;
          }

          if (/[@#]__INLINE__/.test(a.value)) {
            b(e, Tn);
            break;
          }

          if (/[@#]__NOINLINE__/.test(a.value)) {
            b(e, bn);
            break;
          }
        }
      }
    }

    var Ee = function Ee(e, t) {
      var n,
          o = e.start;
      if (r("punc", ".")) return s(), Ee(new mt({
        start: o,
        expression: e,
        property: (n = i.token, "name" != n.type && f(), s(), n.value),
        end: u()
      }), t);

      if (r("punc", "[")) {
        s();
        var a = ht(!0);
        return _("]"), Ee(new Et({
          start: o,
          expression: e,
          property: a,
          end: u()
        }), t);
      }

      if (t && r("punc", "(")) {
        s();
        var c = new ft({
          start: o,
          expression: e,
          args: he(),
          end: u()
        });
        return me(c), Ee(c, !0);
      }

      return r("template_head") ? Ee(new Be({
        start: o,
        prefix: e,
        template_string: H(),
        end: u()
      }), t) : e;
    };

    function he() {
      for (var e = []; !r("punc", ")");) {
        r("expand", "...") ? (s(), e.push(new Ne({
          start: u(),
          expression: ht(!1),
          end: u()
        }))) : e.push(ht(!1)), r("punc", ")") || (_(","), r("punc", ")") && t.ecma < 8 && f());
      }

      return s(), e;
    }

    var Se = function Se(e, t) {
      var n = i.token;

      if ("name" == n.type && "await" == n.value) {
        if (h()) return s(), h() || c("Unexpected await expression outside async function", i.prev.line, i.prev.col, i.prev.pos), new Dn({
          start: u(),
          end: i.token,
          expression: Se(!0)
        });
        i.input.has_directive("use strict") && l(i.token, "Unexpected await identifier inside strict mode");
      }

      if (r("operator") && ne.has(n.value)) {
        s(), A();
        var o = Te(Dt, n, Se(e));
        return o.start = n, o.end = u(), o;
      }

      for (var a = G(e, t); r("operator") && ie.has(i.token.value) && !d(i.token);) {
        a instanceof Le && f(), (a = Te(gt, i.token, a)).start = n, a.end = i.token, s();
      }

      return a;
    };

    function Te(e, t, n) {
      var r = t.value;

      switch (r) {
        case "++":
        case "--":
          He(n) || c("Invalid use of " + r + " operator", t.line, t.col, t.pos);
          break;

        case "delete":
          n instanceof Zt && i.input.has_directive("use strict") && c("Calling delete on expression not allowed in strict mode", n.start.line, n.start.col, n.start.pos);
      }

      return new e({
        operator: r,
        expression: n
      });
    }

    var Re = function Re(e, t, n) {
      var o = r("operator") ? i.token.value : null;
      "in" == o && n && (o = null), "**" == o && e instanceof Dt && !Q(e.start, "punc", "(") && "--" !== e.operator && "++" !== e.operator && f(e.start);
      var a = null != o ? oe[o] : null;

      if (null != a && (a > t || "**" === o && t === a)) {
        s();
        var u = Re(Se(!0), a, n);
        return Re(new St({
          start: e.start,
          left: e,
          operator: o,
          right: u,
          end: u.end
        }), t, n);
      }

      return e;
    };

    var Ge = function Ge(e) {
      var t = i.token,
          n = function (e) {
        return Re(Se(!0, !0), 0, e);
      }(e);

      if (r("operator", "?")) {
        s();
        var o = ht(!1);
        return _(":"), new At({
          start: t,
          condition: n,
          consequent: o,
          alternative: ht(!1, e),
          end: u()
        });
      }

      return n;
    };

    function He(e) {
      return e instanceof dt || e instanceof Zt;
    }

    function We(e) {
      if (e instanceof yt) e = new Pe({
        start: e.start,
        names: e.properties.map(We),
        is_array: !1,
        end: e.end
      });else if (e instanceof bt) {
        for (var t = [], n = 0; n < e.elements.length; n++) {
          e.elements[n] instanceof Ne && (n + 1 !== e.elements.length && l(e.elements[n].start, "Spread must the be last element in destructuring array"), e.elements[n].expression = We(e.elements[n].expression)), t.push(We(e.elements[n]));
        }

        e = new Pe({
          start: e.start,
          names: t,
          is_array: !0,
          end: e.end
        });
      } else e instanceof Ct ? e.value = We(e.value) : e instanceof vt && (e = new Tt({
        start: e.start,
        left: e.left,
        operator: "=",
        right: e.right,
        end: e.end
      }));
      return e;
    }

    var Ze = function Ze(e) {
      A();
      var t = i.token;

      if ("name" == t.type && "yield" == t.value) {
        if (E()) return s(), function () {
          E() || c("Unexpected yield expression outside generator function", i.prev.line, i.prev.col, i.prev.pos);
          var e = i.token,
              t = !1,
              n = !0;
          return m() || r("punc") && K.has(i.token.value) ? n = !1 : r("operator", "*") && (t = !0, s()), new gn({
            start: e,
            is_star: t,
            expression: n ? ht() : null,
            end: u()
          });
        }();
        i.input.has_directive("use strict") && l(i.token, "Unexpected yield identifier inside strict mode");
      }

      var n = Ge(e),
          o = i.token.value;

      if (r("operator") && re.has(o)) {
        if (He(n) || (n = We(n)) instanceof Pe) return s(), new vt({
          start: t,
          left: n,
          operator: o,
          right: Ze(e),
          end: u()
        });
        c("Invalid assignment");
      }

      return n;
    },
        ht = function ht(e, t) {
      for (var n = i.token, o = []; o.push(Ze(t)), e && r("punc", ",");) {
        s(), e = !0;
      }

      return 1 == o.length ? o[0] : new _t({
        start: n,
        expressions: o,
        end: a()
      });
    };

    function wt(e) {
      ++i.in_loop;
      var t = e();
      return --i.in_loop, t;
    }

    return t.expression ? ht(!0) : function () {
      var e = i.token,
          n = [];

      for (i.input.push_directives_stack(), t.module && i.input.add_directive("use strict"); !r("eof");) {
        n.push(v());
      }

      i.input.pop_directives_stack();
      var o = u(),
          a = t.toplevel;
      return a ? (a.body = a.body.concat(n), a.end = o) : a = new we({
        start: e,
        body: n,
        end: o
      }), a;
    }();
  }

  function ue(e, t, n) {
    var i = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : le;
    var r = t = t ? t.split(/\s+/) : [];
    i && i.PROPS && (t = t.concat(i.PROPS));

    for (var o = "return function AST_" + e + "(props){ if (props) { ", a = t.length; --a >= 0;) {
      o += "this." + t[a] + " = props." + t[a] + ";";
    }

    var s = i && Object.create(i.prototype);
    (s && s.initialize || n && n.initialize) && (o += "this.initialize();"), o += "}", o += "this.flags = 0;", o += "}";
    var u = new Function(o)();
    if (s && (u.prototype = s, u.BASE = i), i && i.SUBCLASSES.push(u), u.prototype.CTOR = u, u.PROPS = t || null, u.SELF_PROPS = r, u.SUBCLASSES = [], e && (u.prototype.TYPE = u.TYPE = e), n) for (a in n) {
      D(n, a) && ("$" === a[0] ? u[a.substr(1)] = n[a] : u.prototype[a] = n[a]);
    }
    return u.DEFMETHOD = function (e, t) {
      this.prototype[e] = t;
    }, u;
  }

  var ce = ue("Token", "type value line col pos endline endcol endpos nlb comments_before comments_after file raw quote end", {}, null),
      le = ue("Node", "start end", {
    _clone: function _clone(e) {
      if (e) {
        var t = this.clone();
        return t.transform(new An(function (e) {
          if (e !== t) return e.clone(!0);
        }));
      }

      return new this.CTOR(this);
    },
    clone: function clone(e) {
      return this._clone(e);
    },
    $documentation: "Base class of all AST nodes",
    $propdoc: {
      start: "[AST_Token] The first token of this node",
      end: "[AST_Token] The last token of this node"
    },
    _walk: function _walk(e) {
      return e._visit(this);
    },
    walk: function walk(e) {
      return this._walk(e);
    }
  }, null);
  le.warn_function = null, le.warn = function (e, t) {
    le.warn_function && le.warn_function(_(e, t));
  };

  var fe = ue("Statement", null, {
    $documentation: "Base class of all statements"
  }),
      pe = ue("Debugger", null, {
    $documentation: "Represents a debugger statement"
  }, fe),
      _e = ue("Directive", "value quote", {
    $documentation: 'Represents a directive, like "use strict";',
    $propdoc: {
      value: "[string] The value of this directive as a plain string (it's not an AST_String!)",
      quote: "[string] the original quote character"
    }
  }, fe),
      de = ue("SimpleStatement", "body", {
    $documentation: "A statement consisting of an expression, i.e. a = 1 + 2",
    $propdoc: {
      body: "[AST_Node] an expression node (should not be instanceof AST_Statement)"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.body._walk(e);
      });
    }
  }, fe);

  function me(e, t) {
    var n = e.body;
    if (n instanceof le) n._walk(t);else for (var i = 0, r = n.length; i < r; i++) {
      n[i]._walk(t);
    }
  }

  function Ee(e) {
    var t = this._clone(e);

    return this.block_scope && (t.block_scope = this.block_scope.clone()), t;
  }

  var he = ue("Block", "body block_scope", {
    $documentation: "A body of statements (usually braced)",
    $propdoc: {
      body: "[AST_Statement*] an array of statements",
      block_scope: "[AST_Scope] the block scope"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        me(this, e);
      });
    },
    clone: Ee
  }, fe),
      De = ue("BlockStatement", null, {
    $documentation: "A block statement"
  }, he),
      ge = ue("EmptyStatement", null, {
    $documentation: "The empty statement (empty block or simply a semicolon)"
  }, fe),
      Se = ue("StatementWithBody", "body", {
    $documentation: "Base class for all statements that contain one nested body: `For`, `ForIn`, `Do`, `While`, `With`",
    $propdoc: {
      body: "[AST_Statement] the body; this should always be present, even if it's an AST_EmptyStatement"
    }
  }, fe),
      Ae = ue("LabeledStatement", "label", {
    $documentation: "Statement with a label",
    $propdoc: {
      label: "[AST_Label] a label definition"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.label._walk(e), this.body._walk(e);
      });
    },
    clone: function clone(e) {
      var t = this._clone(e);

      if (e) {
        var n = t.label,
            i = this.label;
        t.walk(new Sn(function (e) {
          e instanceof We && e.label && e.label.thedef === i && (e.label.thedef = n, n.references.push(e));
        }));
      }

      return t;
    }
  }, Se),
      ve = ue("IterationStatement", "block_scope", {
    $documentation: "Internal class.  All loops inherit from it.",
    $propdoc: {
      block_scope: "[AST_Scope] the block scope for this iteration statement."
    },
    clone: Ee
  }, Se),
      Te = ue("DWLoop", "condition", {
    $documentation: "Base class for do/while statements",
    $propdoc: {
      condition: "[AST_Node] the loop condition.  Should not be instanceof AST_Statement"
    }
  }, ve),
      be = ue("Do", null, {
    $documentation: "A `do` statement",
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.body._walk(e), this.condition._walk(e);
      });
    }
  }, Te),
      ye = ue("While", null, {
    $documentation: "A `while` statement",
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.condition._walk(e), this.body._walk(e);
      });
    }
  }, Te),
      Ce = ue("For", "init condition step", {
    $documentation: "A `for` statement",
    $propdoc: {
      init: "[AST_Node?] the `for` initialization code, or null if empty",
      condition: "[AST_Node?] the `for` termination clause, or null if empty",
      step: "[AST_Node?] the `for` update clause, or null if empty"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.init && this.init._walk(e), this.condition && this.condition._walk(e), this.step && this.step._walk(e), this.body._walk(e);
      });
    }
  }, ve),
      Oe = ue("ForIn", "init object", {
    $documentation: "A `for ... in` statement",
    $propdoc: {
      init: "[AST_Node] the `for/in` initialization code",
      object: "[AST_Node] the object that we're looping through"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.init._walk(e), this.object._walk(e), this.body._walk(e);
      });
    }
  }, ve),
      Fe = ue("ForOf", "await", {
    $documentation: "A `for ... of` statement"
  }, Oe),
      Me = ue("With", "expression", {
    $documentation: "A `with` statement",
    $propdoc: {
      expression: "[AST_Node] the `with` expression"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expression._walk(e), this.body._walk(e);
      });
    }
  }, Se),
      Re = ue("Scope", "variables functions uses_with uses_eval parent_scope enclosed cname _var_name_cache", {
    $documentation: "Base class for all statements introducing a lexical scope",
    $propdoc: {
      variables: "[Map/S] a map of name -> SymbolDef for all variables/functions defined in this scope",
      functions: "[Map/S] like `variables`, but only lists function declarations",
      uses_with: "[boolean/S] tells whether this scope uses the `with` statement",
      uses_eval: "[boolean/S] tells whether this scope contains a direct call to the global `eval`",
      parent_scope: "[AST_Scope?/S] link to the parent scope",
      enclosed: "[SymbolDef*/S] a list of all symbol definitions that are accessed from this scope or any subscopes",
      cname: "[integer/S] current index for mangling variables (used internally by the mangler)"
    },
    get_defun_scope: function get_defun_scope() {
      for (var e = this; e.is_block_scope();) {
        e = e.parent_scope;
      }

      return e;
    },
    clone: function clone(e) {
      var t = this._clone(e);

      return this.variables && (t.variables = new Map(this.variables)), this.functions && (t.functions = new Map(this.functions)), this.enclosed && (t.enclosed = this.enclosed.slice()), t;
    },
    pinned: function pinned() {
      return this.uses_eval || this.uses_with;
    }
  }, he),
      we = ue("Toplevel", "globals", {
    $documentation: "The toplevel scope",
    $propdoc: {
      globals: "[Map/S] a map of name -> SymbolDef for all undeclared names"
    },
    wrap_commonjs: function wrap_commonjs(e) {
      var t = this.body,
          n = "(function(exports){'$ORIG';})(typeof " + e + "=='undefined'?(" + e + "={}):" + e + ");";
      return n = (n = se(n)).transform(new An(function (e) {
        if (e instanceof _e && "$ORIG" == e.value) return f.splice(t);
      }));
    },
    wrap_enclose: function wrap_enclose(e) {
      "string" != typeof e && (e = "");
      var t = e.indexOf(":");
      t < 0 && (t = e.length);
      var n = this.body;
      return se(["(function(", e.slice(0, t), '){"$ORIG"})(', e.slice(t + 1), ")"].join("")).transform(new An(function (e) {
        if (e instanceof _e && "$ORIG" == e.value) return f.splice(n);
      }));
    }
  }, Re),
      Ne = ue("Expansion", "expression", {
    $documentation: "An expandible argument, such as ...rest, a splat, such as [1,2,...all], or an expansion in a variable declaration, such as var [first, ...rest] = list",
    $propdoc: {
      expression: "[AST_Node] the thing to be expanded"
    },
    _walk: function _walk(e) {
      var t = this;
      return e._visit(this, function () {
        t.expression.walk(e);
      });
    }
  }),
      xe = ue("Lambda", "name argnames uses_arguments is_generator async", {
    $documentation: "Base class for functions",
    $propdoc: {
      name: "[AST_SymbolDeclaration?] the name of this function",
      argnames: "[AST_SymbolFunarg|AST_Destructuring|AST_Expansion|AST_DefaultAssign*] array of function arguments, destructurings, or expanding arguments",
      uses_arguments: "[boolean/S] tells whether this function accesses the arguments array",
      is_generator: "[boolean] is this a generator method",
      async: "[boolean] is this method async"
    },
    args_as_names: function args_as_names() {
      for (var e = [], t = 0; t < this.argnames.length; t++) {
        this.argnames[t] instanceof Pe ? e.push.apply(e, _toConsumableArray(this.argnames[t].all_symbols())) : e.push(this.argnames[t]);
      }

      return e;
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.name && this.name._walk(e);

        for (var t = this.argnames, n = 0, i = t.length; n < i; n++) {
          t[n]._walk(e);
        }

        me(this, e);
      });
    }
  }, Re),
      ke = ue("Accessor", null, {
    $documentation: "A setter/getter function.  The `name` property is always null."
  }, xe),
      Ie = ue("Function", null, {
    $documentation: "A function expression"
  }, xe),
      Le = ue("Arrow", null, {
    $documentation: "An ES6 Arrow function ((a) => b)"
  }, xe),
      Ve = ue("Defun", null, {
    $documentation: "A function definition"
  }, xe),
      Pe = ue("Destructuring", "names is_array", {
    $documentation: "A destructuring of several names. Used in destructuring assignment and with destructuring function argument names",
    $propdoc: {
      names: "[AST_Node*] Array of properties or elements",
      is_array: "[Boolean] Whether the destructuring represents an object or array"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.names.forEach(function (t) {
          t._walk(e);
        });
      });
    },
    all_symbols: function all_symbols() {
      var e = [];
      return this.walk(new Sn(function (t) {
        t instanceof kt && e.push(t);
      })), e;
    }
  }),
      Be = ue("PrefixedTemplateString", "template_string prefix", {
    $documentation: "A templatestring with a prefix, such as String.raw`foobarbaz`",
    $propdoc: {
      template_string: "[AST_TemplateString] The template string",
      prefix: "[AST_SymbolRef|AST_PropAccess] The prefix, which can be a symbol such as `foo` or a dotted expression such as `String.raw`."
    },
    _walk: function _walk(e) {
      this.prefix._walk(e), this.template_string._walk(e);
    }
  }),
      Ke = ue("TemplateString", "segments", {
    $documentation: "A template string literal",
    $propdoc: {
      segments: "[AST_Node*] One or more segments, starting with AST_TemplateSegment. AST_Node may follow AST_TemplateSegment, but each AST_Node must be followed by AST_TemplateSegment."
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.segments.forEach(function (t) {
          t._walk(e);
        });
      });
    }
  }),
      Ue = ue("TemplateSegment", "value raw", {
    $documentation: "A segment of a template string literal",
    $propdoc: {
      value: "Content of the segment",
      raw: "Raw content of the segment"
    }
  }),
      Ge = ue("Jump", null, {
    $documentation: "Base class for “jumps” (for now that's `return`, `throw`, `break` and `continue`)"
  }, fe),
      He = ue("Exit", "value", {
    $documentation: "Base class for “exits” (`return` and `throw`)",
    $propdoc: {
      value: "[AST_Node?] the value returned or thrown by this statement; could be null for AST_Return"
    },
    _walk: function _walk(e) {
      return e._visit(this, this.value && function () {
        this.value._walk(e);
      });
    }
  }, Ge),
      Xe = ue("Return", null, {
    $documentation: "A `return` statement"
  }, He),
      ze = ue("Throw", null, {
    $documentation: "A `throw` statement"
  }, He),
      We = ue("LoopControl", "label", {
    $documentation: "Base class for loop control statements (`break` and `continue`)",
    $propdoc: {
      label: "[AST_LabelRef?] the label, or null if none"
    },
    _walk: function _walk(e) {
      return e._visit(this, this.label && function () {
        this.label._walk(e);
      });
    }
  }, Ge),
      Ye = ue("Break", null, {
    $documentation: "A `break` statement"
  }, We),
      qe = ue("Continue", null, {
    $documentation: "A `continue` statement"
  }, We),
      $e = ue("If", "condition alternative", {
    $documentation: "A `if` statement",
    $propdoc: {
      condition: "[AST_Node] the `if` condition",
      alternative: "[AST_Statement?] the `else` part, or null if not present"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.condition._walk(e), this.body._walk(e), this.alternative && this.alternative._walk(e);
      });
    }
  }, Se),
      je = ue("Switch", "expression", {
    $documentation: "A `switch` statement",
    $propdoc: {
      expression: "[AST_Node] the `switch` “discriminant”"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expression._walk(e), me(this, e);
      });
    }
  }, he),
      Ze = ue("SwitchBranch", null, {
    $documentation: "Base class for `switch` branches"
  }, he),
      Je = ue("Default", null, {
    $documentation: "A `default` switch branch"
  }, Ze),
      Qe = ue("Case", "expression", {
    $documentation: "A `case` switch branch",
    $propdoc: {
      expression: "[AST_Node] the `case` expression"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expression._walk(e), me(this, e);
      });
    }
  }, Ze),
      et = ue("Try", "bcatch bfinally", {
    $documentation: "A `try` statement",
    $propdoc: {
      bcatch: "[AST_Catch?] the catch block, or null if not present",
      bfinally: "[AST_Finally?] the finally block, or null if not present"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        me(this, e), this.bcatch && this.bcatch._walk(e), this.bfinally && this.bfinally._walk(e);
      });
    }
  }, he),
      tt = ue("Catch", "argname", {
    $documentation: "A `catch` node; only makes sense as part of a `try` statement",
    $propdoc: {
      argname: "[AST_SymbolCatch|AST_Destructuring|AST_Expansion|AST_DefaultAssign] symbol for the exception"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.argname && this.argname._walk(e), me(this, e);
      });
    }
  }, he),
      nt = ue("Finally", null, {
    $documentation: "A `finally` node; only makes sense as part of a `try` statement"
  }, he),
      it = ue("Definitions", "definitions", {
    $documentation: "Base class for `var` or `const` nodes (variable declarations/initializations)",
    $propdoc: {
      definitions: "[AST_VarDef*] array of variable definitions"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        for (var t = this.definitions, n = 0, i = t.length; n < i; n++) {
          t[n]._walk(e);
        }
      });
    }
  }, fe),
      rt = ue("Var", null, {
    $documentation: "A `var` statement"
  }, it),
      ot = ue("Let", null, {
    $documentation: "A `let` statement"
  }, it),
      at = ue("Const", null, {
    $documentation: "A `const` statement"
  }, it),
      st = ue("NameMapping", "foreign_name name", {
    $documentation: "The part of the export/import statement that declare names from a module.",
    $propdoc: {
      foreign_name: "[AST_SymbolExportForeign|AST_SymbolImportForeign] The name being exported/imported (as specified in the module)",
      name: "[AST_SymbolExport|AST_SymbolImport] The name as it is visible to this module."
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.foreign_name._walk(e), this.name._walk(e);
      });
    }
  }),
      ut = ue("Import", "imported_name imported_names module_name", {
    $documentation: "An `import` statement",
    $propdoc: {
      imported_name: "[AST_SymbolImport] The name of the variable holding the module's default export.",
      imported_names: "[AST_NameMapping*] The names of non-default imported variables",
      module_name: "[AST_String] String literal describing where this module came from"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.imported_name && this.imported_name._walk(e), this.imported_names && this.imported_names.forEach(function (t) {
          t._walk(e);
        }), this.module_name._walk(e);
      });
    }
  }),
      ct = ue("Export", "exported_definition exported_value is_default exported_names module_name", {
    $documentation: "An `export` statement",
    $propdoc: {
      exported_definition: "[AST_Defun|AST_Definitions|AST_DefClass?] An exported definition",
      exported_value: "[AST_Node?] An exported value",
      exported_names: "[AST_NameMapping*?] List of exported names",
      module_name: "[AST_String?] Name of the file to load exports from",
      is_default: "[Boolean] Whether this is the default exported value of this module"
    },
    _walk: function _walk(e) {
      e._visit(this, function () {
        this.exported_definition && this.exported_definition._walk(e), this.exported_value && this.exported_value._walk(e), this.exported_names && this.exported_names.forEach(function (t) {
          t._walk(e);
        }), this.module_name && this.module_name._walk(e);
      });
    }
  }, fe),
      lt = ue("VarDef", "name value", {
    $documentation: "A variable declaration; only appears in a AST_Definitions node",
    $propdoc: {
      name: "[AST_Destructuring|AST_SymbolConst|AST_SymbolLet|AST_SymbolVar] name of the variable",
      value: "[AST_Node?] initializer, or null of there's no initializer"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.name._walk(e), this.value && this.value._walk(e);
      });
    }
  }),
      ft = ue("Call", "expression args _annotations", {
    $documentation: "A function call expression",
    $propdoc: {
      expression: "[AST_Node] expression to invoke as function",
      args: "[AST_Node*] array of arguments",
      _annotations: "[number] bitfield containing information about the call"
    },
    initialize: function initialize() {
      null == this._annotations && (this._annotations = 0);
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        for (var t = this.args, n = 0, i = t.length; n < i; n++) {
          t[n]._walk(e);
        }

        this.expression._walk(e);
      });
    }
  }),
      pt = ue("New", null, {
    $documentation: "An object instantiation.  Derives from a function call since it has exactly the same properties"
  }, ft),
      _t = ue("Sequence", "expressions", {
    $documentation: "A sequence expression (comma-separated expressions)",
    $propdoc: {
      expressions: "[AST_Node*] array of expressions (at least two)"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expressions.forEach(function (t) {
          t._walk(e);
        });
      });
    }
  }),
      dt = ue("PropAccess", "expression property", {
    $documentation: 'Base class for property access expressions, i.e. `a.foo` or `a["foo"]`',
    $propdoc: {
      expression: "[AST_Node] the “container” expression",
      property: "[AST_Node|string] the property to access.  For AST_Dot this is always a plain string, while for AST_Sub it's an arbitrary AST_Node"
    }
  }),
      mt = ue("Dot", "quote", {
    $documentation: "A dotted property access expression",
    $propdoc: {
      quote: "[string] the original quote character when transformed from AST_Sub"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expression._walk(e);
      });
    }
  }, dt),
      Et = ue("Sub", null, {
    $documentation: 'Index-style property access, i.e. `a["foo"]`',
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expression._walk(e), this.property._walk(e);
      });
    }
  }, dt),
      ht = ue("Unary", "operator expression", {
    $documentation: "Base class for unary expressions",
    $propdoc: {
      operator: "[string] the operator",
      expression: "[AST_Node] expression that this unary operator applies to"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expression._walk(e);
      });
    }
  }),
      Dt = ue("UnaryPrefix", null, {
    $documentation: "Unary prefix expression, i.e. `typeof i` or `++i`"
  }, ht),
      gt = ue("UnaryPostfix", null, {
    $documentation: "Unary postfix expression, i.e. `i++`"
  }, ht),
      St = ue("Binary", "operator left right", {
    $documentation: "Binary expression, i.e. `a + b`",
    $propdoc: {
      left: "[AST_Node] left-hand side expression",
      operator: "[string] the operator",
      right: "[AST_Node] right-hand side expression"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.left._walk(e), this.right._walk(e);
      });
    }
  }),
      At = ue("Conditional", "condition consequent alternative", {
    $documentation: "Conditional expression using the ternary operator, i.e. `a ? b : c`",
    $propdoc: {
      condition: "[AST_Node]",
      consequent: "[AST_Node]",
      alternative: "[AST_Node]"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.condition._walk(e), this.consequent._walk(e), this.alternative._walk(e);
      });
    }
  }),
      vt = ue("Assign", null, {
    $documentation: "An assignment expression — `a = b + 5`"
  }, St),
      Tt = ue("DefaultAssign", null, {
    $documentation: "A default assignment expression like in `(a = 3) => a`"
  }, St),
      bt = ue("Array", "elements", {
    $documentation: "An array literal",
    $propdoc: {
      elements: "[AST_Node*] array of elements"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        for (var t = this.elements, n = 0, i = t.length; n < i; n++) {
          t[n]._walk(e);
        }
      });
    }
  }),
      yt = ue("Object", "properties", {
    $documentation: "An object literal",
    $propdoc: {
      properties: "[AST_ObjectProperty*] array of properties"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        for (var t = this.properties, n = 0, i = t.length; n < i; n++) {
          t[n]._walk(e);
        }
      });
    }
  }),
      Ct = ue("ObjectProperty", "key value", {
    $documentation: "Base class for literal object properties",
    $propdoc: {
      key: "[string|AST_Node] property name. For ObjectKeyVal this is a string. For getters, setters and computed property this is an AST_Node.",
      value: "[AST_Node] property value.  For getters and setters this is an AST_Accessor."
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.key instanceof le && this.key._walk(e), this.value._walk(e);
      });
    }
  }),
      Ot = ue("ObjectKeyVal", "quote", {
    $documentation: "A key: value object property",
    $propdoc: {
      quote: "[string] the original quote character"
    }
  }, Ct),
      Ft = ue("ObjectSetter", "quote static", {
    $propdoc: {
      quote: "[string|undefined] the original quote character, if any",
      static: "[boolean] whether this is a static setter (classes only)"
    },
    $documentation: "An object setter property"
  }, Ct),
      Mt = ue("ObjectGetter", "quote static", {
    $propdoc: {
      quote: "[string|undefined] the original quote character, if any",
      static: "[boolean] whether this is a static getter (classes only)"
    },
    $documentation: "An object getter property"
  }, Ct),
      Rt = ue("ConciseMethod", "quote static is_generator async", {
    $propdoc: {
      quote: "[string|undefined] the original quote character, if any",
      static: "[boolean] is this method static (classes only)",
      is_generator: "[boolean] is this a generator method",
      async: "[boolean] is this method async"
    },
    $documentation: "An ES6 concise method inside an object or class"
  }, Ct),
      wt = ue("Class", "name extends properties", {
    $propdoc: {
      name: "[AST_SymbolClass|AST_SymbolDefClass?] optional class name.",
      extends: "[AST_Node]? optional parent class",
      properties: "[AST_ObjectProperty*] array of properties"
    },
    $documentation: "An ES6 class",
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.name && this.name._walk(e), this.extends && this.extends._walk(e), this.properties.forEach(function (t) {
          return t._walk(e);
        });
      });
    }
  }, Re),
      Nt = ue("DefClass", null, {
    $documentation: "A class definition"
  }, wt),
      xt = ue("ClassExpression", null, {
    $documentation: "A class expression."
  }, wt),
      kt = ue("Symbol", "scope name thedef", {
    $propdoc: {
      name: "[string] name of this symbol",
      scope: "[AST_Scope/S] the current scope (not necessarily the definition scope)",
      thedef: "[SymbolDef/S] the definition of this symbol"
    },
    $documentation: "Base class for all symbols"
  }),
      It = ue("NewTarget", null, {
    $documentation: "A reference to new.target"
  }),
      Lt = ue("SymbolDeclaration", "init", {
    $documentation: "A declaration symbol (symbol in var/const, function name or argument, symbol in catch)"
  }, kt),
      Vt = ue("SymbolVar", null, {
    $documentation: "Symbol defining a variable"
  }, Lt),
      Pt = ue("SymbolBlockDeclaration", null, {
    $documentation: "Base class for block-scoped declaration symbols"
  }, Lt),
      Bt = ue("SymbolConst", null, {
    $documentation: "A constant declaration"
  }, Pt),
      Kt = ue("SymbolLet", null, {
    $documentation: "A block-scoped `let` declaration"
  }, Pt),
      Ut = ue("SymbolFunarg", null, {
    $documentation: "Symbol naming a function argument"
  }, Vt),
      Gt = ue("SymbolDefun", null, {
    $documentation: "Symbol defining a function"
  }, Lt),
      Ht = ue("SymbolMethod", null, {
    $documentation: "Symbol in an object defining a method"
  }, kt),
      Xt = ue("SymbolLambda", null, {
    $documentation: "Symbol naming a function expression"
  }, Lt),
      zt = ue("SymbolDefClass", null, {
    $documentation: "Symbol naming a class's name in a class declaration. Lexically scoped to its containing scope, and accessible within the class."
  }, Pt),
      Wt = ue("SymbolClass", null, {
    $documentation: "Symbol naming a class's name. Lexically scoped to the class."
  }, Lt),
      Yt = ue("SymbolCatch", null, {
    $documentation: "Symbol naming the exception in catch"
  }, Pt),
      qt = ue("SymbolImport", null, {
    $documentation: "Symbol referring to an imported name"
  }, Pt),
      $t = ue("SymbolImportForeign", null, {
    $documentation: "A symbol imported from a module, but it is defined in the other module, and its real name is irrelevant for this module's purposes"
  }, kt),
      jt = ue("Label", "references", {
    $documentation: "Symbol naming a label (declaration)",
    $propdoc: {
      references: "[AST_LoopControl*] a list of nodes referring to this label"
    },
    initialize: function initialize() {
      this.references = [], this.thedef = this;
    }
  }, kt),
      Zt = ue("SymbolRef", null, {
    $documentation: "Reference to some symbol (not definition/declaration)"
  }, kt),
      Jt = ue("SymbolExport", null, {
    $documentation: "Symbol referring to a name to export"
  }, Zt),
      Qt = ue("SymbolExportForeign", null, {
    $documentation: "A symbol exported from this module, but it is used in the other module, and its real name is irrelevant for this module's purposes"
  }, kt),
      en = ue("LabelRef", null, {
    $documentation: "Reference to a label symbol"
  }, kt),
      tn = ue("This", null, {
    $documentation: "The `this` symbol"
  }, kt),
      nn = ue("Super", null, {
    $documentation: "The `super` symbol"
  }, tn),
      rn = ue("Constant", null, {
    $documentation: "Base class for all constants",
    getValue: function getValue() {
      return this.value;
    }
  }),
      on = ue("String", "value quote", {
    $documentation: "A string literal",
    $propdoc: {
      value: "[string] the contents of this string",
      quote: "[string] the original quote character"
    }
  }, rn),
      an = ue("Number", "value literal", {
    $documentation: "A number literal",
    $propdoc: {
      value: "[number] the numeric value",
      literal: "[string] numeric value as string (optional)"
    }
  }, rn),
      sn = ue("BigInt", "value", {
    $documentation: "A big int literal",
    $propdoc: {
      value: "[string] big int value"
    }
  }, rn),
      un = ue("RegExp", "value", {
    $documentation: "A regexp literal",
    $propdoc: {
      value: "[RegExp] the actual regexp"
    }
  }, rn),
      cn = ue("Atom", null, {
    $documentation: "Base class for atoms"
  }, rn),
      ln = ue("Null", null, {
    $documentation: "The `null` atom",
    value: null
  }, cn),
      fn = ue("NaN", null, {
    $documentation: "The impossible value",
    value: NaN
  }, cn),
      pn = ue("Undefined", null, {
    $documentation: "The `undefined` value",
    value: void 0
  }, cn),
      _n = ue("Hole", null, {
    $documentation: "A hole in an array",
    value: void 0
  }, cn),
      dn = ue("Infinity", null, {
    $documentation: "The `Infinity` value",
    value: 1 / 0
  }, cn),
      mn = ue("Boolean", null, {
    $documentation: "Base class for booleans"
  }, cn),
      En = ue("False", null, {
    $documentation: "The `false` atom",
    value: !1
  }, mn),
      hn = ue("True", null, {
    $documentation: "The `true` atom",
    value: !0
  }, mn),
      Dn = ue("Await", "expression", {
    $documentation: "An `await` statement",
    $propdoc: {
      expression: "[AST_Node] the mandatory expression being awaited"
    },
    _walk: function _walk(e) {
      return e._visit(this, function () {
        this.expression._walk(e);
      });
    }
  }),
      gn = ue("Yield", "expression is_star", {
    $documentation: "A `yield` statement",
    $propdoc: {
      expression: "[AST_Node?] the value returned or thrown by this statement; could be null (representing undefined) but only when is_star is set to false",
      is_star: "[Boolean] Whether this is a yield or yield* statement"
    },
    _walk: function _walk(e) {
      return e._visit(this, this.expression && function () {
        this.expression._walk(e);
      });
    }
  });

  var Sn =
  /*#__PURE__*/
  function () {
    function Sn(e) {
      _classCallCheck(this, Sn);

      this.visit = e, this.stack = [], this.directives = Object.create(null);
    }

    _createClass(Sn, [{
      key: "_visit",
      value: function _visit(e, t) {
        this.push(e);
        var n = this.visit(e, t ? function () {
          t.call(e);
        } : a);
        return !n && t && t.call(e), this.pop(), n;
      }
    }, {
      key: "parent",
      value: function parent(e) {
        return this.stack[this.stack.length - 2 - (e || 0)];
      }
    }, {
      key: "push",
      value: function push(e) {
        e instanceof xe ? this.directives = Object.create(this.directives) : e instanceof _e && !this.directives[e.value] ? this.directives[e.value] = e : e instanceof wt && (this.directives = Object.create(this.directives), this.directives["use strict"] || (this.directives["use strict"] = e)), this.stack.push(e);
      }
    }, {
      key: "pop",
      value: function pop() {
        var e = this.stack.pop();
        (e instanceof xe || e instanceof wt) && (this.directives = Object.getPrototypeOf(this.directives));
      }
    }, {
      key: "self",
      value: function self() {
        return this.stack[this.stack.length - 1];
      }
    }, {
      key: "find_parent",
      value: function find_parent(e) {
        for (var t = this.stack, n = t.length; --n >= 0;) {
          var i = t[n];
          if (i instanceof e) return i;
        }
      }
    }, {
      key: "has_directive",
      value: function has_directive(e) {
        var t = this.directives[e];
        if (t) return t;
        var n = this.stack[this.stack.length - 1];
        if (n instanceof Re && n.body) for (var i = 0; i < n.body.length; ++i) {
          var r = n.body[i];
          if (!(r instanceof _e)) break;
          if (r.value == e) return r;
        }
      }
    }, {
      key: "loopcontrol_target",
      value: function loopcontrol_target(e) {
        var t = this.stack;
        if (e.label) for (var n = t.length; --n >= 0;) {
          if ((i = t[n]) instanceof Ae && i.label.name == e.label.name) return i.body;
        } else for (n = t.length; --n >= 0;) {
          var i;
          if ((i = t[n]) instanceof ve || e instanceof Ye && i instanceof je) return i;
        }
      }
    }]);

    return Sn;
  }();

  var An =
  /*#__PURE__*/
  function (_Sn) {
    _inherits(An, _Sn);

    function An(e, t) {
      var _this3;

      _classCallCheck(this, An);

      _this3 = _possibleConstructorReturn(this, _getPrototypeOf(An).call(this)), _this3.before = e, _this3.after = t;
      return _this3;
    }

    return An;
  }(Sn);

  var vn = 1,
      Tn = 2,
      bn = 4;
  var yn = Object.freeze({
    __proto__: null,
    AST_Accessor: ke,
    AST_Array: bt,
    AST_Arrow: Le,
    AST_Assign: vt,
    AST_Atom: cn,
    AST_Await: Dn,
    AST_BigInt: sn,
    AST_Binary: St,
    AST_Block: he,
    AST_BlockStatement: De,
    AST_Boolean: mn,
    AST_Break: Ye,
    AST_Call: ft,
    AST_Case: Qe,
    AST_Catch: tt,
    AST_Class: wt,
    AST_ClassExpression: xt,
    AST_ConciseMethod: Rt,
    AST_Conditional: At,
    AST_Const: at,
    AST_Constant: rn,
    AST_Continue: qe,
    AST_Debugger: pe,
    AST_Default: Je,
    AST_DefaultAssign: Tt,
    AST_DefClass: Nt,
    AST_Definitions: it,
    AST_Defun: Ve,
    AST_Destructuring: Pe,
    AST_Directive: _e,
    AST_Do: be,
    AST_Dot: mt,
    AST_DWLoop: Te,
    AST_EmptyStatement: ge,
    AST_Exit: He,
    AST_Expansion: Ne,
    AST_Export: ct,
    AST_False: En,
    AST_Finally: nt,
    AST_For: Ce,
    AST_ForIn: Oe,
    AST_ForOf: Fe,
    AST_Function: Ie,
    AST_Hole: _n,
    AST_If: $e,
    AST_Import: ut,
    AST_Infinity: dn,
    AST_IterationStatement: ve,
    AST_Jump: Ge,
    AST_Label: jt,
    AST_LabeledStatement: Ae,
    AST_LabelRef: en,
    AST_Lambda: xe,
    AST_Let: ot,
    AST_LoopControl: We,
    AST_NameMapping: st,
    AST_NaN: fn,
    AST_New: pt,
    AST_NewTarget: It,
    AST_Node: le,
    AST_Null: ln,
    AST_Number: an,
    AST_Object: yt,
    AST_ObjectGetter: Mt,
    AST_ObjectKeyVal: Ot,
    AST_ObjectProperty: Ct,
    AST_ObjectSetter: Ft,
    AST_PrefixedTemplateString: Be,
    AST_PropAccess: dt,
    AST_RegExp: un,
    AST_Return: Xe,
    AST_Scope: Re,
    AST_Sequence: _t,
    AST_SimpleStatement: de,
    AST_Statement: fe,
    AST_StatementWithBody: Se,
    AST_String: on,
    AST_Sub: Et,
    AST_Super: nn,
    AST_Switch: je,
    AST_SwitchBranch: Ze,
    AST_Symbol: kt,
    AST_SymbolBlockDeclaration: Pt,
    AST_SymbolCatch: Yt,
    AST_SymbolClass: Wt,
    AST_SymbolConst: Bt,
    AST_SymbolDeclaration: Lt,
    AST_SymbolDefClass: zt,
    AST_SymbolDefun: Gt,
    AST_SymbolExport: Jt,
    AST_SymbolExportForeign: Qt,
    AST_SymbolFunarg: Ut,
    AST_SymbolImport: qt,
    AST_SymbolImportForeign: $t,
    AST_SymbolLambda: Xt,
    AST_SymbolLet: Kt,
    AST_SymbolMethod: Ht,
    AST_SymbolRef: Zt,
    AST_SymbolVar: Vt,
    AST_TemplateSegment: Ue,
    AST_TemplateString: Ke,
    AST_This: tn,
    AST_Throw: ze,
    AST_Token: ce,
    AST_Toplevel: we,
    AST_True: hn,
    AST_Try: et,
    AST_Unary: ht,
    AST_UnaryPostfix: gt,
    AST_UnaryPrefix: Dt,
    AST_Undefined: pn,
    AST_Var: rt,
    AST_VarDef: lt,
    AST_While: ye,
    AST_With: Me,
    AST_Yield: gn,
    TreeTransformer: An,
    TreeWalker: Sn,
    walk_body: me,
    _INLINE: Tn,
    _NOINLINE: bn,
    _PURE: vn
  });

  function Cn(e, t) {
    e.DEFMETHOD("transform", function (e, n) {
      var i = void 0;

      if (e.push(this), e.before && (i = e.before(this, t, n)), void 0 === i && (t(i = this, e), e.after)) {
        var _t2 = e.after(i, n);

        void 0 !== _t2 && (i = _t2);
      }

      return e.pop(), i;
    });
  }

  function On(e, t) {
    return f(e, function (e) {
      return e.transform(t, !0);
    });
  }

  function Fn(e) {
    var t = e.parent(-1);

    for (var _n2, _i2 = 0; _n2 = e.parent(_i2); _i2++) {
      if (_n2 instanceof fe && _n2.body === t) return !0;
      if (!(_n2 instanceof _t && _n2.expressions[0] === t || "Call" === _n2.TYPE && _n2.expression === t || _n2 instanceof Be && _n2.prefix === t || _n2 instanceof mt && _n2.expression === t || _n2 instanceof Et && _n2.expression === t || _n2 instanceof At && _n2.condition === t || _n2 instanceof St && _n2.left === t || _n2 instanceof gt && _n2.expression === t)) return !1;
      t = _n2;
    }
  }

  Cn(le, a), Cn(Ae, function (e, t) {
    e.label = e.label.transform(t), e.body = e.body.transform(t);
  }), Cn(de, function (e, t) {
    e.body = e.body.transform(t);
  }), Cn(he, function (e, t) {
    e.body = On(e.body, t);
  }), Cn(be, function (e, t) {
    e.body = e.body.transform(t), e.condition = e.condition.transform(t);
  }), Cn(ye, function (e, t) {
    e.condition = e.condition.transform(t), e.body = e.body.transform(t);
  }), Cn(Ce, function (e, t) {
    e.init && (e.init = e.init.transform(t)), e.condition && (e.condition = e.condition.transform(t)), e.step && (e.step = e.step.transform(t)), e.body = e.body.transform(t);
  }), Cn(Oe, function (e, t) {
    e.init = e.init.transform(t), e.object = e.object.transform(t), e.body = e.body.transform(t);
  }), Cn(Me, function (e, t) {
    e.expression = e.expression.transform(t), e.body = e.body.transform(t);
  }), Cn(He, function (e, t) {
    e.value && (e.value = e.value.transform(t));
  }), Cn(We, function (e, t) {
    e.label && (e.label = e.label.transform(t));
  }), Cn($e, function (e, t) {
    e.condition = e.condition.transform(t), e.body = e.body.transform(t), e.alternative && (e.alternative = e.alternative.transform(t));
  }), Cn(je, function (e, t) {
    e.expression = e.expression.transform(t), e.body = On(e.body, t);
  }), Cn(Qe, function (e, t) {
    e.expression = e.expression.transform(t), e.body = On(e.body, t);
  }), Cn(et, function (e, t) {
    e.body = On(e.body, t), e.bcatch && (e.bcatch = e.bcatch.transform(t)), e.bfinally && (e.bfinally = e.bfinally.transform(t));
  }), Cn(tt, function (e, t) {
    e.argname && (e.argname = e.argname.transform(t)), e.body = On(e.body, t);
  }), Cn(it, function (e, t) {
    e.definitions = On(e.definitions, t);
  }), Cn(lt, function (e, t) {
    e.name = e.name.transform(t), e.value && (e.value = e.value.transform(t));
  }), Cn(Pe, function (e, t) {
    e.names = On(e.names, t);
  }), Cn(xe, function (e, t) {
    e.name && (e.name = e.name.transform(t)), e.argnames = On(e.argnames, t), e.body instanceof le ? e.body = e.body.transform(t) : e.body = On(e.body, t);
  }), Cn(ft, function (e, t) {
    e.expression = e.expression.transform(t), e.args = On(e.args, t);
  }), Cn(_t, function (e, t) {
    var n = On(e.expressions, t);
    e.expressions = n.length ? n : [new an({
      value: 0
    })];
  }), Cn(mt, function (e, t) {
    e.expression = e.expression.transform(t);
  }), Cn(Et, function (e, t) {
    e.expression = e.expression.transform(t), e.property = e.property.transform(t);
  }), Cn(gn, function (e, t) {
    e.expression && (e.expression = e.expression.transform(t));
  }), Cn(Dn, function (e, t) {
    e.expression = e.expression.transform(t);
  }), Cn(ht, function (e, t) {
    e.expression = e.expression.transform(t);
  }), Cn(St, function (e, t) {
    e.left = e.left.transform(t), e.right = e.right.transform(t);
  }), Cn(At, function (e, t) {
    e.condition = e.condition.transform(t), e.consequent = e.consequent.transform(t), e.alternative = e.alternative.transform(t);
  }), Cn(bt, function (e, t) {
    e.elements = On(e.elements, t);
  }), Cn(yt, function (e, t) {
    e.properties = On(e.properties, t);
  }), Cn(Ct, function (e, t) {
    e.key instanceof le && (e.key = e.key.transform(t)), e.value = e.value.transform(t);
  }), Cn(wt, function (e, t) {
    e.name && (e.name = e.name.transform(t)), e.extends && (e.extends = e.extends.transform(t)), e.properties = On(e.properties, t);
  }), Cn(Ne, function (e, t) {
    e.expression = e.expression.transform(t);
  }), Cn(st, function (e, t) {
    e.foreign_name = e.foreign_name.transform(t), e.name = e.name.transform(t);
  }), Cn(ut, function (e, t) {
    e.imported_name && (e.imported_name = e.imported_name.transform(t)), e.imported_names && On(e.imported_names, t), e.module_name = e.module_name.transform(t);
  }), Cn(ct, function (e, t) {
    e.exported_definition && (e.exported_definition = e.exported_definition.transform(t)), e.exported_value && (e.exported_value = e.exported_value.transform(t)), e.exported_names && On(e.exported_names, t), e.module_name && (e.module_name = e.module_name.transform(t));
  }), Cn(Ke, function (e, t) {
    e.segments = On(e.segments, t);
  }), Cn(Be, function (e, t) {
    e.prefix = e.prefix.transform(t), e.template_string = e.template_string.transform(t);
  });
  var Mn = /^$|[;{][\s\n]*$/,
      Rn = 10,
      wn = 32,
      Nn = /[@#]__(PURE|INLINE|NOINLINE)__/g;

  function xn(e) {
    return "comment2" == e.type && /@preserve|@lic|@cc_on|^\**!/i.test(e.value);
  }

  function kn(e) {
    var t = !e;
    void 0 === (e = o(e, {
      ascii_only: !1,
      beautify: !1,
      braces: !1,
      comments: "some",
      ecma: 5,
      ie8: !1,
      indent_level: 4,
      indent_start: 0,
      inline_script: !0,
      keep_quoted_props: !1,
      max_line_len: !1,
      preamble: null,
      quote_keys: !1,
      quote_style: 0,
      safari10: !1,
      semicolons: !0,
      shebang: !0,
      shorthand: void 0,
      source_map: null,
      webkit: !1,
      width: 80,
      wrap_iife: !1,
      wrap_func_args: !0
    }, !0)).shorthand && (e.shorthand = e.ecma > 5);
    var n = s;

    if (e.comments) {
      var _t3 = e.comments;

      if ("string" == typeof e.comments && /^\/.*\/[a-zA-Z]*$/.test(e.comments)) {
        var i = e.comments.lastIndexOf("/");
        _t3 = new RegExp(e.comments.substr(1, i - 1), e.comments.substr(i + 1));
      }

      n = _t3 instanceof RegExp ? function (e) {
        return "comment5" != e.type && _t3.test(e.value);
      } : "function" == typeof _t3 ? function (e) {
        return "comment5" != e.type && _t3(this, e);
      } : "some" === _t3 ? xn : u;
    }

    var r = 0,
        c = 0,
        l = 1,
        f = 0,
        p = "";

    var _ = new Set();

    var d = e.ascii_only ? function (t, n) {
      return e.ecma >= 6 && (t = t.replace(/[\ud800-\udbff][\udc00-\udfff]/g, function (e) {
        return "\\u{" + function (e, t) {
          return z(e.charAt(t)) ? 65536 + (e.charCodeAt(t) - 55296 << 10) + e.charCodeAt(t + 1) - 56320 : e.charCodeAt(t);
        }(e, 0).toString(16) + "}";
      })), t.replace(/[\u0000-\u001f\u007f-\uffff]/g, function (e) {
        var t = e.charCodeAt(0).toString(16);

        if (t.length <= 2 && !n) {
          for (; t.length < 2;) {
            t = "0" + t;
          }

          return "\\x" + t;
        }

        for (; t.length < 4;) {
          t = "0" + t;
        }

        return "\\u" + t;
      });
    } : function (e) {
      for (var t = "", n = 0, i = e.length; n < i; n++) {
        z(e[n]) && !W(e[n + 1]) || W(e[n]) && !z(e[n - 1]) ? t += "\\u" + e.charCodeAt(n).toString(16) : t += e[n];
      }

      return t;
    };

    function m(t, n) {
      var i = function (t, n) {
        var i = 0,
            r = 0;

        function o() {
          return "'" + t.replace(/\x27/g, "\\'") + "'";
        }

        function a() {
          return '"' + t.replace(/\x22/g, '\\"') + '"';
        }

        if (t = t.replace(/[\\\b\f\n\r\v\t\x22\x27\u2028\u2029\0\ufeff]/g, function (n, o) {
          switch (n) {
            case '"':
              return ++i, '"';

            case "'":
              return ++r, "'";

            case "\\":
              return "\\\\";

            case "\n":
              return "\\n";

            case "\r":
              return "\\r";

            case "\t":
              return "\\t";

            case "\b":
              return "\\b";

            case "\f":
              return "\\f";

            case "\v":
              return e.ie8 ? "\\x0B" : "\\v";

            case "\u2028":
              return "\\u2028";

            case "\u2029":
              return "\\u2029";

            case "\uFEFF":
              return "\\ufeff";

            case "\0":
              return /[0-9]/.test(X(t, o + 1)) ? "\\x00" : "\\0";
          }

          return n;
        }), t = d(t), "`" === n) return "`" + t.replace(/`/g, "\\`") + "`";

        switch (e.quote_style) {
          case 1:
            return o();

          case 2:
            return a();

          case 3:
            return "'" == n ? o() : a();

          default:
            return i > r ? o() : a();
        }
      }(t, n);

      return e.inline_script && (i = (i = (i = i.replace(/<\x2f(script)([>\/\t\n\f\r ])/gi, "<\\/$1$2")).replace(/\x3c!--/g, "\\x3c!--")).replace(/--\x3e/g, "--\\x3e")), i;
    }

    var h,
        D,
        g = !1,
        S = !1,
        A = !1,
        v = 0,
        T = !1,
        b = !1,
        y = -1,
        C = "",
        O = e.source_map && [],
        F = O ? function () {
      O.forEach(function (t) {
        try {
          e.source_map.add(t.token.file, t.line, t.col, t.token.line, t.token.col, t.name || "name" != t.token.type ? t.name : t.token.value);
        } catch (e) {
          null != t.token.file && le.warn("Couldn't figure out mapping for {file}:{line},{col} → {cline},{ccol} [{name}]", {
            file: t.token.file,
            line: t.token.line,
            col: t.token.col,
            cline: t.line,
            ccol: t.col,
            name: t.name || ""
          });
        }
      }), O = [];
    } : a,
        M = e.max_line_len ? function () {
      if (c > e.max_line_len) {
        if (v) {
          var t = p.slice(0, v),
              n = p.slice(v);

          if (O) {
            var i = n.length - c;
            O.forEach(function (e) {
              e.line++, e.col += i;
            });
          }

          p = t + "\n" + n, l++, f++, c = n.length;
        }

        c > e.max_line_len && le.warn("Output exceeds {max_line_len} characters", e);
      }

      v && (v = 0, F());
    } : a,
        R = E("( [ + * / - , . `");

    function w(t) {
      var n = X(t = String(t), 0);
      T && n && (T = !1, "\n" !== n && (w("\n"), x())), b && n && (b = !1, /[\s;})]/.test(n) || N()), y = -1;
      var i = C.charAt(C.length - 1);
      A && (A = !1, (":" !== i || "}" !== n) && (n && ";}".includes(n) || ";" === i) || (e.semicolons || R.has(n) ? (p += ";", c++, f++) : (M(), c > 0 && (p += "\n", f++, l++, c = 0), /^\s+$/.test(t) && (A = !0)), e.beautify || (S = !1))), S && (($(i) && ($(n) || "\\" == n) || "/" == n && n == i || ("+" == n || "-" == n) && n == C) && (p += " ", c++, f++), S = !1), h && (O.push({
        token: h,
        name: D,
        line: l,
        col: c
      }), h = !1, v || F()), p += t, g = "(" == t[t.length - 1], f += t.length;
      var r = t.split(/\r?\n/),
          o = r.length - 1;
      l += o, c += r[0].length, o > 0 && (M(), c = r[o].length), C = t;
    }

    var N = e.beautify ? function () {
      w(" ");
    } : function () {
      S = !0;
    },
        x = e.beautify ? function (t) {
      var n;
      e.beautify && w((n = t ? .5 : 0, " ".repeat(e.indent_start + r - n * e.indent_level)));
    } : a,
        k = e.beautify ? function (e, t) {
      !0 === e && (e = P());
      var n = r;
      r = e;
      var i = t();
      return r = n, i;
    } : function (e, t) {
      return t();
    },
        I = e.beautify ? function () {
      if (y < 0) return w("\n");
      "\n" != p[y] && (p = p.slice(0, y) + "\n" + p.slice(y), f++, l++), y++;
    } : e.max_line_len ? function () {
      M(), v = p.length;
    } : a,
        L = e.beautify ? function () {
      w(";");
    } : function () {
      A = !0;
    };

    function V() {
      A = !1, w(";");
    }

    function P() {
      return r + e.indent_level;
    }

    function B() {
      return v && M(), p;
    }

    function K() {
      var e = p.length - 1;

      for (; e >= 0;) {
        var _t4 = p.charCodeAt(e);

        if (_t4 === Rn) return !0;
        if (_t4 !== wn) return !1;
        e--;
      }

      return !0;
    }

    var U = [];
    return {
      get: B,
      toString: B,
      indent: x,
      indentation: function indentation() {
        return r;
      },
      current_width: function current_width() {
        return c - r;
      },
      should_break: function should_break() {
        return e.width && this.current_width() >= e.width;
      },
      has_parens: function has_parens() {
        return g;
      },
      newline: I,
      print: w,
      star: function star() {
        w("*");
      },
      space: N,
      comma: function comma() {
        w(","), N();
      },
      colon: function colon() {
        w(":"), N();
      },
      last: function last() {
        return C;
      },
      semicolon: L,
      force_semicolon: V,
      to_utf8: d,
      print_name: function print_name(e) {
        w(function (e) {
          return e = e.toString(), e = d(e, !0);
        }(e));
      },
      print_string: function print_string(e, t, n) {
        var i = m(e, t);
        !0 !== n || i.includes("\\") || (Mn.test(p) || V(), V()), w(i);
      },
      print_template_string_chars: function print_template_string_chars(e) {
        var t = m(e, "`").replace(/\${/g, "\\${");
        return w(t.substr(1, t.length - 2));
      },
      encode_string: m,
      next_indent: P,
      with_indent: k,
      with_block: function with_block(e) {
        var t;
        return w("{"), I(), k(P(), function () {
          t = e();
        }), x(), w("}"), t;
      },
      with_parens: function with_parens(e) {
        w("(");
        var t = e();
        return w(")"), t;
      },
      with_square: function with_square(e) {
        w("[");
        var t = e();
        return w("]"), t;
      },
      add_mapping: O ? function (e, t) {
        h = e, D = t;
      } : a,
      option: function option(t) {
        return e[t];
      },
      printed_comments: _,
      prepend_comments: t ? a : function (t) {
        var i = t.start;

        if (i) {
          var r = this.printed_comments;

          if (!i.comments_before || !r.has(i.comments_before)) {
            var o = i.comments_before;

            if (o || (o = i.comments_before = []), r.add(o), t instanceof He && t.value) {
              var a = new Sn(function (e) {
                var t = a.parent();
                if (!(t instanceof He || t instanceof St && t.left === e || "Call" == t.TYPE && t.expression === e || t instanceof At && t.condition === e || t instanceof mt && t.expression === e || t instanceof _t && t.expressions[0] === e || t instanceof Et && t.expression === e || t instanceof gt)) return !0;

                if (e.start) {
                  var n = e.start.comments_before;
                  n && !r.has(n) && (r.add(n), o = o.concat(n));
                }
              });
              a.push(t), t.value.walk(a);
            }

            if (0 == f) {
              o.length > 0 && e.shebang && "comment5" === o[0].type && !r.has(o[0]) && (w("#!" + o.shift().value + "\n"), x());
              var s = e.preamble;
              s && w(s.replace(/\r\n?|[\n\u2028\u2029]|\s*$/g, "\n"));
            }

            if (0 != (o = o.filter(n, t).filter(function (e) {
              return !r.has(e);
            })).length) {
              var u = K();
              o.forEach(function (e, t) {
                r.add(e), u || (e.nlb ? (w("\n"), x(), u = !0) : t > 0 && N()), /comment[134]/.test(e.type) ? (w("//" + e.value.replace(Nn, " ") + "\n"), x(), u = !0) : "comment2" == e.type && (w("/*" + e.value.replace(Nn, " ") + "*/"), u = !1);
              }), u || (i.nlb ? (w("\n"), x()) : N());
            }
          }
        }
      },
      append_comments: t || n === s ? a : function (e, t) {
        var i = e.end;

        if (i) {
          var r = this.printed_comments,
              o = i[t ? "comments_before" : "comments_after"];

          if (o && !r.has(o) && (e instanceof fe || o.every(function (e) {
            return !/comment[134]/.test(e.type);
          }))) {
            r.add(o);
            var a = p.length;
            o.filter(n, e).forEach(function (e, n) {
              r.has(e) || (r.add(e), b = !1, T ? (w("\n"), x(), T = !1) : e.nlb && (n > 0 || !K()) ? (w("\n"), x()) : (n > 0 || !t) && N(), /comment[134]/.test(e.type) ? (w("//" + e.value.replace(Nn, " ")), T = !0) : "comment2" == e.type && (w("/*" + e.value.replace(Nn, " ") + "*/"), b = !0));
            }), p.length > a && (y = a);
          }
        }
      },
      line: function line() {
        return l;
      },
      col: function col() {
        return c;
      },
      pos: function pos() {
        return f;
      },
      push_node: function push_node(e) {
        U.push(e);
      },
      pop_node: function pop_node() {
        return U.pop();
      },
      parent: function parent(e) {
        return U[U.length - 2 - (e || 0)];
      }
    };
  }

  !function () {
    function e(e, t) {
      e.DEFMETHOD("_codegen", t);
    }

    var t = !1,
        n = null,
        i = null;

    function r(e, t) {
      Array.isArray(e) ? e.forEach(function (e) {
        r(e, t);
      }) : e.DEFMETHOD("needs_parens", t);
    }

    function o(e, n, i, r) {
      var o = e.length - 1;
      t = r, e.forEach(function (e, r) {
        !0 !== t || e instanceof _e || e instanceof ge || e instanceof de && e.body instanceof on || (t = !1), e instanceof ge || (i.indent(), e.print(i), r == o && n || (i.newline(), n && i.newline())), !0 === t && e instanceof de && e.body instanceof on && (t = !1);
      }), t = !1;
    }

    function u(e, t) {
      t.print("{"), t.with_indent(t.next_indent(), function () {
        t.append_comments(e, !0);
      }), t.print("}");
    }

    function c(e, t, n) {
      e.body.length > 0 ? t.with_block(function () {
        o(e.body, !1, t, n);
      }) : u(e, t);
    }

    function l(e, t, n) {
      var i = !1;
      n && e.walk(new Sn(function (e) {
        return !!(i || e instanceof Re) || (e instanceof St && "in" == e.operator ? (i = !0, !0) : void 0);
      })), e.print(t, i);
    }

    function f(e, t, n) {
      n.option("quote_keys") ? n.print_string(e) : "" + +e == e && e >= 0 ? n.print(_(e)) : (O.has(e) ? !n.option("ie8") : j(e)) ? t && n.option("keep_quoted_props") ? n.print_string(e, t) : n.print_name(e) : n.print_string(e, t);
    }

    function p(e, t) {
      t.option("braces") ? d(e, t) : !e || e instanceof ge ? t.force_semicolon() : e.print(t);
    }

    function _(e) {
      var t,
          n,
          i,
          r = e.toString(10).replace(/^0\./, ".").replace("e+", "e"),
          o = [r];
      return Math.floor(e) === e && (e < 0 ? o.push("-0x" + (-e).toString(16).toLowerCase()) : o.push("0x" + e.toString(16).toLowerCase())), (t = /^\.0+/.exec(r)) ? (n = t[0].length, i = r.slice(n), o.push(i + "e-" + (i.length + n - 1))) : (t = /0+$/.exec(r)) ? (n = t[0].length, o.push(r.slice(0, -n) + "e" + n)) : (t = /^(\d)\.(\d+)e(-?\d+)$/.exec(r)) && o.push(t[1] + t[2] + "e" + (t[3] - t[2].length)), function (e) {
        for (var t = e[0], n = t.length, i = 1; i < e.length; ++i) {
          e[i].length < n && (n = (t = e[i]).length);
        }

        return t;
      }(o);
    }

    function d(e, t) {
      !e || e instanceof ge ? t.print("{}") : e instanceof De ? e.print(t) : t.with_block(function () {
        t.indent(), e.print(t), t.newline();
      });
    }

    function m(e, t) {
      e.forEach(function (e) {
        e.DEFMETHOD("add_source_map", t);
      });
    }

    le.DEFMETHOD("print", function (e, t) {
      var r = this,
          o = r._codegen;

      function a() {
        e.prepend_comments(r), r.add_source_map(e), o(r, e), e.append_comments(r);
      }

      r instanceof Re ? n = r : !i && r instanceof _e && "use asm" == r.value && (i = n), e.push_node(r), t || r.needs_parens(e) ? e.with_parens(a) : a(), e.pop_node(), r === i && (i = null);
    }), le.DEFMETHOD("_print", le.prototype.print), le.DEFMETHOD("print_to_string", function (e) {
      var t = kn(e);
      return this.print(t), t.get();
    }), r(le, s), r(Ie, function (e) {
      if (!e.has_parens() && Fn(e)) return !0;
      var t;
      if (e.option("webkit") && (t = e.parent()) instanceof dt && t.expression === this) return !0;
      if (e.option("wrap_iife") && (t = e.parent()) instanceof ft && t.expression === this) return !0;
      if (e.option("wrap_func_args") && (t = e.parent()) instanceof ft && t.args.includes(this)) return !0;
      return !1;
    }), r(Le, function (e) {
      var t = e.parent();
      return t instanceof dt && t.expression === this;
    }), r(yt, function (e) {
      return !e.has_parens() && Fn(e);
    }), r(xt, Fn), r(ht, function (e) {
      var t = e.parent();
      return t instanceof dt && t.expression === this || t instanceof ft && t.expression === this || t instanceof St && "**" === t.operator && this instanceof Dt && t.left === this && "++" !== this.operator && "--" !== this.operator;
    }), r(Dn, function (e) {
      var t = e.parent();
      return t instanceof dt && t.expression === this || t instanceof ft && t.expression === this || e.option("safari10") && t instanceof Dt;
    }), r(_t, function (e) {
      var t = e.parent();
      return t instanceof ft || t instanceof ht || t instanceof St || t instanceof lt || t instanceof dt || t instanceof bt || t instanceof Ct || t instanceof At || t instanceof Le || t instanceof Tt || t instanceof Ne || t instanceof Fe && this === t.object || t instanceof gn || t instanceof ct;
    }), r(St, function (e) {
      var t = e.parent();
      if (t instanceof ft && t.expression === this) return !0;
      if (t instanceof ht) return !0;
      if (t instanceof dt && t.expression === this) return !0;

      if (t instanceof St) {
        var n = t.operator,
            i = oe[n],
            r = this.operator,
            o = oe[r];
        if (i > o || i == o && (this === t.right || "**" == n)) return !0;
      }
    }), r(gn, function (e) {
      var t = e.parent();
      return t instanceof St && "=" !== t.operator || t instanceof ft && t.expression === this || t instanceof At && t.condition === this || t instanceof ht || t instanceof dt && t.expression === this || void 0;
    }), r(dt, function (e) {
      var t = e.parent();

      if (t instanceof pt && t.expression === this) {
        var n = !1;
        return this.walk(new Sn(function (e) {
          return !!(n || e instanceof Re) || (e instanceof ft ? (n = !0, !0) : void 0);
        })), n;
      }
    }), r(ft, function (e) {
      var t,
          n = e.parent();
      return !!(n instanceof pt && n.expression === this || n instanceof ct && n.is_default && this.expression instanceof Ie) || this.expression instanceof Ie && n instanceof dt && n.expression === this && (t = e.parent(1)) instanceof vt && t.left === n;
    }), r(pt, function (e) {
      var t = e.parent();
      if (0 === this.args.length && (t instanceof dt || t instanceof ft && t.expression === this)) return !0;
    }), r(an, function (e) {
      var t = e.parent();

      if (t instanceof dt && t.expression === this) {
        var n = this.getValue();
        if (n < 0 || /^0/.test(_(n))) return !0;
      }
    }), r(sn, function (e) {
      var t = e.parent();
      if (t instanceof dt && t.expression === this && this.getValue().startsWith("-")) return !0;
    }), r([vt, At], function (e) {
      var t = e.parent();
      return t instanceof ht || t instanceof St && !(t instanceof vt) || t instanceof ft && t.expression === this || t instanceof At && t.condition === this || t instanceof dt && t.expression === this || this instanceof vt && this.left instanceof Pe && !1 === this.left.is_array || void 0;
    }), e(_e, function (e, t) {
      t.print_string(e.value, e.quote), t.semicolon();
    }), e(Ne, function (e, t) {
      t.print("..."), e.expression.print(t);
    }), e(Pe, function (e, t) {
      t.print(e.is_array ? "[" : "{");
      var n = e.names.length;
      e.names.forEach(function (e, i) {
        i > 0 && t.comma(), e.print(t), i == n - 1 && e instanceof _n && t.comma();
      }), t.print(e.is_array ? "]" : "}");
    }), e(pe, function (e, t) {
      t.print("debugger"), t.semicolon();
    }), Se.DEFMETHOD("_do_print_body", function (e) {
      p(this.body, e);
    }), e(fe, function (e, t) {
      e.body.print(t), t.semicolon();
    }), e(we, function (e, t) {
      o(e.body, !0, t, !0), t.print("");
    }), e(Ae, function (e, t) {
      e.label.print(t), t.colon(), e.body.print(t);
    }), e(de, function (e, t) {
      e.body.print(t), t.semicolon();
    }), e(De, function (e, t) {
      c(e, t);
    }), e(ge, function (e, t) {
      t.semicolon();
    }), e(be, function (e, t) {
      t.print("do"), t.space(), d(e.body, t), t.space(), t.print("while"), t.space(), t.with_parens(function () {
        e.condition.print(t);
      }), t.semicolon();
    }), e(ye, function (e, t) {
      t.print("while"), t.space(), t.with_parens(function () {
        e.condition.print(t);
      }), t.space(), e._do_print_body(t);
    }), e(Ce, function (e, t) {
      t.print("for"), t.space(), t.with_parens(function () {
        e.init ? (e.init instanceof it ? e.init.print(t) : l(e.init, t, !0), t.print(";"), t.space()) : t.print(";"), e.condition ? (e.condition.print(t), t.print(";"), t.space()) : t.print(";"), e.step && e.step.print(t);
      }), t.space(), e._do_print_body(t);
    }), e(Oe, function (e, t) {
      t.print("for"), e.await && (t.space(), t.print("await")), t.space(), t.with_parens(function () {
        e.init.print(t), t.space(), t.print(e instanceof Fe ? "of" : "in"), t.space(), e.object.print(t);
      }), t.space(), e._do_print_body(t);
    }), e(Me, function (e, t) {
      t.print("with"), t.space(), t.with_parens(function () {
        e.expression.print(t);
      }), t.space(), e._do_print_body(t);
    }), xe.DEFMETHOD("_do_print", function (e, t) {
      var n = this;
      t || (n.async && (e.print("async"), e.space()), e.print("function"), n.is_generator && e.star(), n.name && e.space()), n.name instanceof kt ? n.name.print(e) : t && n.name instanceof le && e.with_square(function () {
        n.name.print(e);
      }), e.with_parens(function () {
        n.argnames.forEach(function (t, n) {
          n && e.comma(), t.print(e);
        });
      }), e.space(), c(n, e, !0);
    }), e(xe, function (e, t) {
      e._do_print(t);
    }), e(Be, function (e, t) {
      var n = e.prefix,
          i = n instanceof xe || n instanceof St || n instanceof At || n instanceof _t || n instanceof ht || n instanceof mt && n.expression instanceof yt;
      i && t.print("("), e.prefix.print(t), i && t.print(")"), e.template_string.print(t);
    }), e(Ke, function (e, t) {
      var n = t.parent() instanceof Be;
      t.print("`");

      for (var i = 0; i < e.segments.length; i++) {
        e.segments[i] instanceof Ue ? n ? t.print(e.segments[i].raw) : t.print_template_string_chars(e.segments[i].value) : (t.print("${"), e.segments[i].print(t), t.print("}"));
      }

      t.print("`");
    }), Le.DEFMETHOD("_do_print", function (e) {
      var t = this,
          n = e.parent(),
          i = n instanceof St && !(n instanceof vt) || n instanceof ht || n instanceof ft && t === n.expression;
      i && e.print("("), t.async && (e.print("async"), e.space()), 1 === t.argnames.length && t.argnames[0] instanceof kt ? t.argnames[0].print(e) : e.with_parens(function () {
        t.argnames.forEach(function (t, n) {
          n && e.comma(), t.print(e);
        });
      }), e.space(), e.print("=>"), e.space(), t.body instanceof le ? t.body.print(e) : c(t, e), i && e.print(")");
    }), He.DEFMETHOD("_do_print", function (e, t) {
      if (e.print(t), this.value) {
        e.space();
        var _t5 = this.value.start.comments_before;
        _t5 && _t5.length && !e.printed_comments.has(_t5) ? (e.print("("), this.value.print(e), e.print(")")) : this.value.print(e);
      }

      e.semicolon();
    }), e(Xe, function (e, t) {
      e._do_print(t, "return");
    }), e(ze, function (e, t) {
      e._do_print(t, "throw");
    }), e(gn, function (e, t) {
      var n = e.is_star ? "*" : "";
      t.print("yield" + n), e.expression && (t.space(), e.expression.print(t));
    }), e(Dn, function (e, t) {
      t.print("await"), t.space();
      var n = e.expression,
          i = !(n instanceof ft || n instanceof Zt || n instanceof dt || n instanceof ht || n instanceof rn);
      i && t.print("("), e.expression.print(t), i && t.print(")");
    }), We.DEFMETHOD("_do_print", function (e, t) {
      e.print(t), this.label && (e.space(), this.label.print(e)), e.semicolon();
    }), e(Ye, function (e, t) {
      e._do_print(t, "break");
    }), e(qe, function (e, t) {
      e._do_print(t, "continue");
    }), e($e, function (e, t) {
      t.print("if"), t.space(), t.with_parens(function () {
        e.condition.print(t);
      }), t.space(), e.alternative ? (!function (e, t) {
        var n = e.body;
        if (t.option("braces") || t.option("ie8") && n instanceof be) return d(n, t);
        if (!n) return t.force_semicolon();

        for (;;) {
          if (n instanceof $e) {
            if (!n.alternative) return void d(e.body, t);
            n = n.alternative;
          } else {
            if (!(n instanceof Se)) break;
            n = n.body;
          }
        }

        p(e.body, t);
      }(e, t), t.space(), t.print("else"), t.space(), e.alternative instanceof $e ? e.alternative.print(t) : p(e.alternative, t)) : e._do_print_body(t);
    }), e(je, function (e, t) {
      t.print("switch"), t.space(), t.with_parens(function () {
        e.expression.print(t);
      }), t.space();
      var n = e.body.length - 1;
      n < 0 ? u(e, t) : t.with_block(function () {
        e.body.forEach(function (e, i) {
          t.indent(!0), e.print(t), i < n && e.body.length > 0 && t.newline();
        });
      });
    }), Ze.DEFMETHOD("_do_print_body", function (e) {
      e.newline(), this.body.forEach(function (t) {
        e.indent(), t.print(e), e.newline();
      });
    }), e(Je, function (e, t) {
      t.print("default:"), e._do_print_body(t);
    }), e(Qe, function (e, t) {
      t.print("case"), t.space(), e.expression.print(t), t.print(":"), e._do_print_body(t);
    }), e(et, function (e, t) {
      t.print("try"), t.space(), c(e, t), e.bcatch && (t.space(), e.bcatch.print(t)), e.bfinally && (t.space(), e.bfinally.print(t));
    }), e(tt, function (e, t) {
      t.print("catch"), e.argname && (t.space(), t.with_parens(function () {
        e.argname.print(t);
      })), t.space(), c(e, t);
    }), e(nt, function (e, t) {
      t.print("finally"), t.space(), c(e, t);
    }), it.DEFMETHOD("_do_print", function (e, t) {
      e.print(t), e.space(), this.definitions.forEach(function (t, n) {
        n && e.comma(), t.print(e);
      });
      var n = e.parent();
      (!(n instanceof Ce || n instanceof Oe) || n && n.init !== this) && e.semicolon();
    }), e(ot, function (e, t) {
      e._do_print(t, "let");
    }), e(rt, function (e, t) {
      e._do_print(t, "var");
    }), e(at, function (e, t) {
      e._do_print(t, "const");
    }), e(ut, function (e, t) {
      t.print("import"), t.space(), e.imported_name && e.imported_name.print(t), e.imported_name && e.imported_names && (t.print(","), t.space()), e.imported_names && (1 === e.imported_names.length && "*" === e.imported_names[0].foreign_name.name ? e.imported_names[0].print(t) : (t.print("{"), e.imported_names.forEach(function (n, i) {
        t.space(), n.print(t), i < e.imported_names.length - 1 && t.print(",");
      }), t.space(), t.print("}"))), (e.imported_name || e.imported_names) && (t.space(), t.print("from"), t.space()), e.module_name.print(t), t.semicolon();
    }), e(st, function (e, t) {
      var n = t.parent() instanceof ut,
          i = e.name.definition();
      (i && i.mangled_name || e.name.name) !== e.foreign_name.name ? (n ? t.print(e.foreign_name.name) : e.name.print(t), t.space(), t.print("as"), t.space(), n ? e.name.print(t) : t.print(e.foreign_name.name)) : e.name.print(t);
    }), e(ct, function (e, t) {
      if (t.print("export"), t.space(), e.is_default && (t.print("default"), t.space()), e.exported_names) 1 === e.exported_names.length && "*" === e.exported_names[0].name.name ? e.exported_names[0].print(t) : (t.print("{"), e.exported_names.forEach(function (n, i) {
        t.space(), n.print(t), i < e.exported_names.length - 1 && t.print(",");
      }), t.space(), t.print("}"));else if (e.exported_value) e.exported_value.print(t);else if (e.exported_definition && (e.exported_definition.print(t), e.exported_definition instanceof it)) return;
      e.module_name && (t.space(), t.print("from"), t.space(), e.module_name.print(t)), (e.exported_value && !(e.exported_value instanceof Ve || e.exported_value instanceof Ie || e.exported_value instanceof wt) || e.module_name || e.exported_names) && t.semicolon();
    }), e(lt, function (e, t) {
      if (e.name.print(t), e.value) {
        t.space(), t.print("="), t.space();
        var n = t.parent(1),
            i = n instanceof Ce || n instanceof Oe;
        l(e.value, t, i);
      }
    }), e(ft, function (e, t) {
      e.expression.print(t), e instanceof pt && 0 === e.args.length || ((e.expression instanceof ft || e.expression instanceof xe) && t.add_mapping(e.start), t.with_parens(function () {
        e.args.forEach(function (e, n) {
          n && t.comma(), e.print(t);
        });
      }));
    }), e(pt, function (e, t) {
      t.print("new"), t.space(), ft.prototype._codegen(e, t);
    }), _t.DEFMETHOD("_do_print", function (e) {
      this.expressions.forEach(function (t, n) {
        n > 0 && (e.comma(), e.should_break() && (e.newline(), e.indent())), t.print(e);
      });
    }), e(_t, function (e, t) {
      e._do_print(t);
    }), e(mt, function (e, t) {
      var n = e.expression;
      n.print(t);
      var i = e.property;
      t.option("ie8") && O.has(i) ? (t.print("["), t.add_mapping(e.end), t.print_string(i), t.print("]")) : (n instanceof an && n.getValue() >= 0 && (/[xa-f.)]/i.test(t.last()) || t.print(".")), t.print("."), t.add_mapping(e.end), t.print_name(i));
    }), e(Et, function (e, t) {
      e.expression.print(t), t.print("["), e.property.print(t), t.print("]");
    }), e(Dt, function (e, t) {
      var n = e.operator;
      t.print(n), (/^[a-z]/i.test(n) || /[+-]$/.test(n) && e.expression instanceof Dt && /^[+-]/.test(e.expression.operator)) && t.space(), e.expression.print(t);
    }), e(gt, function (e, t) {
      e.expression.print(t), t.print(e.operator);
    }), e(St, function (e, t) {
      var n = e.operator;
      e.left.print(t), ">" == n[0] && e.left instanceof gt && "--" == e.left.operator ? t.print(" ") : t.space(), t.print(n), ("<" == n || "<<" == n) && e.right instanceof Dt && "!" == e.right.operator && e.right.expression instanceof Dt && "--" == e.right.expression.operator ? t.print(" ") : t.space(), e.right.print(t);
    }), e(At, function (e, t) {
      e.condition.print(t), t.space(), t.print("?"), t.space(), e.consequent.print(t), t.space(), t.colon(), e.alternative.print(t);
    }), e(bt, function (e, t) {
      t.with_square(function () {
        var n = e.elements,
            i = n.length;
        i > 0 && t.space(), n.forEach(function (e, n) {
          n && t.comma(), e.print(t), n === i - 1 && e instanceof _n && t.comma();
        }), i > 0 && t.space();
      });
    }), e(yt, function (e, t) {
      e.properties.length > 0 ? t.with_block(function () {
        e.properties.forEach(function (e, n) {
          n && (t.print(","), t.newline()), t.indent(), e.print(t);
        }), t.newline();
      }) : u(e, t);
    }), e(wt, function (e, t) {
      if (t.print("class"), t.space(), e.name && (e.name.print(t), t.space()), e.extends) {
        var n = !(e.extends instanceof Zt || e.extends instanceof dt || e.extends instanceof xt || e.extends instanceof Ie);
        t.print("extends"), n ? t.print("(") : t.space(), e.extends.print(t), n ? t.print(")") : t.space();
      }

      e.properties.length > 0 ? t.with_block(function () {
        e.properties.forEach(function (e, n) {
          n && t.newline(), t.indent(), e.print(t);
        }), t.newline();
      }) : t.print("{}");
    }), e(It, function (e, t) {
      t.print("new.target");
    }), e(Ot, function (e, t) {
      function n(e) {
        var t = e.definition();
        return t ? t.mangled_name || t.name : e.name;
      }

      var i = t.option("shorthand");
      i && e.value instanceof kt && j(e.key) && n(e.value) === e.key && !O.has(e.key) ? f(e.key, e.quote, t) : i && e.value instanceof Tt && e.value.left instanceof kt && j(e.key) && n(e.value.left) === e.key ? (f(e.key, e.quote, t), t.space(), t.print("="), t.space(), e.value.right.print(t)) : (e.key instanceof le ? t.with_square(function () {
        e.key.print(t);
      }) : f(e.key, e.quote, t), t.colon(), e.value.print(t));
    }), Ct.DEFMETHOD("_print_getter_setter", function (e, t) {
      var n = this;
      n.static && (t.print("static"), t.space()), e && (t.print(e), t.space()), n.key instanceof Ht ? f(n.key.name, n.quote, t) : t.with_square(function () {
        n.key.print(t);
      }), n.value._do_print(t, !0);
    }), e(Ft, function (e, t) {
      e._print_getter_setter("set", t);
    }), e(Mt, function (e, t) {
      e._print_getter_setter("get", t);
    }), e(Rt, function (e, t) {
      var n;
      e.is_generator && e.async ? n = "async*" : e.is_generator ? n = "*" : e.async && (n = "async"), e._print_getter_setter(n, t);
    }), kt.DEFMETHOD("_do_print", function (e) {
      var t = this.definition();
      e.print_name(t ? t.mangled_name || t.name : this.name);
    }), e(kt, function (e, t) {
      e._do_print(t);
    }), e(_n, a), e(tn, function (e, t) {
      t.print("this");
    }), e(nn, function (e, t) {
      t.print("super");
    }), e(rn, function (e, t) {
      t.print(e.getValue());
    }), e(on, function (e, n) {
      n.print_string(e.getValue(), e.quote, t);
    }), e(an, function (e, t) {
      i && e.start && null != e.start.raw ? t.print(e.start.raw) : t.print(_(e.getValue()));
    }), e(sn, function (e, t) {
      t.print(e.getValue() + "n");
    }), e(un, function (e, t) {
      var _e$getValue = e.getValue(),
          n = _e$getValue.source,
          i = _e$getValue.flags;

      n = A(n), i = i ? function (e) {
        var t = new Set(e.split(""));
        var n = "";
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = v[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            var _e3 = _step.value;
            t.has(_e3) && (n += _e3, t.delete(_e3));
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return t.size && t.forEach(function (e) {
          n += e;
        }), n;
      }(i) : "", t.print(t.to_utf8("/".concat(n, "/").concat(i)));
      var r = t.parent();
      r instanceof St && /^\w/.test(r.operator) && r.left === e && t.print(" ");
    }), m([le, Ae, we], a), m([bt, De, tt, wt, rn, pe, it, _e, nt, Ge, xe, pt, yt, Se, kt, je, Ze, Ke, Ue, et], function (e) {
      e.add_mapping(this.start);
    }), m([Mt, Ft], function (e) {
      e.add_mapping(this.start, this.key.name);
    }), m([Ct], function (e) {
      e.add_mapping(this.start, this.key);
    });
  }();
  var In = 1,
      Ln = 2;
  var Vn = null;

  var Pn =
  /*#__PURE__*/
  function () {
    function Pn(e, t, n) {
      _classCallCheck(this, Pn);

      this.name = t.name, this.orig = [t], this.init = n, this.eliminated = 0, this.assignments = 0, this.scope = e, this.references = [], this.replaced = 0, this.global = !1, this.export = 0, this.mangled_name = null, this.undeclared = !1, this.id = Pn.next_id++, this.chained = !1, this.direct_access = !1, this.escaped = 0, this.recursive_refs = 0, this.references = [], this.should_replace = void 0, this.single_use = !1, this.fixed = !1, Object.seal(this);
    }

    _createClass(Pn, [{
      key: "unmangleable",
      value: function unmangleable(e) {
        return e || (e = {}), !!(Vn && Vn.has(this.id) && g(e.keep_fnames, this.orig[0].name)) || this.global && !e.toplevel || this.export & In || this.undeclared || !e.eval && this.scope.pinned() || (this.orig[0] instanceof Xt || this.orig[0] instanceof Gt) && g(e.keep_fnames, this.orig[0].name) || this.orig[0] instanceof Ht || (this.orig[0] instanceof Wt || this.orig[0] instanceof zt) && g(e.keep_classnames, this.orig[0].name);
      }
    }, {
      key: "mangle",
      value: function mangle(e) {
        var t = e.cache && e.cache.props;
        if (this.global && t && t.has(this.name)) this.mangled_name = t.get(this.name);else if (!this.mangled_name && !this.unmangleable(e)) {
          var n = this.scope,
              i = this.orig[0];
          e.ie8 && i instanceof Xt && (n = n.parent_scope);

          var _r = Bn(this);

          this.mangled_name = _r ? _r.mangled_name || _r.name : n.next_mangled(e, this), this.global && t && t.set(this.name, this.mangled_name);
        }
      }
    }]);

    return Pn;
  }();

  function Bn(e) {
    if (e.orig[0] instanceof Yt && e.scope.is_block_scope()) return e.scope.get_defun_scope().variables.get(e.name);
  }

  function Kn(e, t) {
    var n = e.enclosed;

    e: for (;;) {
      var i = Un(++e.cname);

      if (!O.has(i) && !t.reserved.has(i)) {
        for (var r = n.length; --r >= 0;) {
          var o = n[r];
          if (i == (o.mangled_name || o.unmangleable(t) && o.name)) continue e;
        }

        return i;
      }
    }
  }

  Pn.next_id = 1, we.DEFMETHOD("figure_out_scope", function (e) {
    e = o(e, {
      cache: null,
      ie8: !1,
      safari10: !1
    });
    var t = this,
        n = t.parent_scope = null,
        i = new Map(),
        r = null,
        a = null,
        s = [],
        u = new Sn(function (t, o) {
      if (t.is_block_scope()) {
        var _i3 = n;
        t.block_scope = n = new Re(t);

        var _r2 = t instanceof tt ? _i3.parent_scope : _i3;

        if (n.init_scope_vars(_r2), n.uses_with = _i3.uses_with, n.uses_eval = _i3.uses_eval, e.safari10 && (t instanceof Ce || t instanceof Oe) && s.push(n), t instanceof je) {
          var _e4 = n;
          n = _i3, t.expression.walk(u), n = _e4;

          for (var _e5 = 0; _e5 < t.body.length; _e5++) {
            t.body[_e5].walk(u);
          }
        } else o();

        return n = _i3, !0;
      }

      if (t instanceof Pe) {
        var _e6 = a;
        return a = t, o(), a = _e6, !0;
      }

      if (t instanceof Re) {
        t.init_scope_vars(n);
        var c = n,
            l = r,
            f = i;
        return r = n = t, i = new Map(), o(), n = c, r = l, i = f, !0;
      }

      if (t instanceof Ae) {
        var p = t.label;
        if (i.has(p.name)) throw new Error(_("Label {name} defined twice", p));
        return i.set(p.name, p), o(), i.delete(p.name), !0;
      }

      if (t instanceof Me) for (var d = n; d; d = d.parent_scope) {
        d.uses_with = !0;
      } else {
        if (t instanceof kt && (t.scope = n), t instanceof jt && (t.thedef = t, t.references = []), t instanceof Xt) r.def_function(t, "arguments" == t.name ? void 0 : r);else if (t instanceof Gt) h((t.scope = r.parent_scope.get_defun_scope()).def_function(t, r), 1);else if (t instanceof Wt) h(r.def_variable(t, r), 1);else if (t instanceof qt) n.def_variable(t);else if (t instanceof zt) h((t.scope = r.parent_scope).def_function(t, r), 1);else if (t instanceof Vt || t instanceof Kt || t instanceof Bt || t instanceof Yt) {
          if ((m = t instanceof Pt ? n.def_variable(t, null) : r.def_variable(t, "SymbolVar" == t.TYPE ? null : void 0)).orig.every(function (e) {
            return e === t || (t instanceof Pt ? e instanceof Xt : !(e instanceof Kt || e instanceof Bt));
          }) || J(t.name + " redeclared", t.start.file, t.start.line, t.start.col, t.start.pos), t instanceof Ut || h(m, 2), r !== n) {
            t.mark_enclosed(e);
            var m = n.find_variable(t);
            t.thedef !== m && (t.thedef = m, t.reference(e));
          }
        } else if (t instanceof en) {
          var E = i.get(t.name);
          if (!E) throw new Error(_("Undefined label {name} [{line},{col}]", {
            name: t.name,
            line: t.start.line,
            col: t.start.col
          }));
          t.thedef = E;
        }
        n instanceof we || !(t instanceof ct || t instanceof ut) || J(t.TYPE + " statement may only appear at top level", t.start.file, t.start.line, t.start.col, t.start.pos);
      }

      function h(e, t) {
        if (a) {
          var n = 0;

          do {
            t++;
          } while (u.parent(n++) !== a);
        }

        var i = u.parent(t);

        if (e.export = i instanceof ct ? In : 0) {
          var r = i.exported_definition;
          (r instanceof Ve || r instanceof Nt) && i.is_default && (e.export = Ln);
        }
      }
    });
    t.walk(u), t.globals = new Map();
    u = new Sn(function (n, i) {
      if (n instanceof We && n.label) return n.label.thedef.references.push(n), !0;

      if (n instanceof Zt) {
        var r,
            o = n.name;
        if ("eval" == o && u.parent() instanceof ft) for (var a = n.scope; a && !a.uses_eval; a = a.parent_scope) {
          a.uses_eval = !0;
        }
        return u.parent() instanceof st && u.parent(1).module_name || !(r = n.scope.find_variable(o)) ? (r = t.def_global(n), n instanceof Jt && (r.export = In)) : r.scope instanceof xe && "arguments" == o && (r.scope.uses_arguments = !0), n.thedef = r, n.reference(e), !n.scope.is_block_scope() || r.orig[0] instanceof Pt || (n.scope = n.scope.get_defun_scope()), !0;
      }

      var s;
      if (n instanceof Yt && (s = Bn(n.definition()))) for (a = n.scope; a && (p(a.enclosed, s), a !== s.scope);) {
        a = a.parent_scope;
      }
    });

    if (t.walk(u), (e.ie8 || e.safari10) && t.walk(new Sn(function (n, i) {
      if (n instanceof Yt) {
        var r = n.name,
            o = n.thedef.references,
            a = n.scope.get_defun_scope(),
            s = a.find_variable(r) || t.globals.get(r) || a.def_variable(n);
        return o.forEach(function (t) {
          t.thedef = s, t.reference(e);
        }), n.thedef = s, n.reference(e), !0;
      }
    })), e.safari10) {
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        var _loop = function _loop() {
          var e = _step2.value;
          e.parent_scope.variables.forEach(function (t) {
            p(e.enclosed, t);
          });
        };

        for (var _iterator2 = s[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          _loop();
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }
    }
  }), we.DEFMETHOD("def_global", function (e) {
    var t = this.globals,
        n = e.name;
    if (t.has(n)) return t.get(n);
    var i = new Pn(this, e);
    return i.undeclared = !0, i.global = !0, t.set(n, i), i;
  }), Re.DEFMETHOD("init_scope_vars", function (e) {
    this.variables = new Map(), this.functions = new Map(), this.uses_with = !1, this.uses_eval = !1, this.parent_scope = e, this.enclosed = [], this.cname = -1, this._var_name_cache = null;
  }), Re.DEFMETHOD("var_names", function e() {
    var t = this._var_name_cache;
    return t || (this._var_name_cache = t = new Set(this.parent_scope ? e.call(this.parent_scope) : null), this._added_var_names && this._added_var_names.forEach(function (e) {
      t.add(e);
    }), this.enclosed.forEach(function (e) {
      t.add(e.name);
    }), this.variables.forEach(function (e, n) {
      t.add(n);
    })), t;
  }), Re.DEFMETHOD("add_var_name", function (e) {
    this._added_var_names || (this._added_var_names = new Set()), this._added_var_names.add(e), this._var_name_cache || this.var_names(), this._var_name_cache.add(e);
  }), Re.DEFMETHOD("add_child_scope", function (e) {
    var _this4 = this;

    if (e.parent_scope === this) return;
    e.parent_scope = this, e._var_name_cache = null, e._added_var_names && e._added_var_names.forEach(function (t) {
      return e.add_var_name(t);
    });

    var t = new Set(e.enclosed),
        n = function () {
      var e = [];
      var t = _this4;

      do {
        e.push(t);
      } while (t = t.parent_scope);

      return e.reverse(), e;
    }(),
        i = [];

    var _iteratorNormalCompletion3 = true;
    var _didIteratorError3 = false;
    var _iteratorError3 = undefined;

    try {
      var _loop2 = function _loop2() {
        var e = _step3.value;
        i.forEach(function (t) {
          return p(e.enclosed, t);
        });
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = e.variables.values()[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var _n3 = _step4.value;
            t.has(_n3) && (p(i, _n3), p(e.enclosed, _n3));
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      };

      for (var _iterator3 = n[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
        _loop2();
      }
    } catch (err) {
      _didIteratorError3 = true;
      _iteratorError3 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
          _iterator3.return();
        }
      } finally {
        if (_didIteratorError3) {
          throw _iteratorError3;
        }
      }
    }
  }), le.DEFMETHOD("is_block_scope", s), wt.DEFMETHOD("is_block_scope", s), xe.DEFMETHOD("is_block_scope", s), we.DEFMETHOD("is_block_scope", s), Ze.DEFMETHOD("is_block_scope", s), he.DEFMETHOD("is_block_scope", u), ve.DEFMETHOD("is_block_scope", u), xe.DEFMETHOD("init_scope_vars", function () {
    Re.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1, this.def_variable(new Ut({
      name: "arguments",
      start: this.start,
      end: this.end
    }));
  }), Le.DEFMETHOD("init_scope_vars", function () {
    Re.prototype.init_scope_vars.apply(this, arguments), this.uses_arguments = !1;
  }), kt.DEFMETHOD("mark_enclosed", function (e) {
    for (var t = this.definition(), n = this.scope; n && (p(n.enclosed, t), e.keep_fnames && n.functions.forEach(function (n) {
      g(e.keep_fnames, n.name) && p(t.scope.enclosed, n);
    }), n !== t.scope);) {
      n = n.parent_scope;
    }
  }), kt.DEFMETHOD("reference", function (e) {
    this.definition().references.push(this), this.mark_enclosed(e);
  }), Re.DEFMETHOD("find_variable", function (e) {
    return e instanceof kt && (e = e.name), this.variables.get(e) || this.parent_scope && this.parent_scope.find_variable(e);
  }), Re.DEFMETHOD("def_function", function (e, t) {
    var n = this.def_variable(e, t);
    return (!n.init || n.init instanceof Ve) && (n.init = t), this.functions.set(e.name, n), n;
  }), Re.DEFMETHOD("def_variable", function (e, t) {
    var n = this.variables.get(e.name);
    return n ? (n.orig.push(e), n.init && (n.scope !== e.scope || n.init instanceof Ie) && (n.init = t)) : (n = new Pn(this, e, t), this.variables.set(e.name, n), n.global = !this.parent_scope), e.thedef = n;
  }), Re.DEFMETHOD("next_mangled", function (e) {
    return Kn(this, e);
  }), we.DEFMETHOD("next_mangled", function (e) {
    var t;
    var n = this.mangled_names;

    do {
      t = Kn(this, e);
    } while (n.has(t));

    return t;
  }), Ie.DEFMETHOD("next_mangled", function (e, t) {
    for (var n = t.orig[0] instanceof Ut && this.name && this.name.definition(), i = n ? n.mangled_name || n.name : null;;) {
      var r = Kn(this, e);
      if (!i || i != r) return r;
    }
  }), kt.DEFMETHOD("unmangleable", function (e) {
    var t = this.definition();
    return !t || t.unmangleable(e);
  }), jt.DEFMETHOD("unmangleable", s), kt.DEFMETHOD("unreferenced", function () {
    return !this.definition().references.length && !this.scope.pinned();
  }), kt.DEFMETHOD("definition", function () {
    return this.thedef;
  }), kt.DEFMETHOD("global", function () {
    return this.definition().global;
  }), we.DEFMETHOD("_default_mangler_options", function (e) {
    return (e = o(e, {
      eval: !1,
      ie8: !1,
      keep_classnames: !1,
      keep_fnames: !1,
      module: !1,
      reserved: [],
      toplevel: !1
    })).module && (e.toplevel = !0), Array.isArray(e.reserved) || e.reserved instanceof Set || (e.reserved = []), e.reserved = new Set(e.reserved), e.reserved.add("arguments"), e;
  }), we.DEFMETHOD("mangle_names", function (e) {
    e = this._default_mangler_options(e);
    var t = -1,
        n = [];
    e.keep_fnames && (Vn = new Set());
    var i = this.mangled_names = new Set();
    e.cache && (this.globals.forEach(o), e.cache.props && e.cache.props.forEach(function (e) {
      i.add(e);
    }));
    var r = new Sn(function (i, r) {
      if (i instanceof Ae) {
        var a = t;
        return r(), t = a, !0;
      }

      if (i instanceof Re) i.variables.forEach(o);else if (i.is_block_scope()) i.block_scope.variables.forEach(o);else if (Vn && i instanceof lt && i.value instanceof xe && !i.value.name && g(e.keep_fnames, i.name.name)) Vn.add(i.name.definition().id);else {
        if (i instanceof jt) {
          var _e7;

          do {
            _e7 = Un(++t);
          } while (O.has(_e7));

          return i.mangled_name = _e7, !0;
        }

        !e.ie8 && !e.safari10 && i instanceof Yt && n.push(i.definition());
      }
    });

    function o(t) {
      !(e.reserved.has(t.name) || t.export & In) && n.push(t);
    }

    this.walk(r), n.forEach(function (t) {
      t.mangle(e);
    }), Vn = null;
  }), we.DEFMETHOD("find_colliding_names", function (e) {
    var t = e.cache && e.cache.props,
        n = new Set();
    return e.reserved.forEach(i), this.globals.forEach(r), this.walk(new Sn(function (e) {
      e instanceof Re && e.variables.forEach(r), e instanceof Yt && r(e.definition());
    })), n;

    function i(e) {
      n.add(e);
    }

    function r(n) {
      var r = n.name;
      if (n.global && t && t.has(r)) r = t.get(r);else if (!n.unmangleable(e)) return;
      i(r);
    }
  }), we.DEFMETHOD("expand_names", function (e) {
    Un.reset(), Un.sort(), e = this._default_mangler_options(e);
    var t = this.find_colliding_names(e),
        n = 0;

    function i(i) {
      if (i.global && e.cache) return;
      if (i.unmangleable(e)) return;
      if (e.reserved.has(i.name)) return;
      var r = Bn(i),
          o = i.name = r ? r.name : function () {
        var e;

        do {
          e = Un(n++);
        } while (t.has(e) || O.has(e));

        return e;
      }();
      i.orig.forEach(function (e) {
        e.name = o;
      }), i.references.forEach(function (e) {
        e.name = o;
      });
    }

    this.globals.forEach(i), this.walk(new Sn(function (e) {
      e instanceof Re && e.variables.forEach(i), e instanceof Yt && i(e.definition());
    }));
  }), le.DEFMETHOD("tail_node", c), _t.DEFMETHOD("tail_node", function () {
    return this.expressions[this.expressions.length - 1];
  }), we.DEFMETHOD("compute_char_frequency", function (e) {
    e = this._default_mangler_options(e);

    try {
      le.prototype.print = function (t, n) {
        this._print(t, n), this instanceof kt && !this.unmangleable(e) ? Un.consider(this.name, -1) : e.properties && (this instanceof mt ? Un.consider(this.property, -1) : this instanceof Et && function e(t) {
          t instanceof on ? Un.consider(t.value, -1) : t instanceof At ? (e(t.consequent), e(t.alternative)) : t instanceof _t && e(t.tail_node());
        }(this.property));
      }, Un.consider(this.print_to_string(), 1);
    } finally {
      le.prototype.print = le.prototype._print;
    }

    Un.sort();
  });

  var Un = function () {
    var e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_".split(""),
        t = "0123456789".split("");
    var n, i;

    function r() {
      i = new Map(), e.forEach(function (e) {
        i.set(e, 0);
      }), t.forEach(function (e) {
        i.set(e, 0);
      });
    }

    function o(e, t) {
      return i.get(t) - i.get(e);
    }

    function a(e) {
      var t = "",
          i = 54;
      e++;

      do {
        t += n[--e % i], e = Math.floor(e / i), i = 64;
      } while (e > 0);

      return t;
    }

    return a.consider = function (e, t) {
      for (var n = e.length; --n >= 0;) {
        i.set(e[n], i.get(e[n]) + t);
      }
    }, a.sort = function () {
      n = m(e, o).concat(m(t, o));
    }, a.reset = r, r(), a;
  }(),
      Gn = 1,
      Hn = 8,
      Xn = 16,
      zn = 32,
      Wn = 256,
      Yn = 512,
      qn = 1024,
      $n = Wn | Yn | qn,
      jn = function jn(e, t) {
    return e.flags & t;
  },
      Zn = function Zn(e, t) {
    e.flags |= t;
  },
      Jn = function Jn(e, t) {
    e.flags &= ~t;
  };

  var Qn =
  /*#__PURE__*/
  function (_Sn2) {
    _inherits(Qn, _Sn2);

    function Qn(e, t) {
      var _this5;

      _classCallCheck(this, Qn);

      _this5 = _possibleConstructorReturn(this, _getPrototypeOf(Qn).call(this)), void 0 === e.defaults || e.defaults || (t = !0), _this5.options = o(e, {
        arguments: !1,
        arrows: !t,
        booleans: !t,
        booleans_as_integers: !1,
        collapse_vars: !t,
        comparisons: !t,
        computed_props: !t,
        conditionals: !t,
        dead_code: !t,
        defaults: !0,
        directives: !t,
        drop_console: !1,
        drop_debugger: !t,
        ecma: 5,
        evaluate: !t,
        expression: !1,
        global_defs: !1,
        hoist_funs: !1,
        hoist_props: !t,
        hoist_vars: !1,
        ie8: !1,
        if_return: !t,
        inline: !t,
        join_vars: !t,
        keep_classnames: !1,
        keep_fargs: !0,
        keep_fnames: !1,
        keep_infinity: !1,
        loops: !t,
        module: !1,
        negate_iife: !t,
        passes: 1,
        properties: !t,
        pure_getters: !t && "strict",
        pure_funcs: null,
        reduce_funcs: null,
        reduce_vars: !t,
        sequences: !t,
        side_effects: !t,
        switches: !t,
        top_retain: null,
        toplevel: !(!e || !e.top_retain),
        typeofs: !t,
        unsafe: !1,
        unsafe_arrows: !1,
        unsafe_comps: !1,
        unsafe_Function: !1,
        unsafe_math: !1,
        unsafe_methods: !1,
        unsafe_proto: !1,
        unsafe_regexp: !1,
        unsafe_undefined: !1,
        unused: !t,
        warnings: !1
      }, !0);
      var n = _this5.options.global_defs;
      if ("object" == _typeof(n)) for (var i in n) {
        "@" === i[0] && D(n, i) && (n[i.slice(1)] = se(n[i], {
          expression: !0
        }));
      }
      !0 === _this5.options.inline && (_this5.options.inline = 3);
      var r = _this5.options.pure_funcs;
      _this5.pure_funcs = "function" == typeof r ? r : r ? function (e) {
        return !r.includes(e.expression.print_to_string());
      } : u;
      var a = _this5.options.top_retain;
      a instanceof RegExp ? _this5.top_retain = function (e) {
        return a.test(e.name);
      } : "function" == typeof a ? _this5.top_retain = a : a && ("string" == typeof a && (a = a.split(/,/)), _this5.top_retain = function (e) {
        return a.includes(e.name);
      }), _this5.options.module && (_this5.directives["use strict"] = !0, _this5.options.toplevel = !0);
      var s = _this5.options.toplevel;
      _this5.toplevel = "string" == typeof s ? {
        funcs: /funcs/.test(s),
        vars: /vars/.test(s)
      } : {
        funcs: s,
        vars: s
      };
      var c = _this5.options.sequences;
      _this5.sequences_limit = 1 == c ? 800 : 0 | c, _this5.warnings_produced = {}, _this5.evaluated_regexps = new Map();
      return _this5;
    }

    _createClass(Qn, [{
      key: "option",
      value: function option(e) {
        return this.options[e];
      }
    }, {
      key: "exposed",
      value: function exposed(e) {
        if (e.export) return !0;
        if (e.global) for (var t = 0, n = e.orig.length; t < n; t++) {
          if (!this.toplevel[e.orig[t] instanceof Gt ? "funcs" : "vars"]) return !0;
        }
        return !1;
      }
    }, {
      key: "in_boolean_context",
      value: function in_boolean_context() {
        if (!this.option("booleans")) return !1;

        for (var e, t = this.self(), n = 0; e = this.parent(n); n++) {
          if (e instanceof de || e instanceof At && e.condition === t || e instanceof Te && e.condition === t || e instanceof Ce && e.condition === t || e instanceof $e && e.condition === t || e instanceof Dt && "!" == e.operator && e.expression === t) return !0;
          if (!(e instanceof St && ("&&" == e.operator || "||" == e.operator) || e instanceof At || e.tail_node() === t)) return !1;
          t = e;
        }
      }
    }, {
      key: "compress",
      value: function compress(e) {
        e = e.resolve_defines(this), this.option("expression") && e.process_expression(!0);

        for (var t = +this.options.passes || 1, n = 1 / 0, i = !1, r = {
          ie8: this.option("ie8")
        }, o = 0; o < t; o++) {
          if (e.figure_out_scope(r), 0 === o && this.option("drop_console") && (e = e.drop_console()), (o > 0 || this.option("reduce_vars")) && e.reset_opt_flags(this), e = e.transform(this), t > 1) {
            var a = 0;
            if (e.walk(new Sn(function () {
              a++;
            })), this.info("pass " + o + ": last_count: " + n + ", count: " + a), a < n) n = a, i = !1;else {
              if (i) break;
              i = !0;
            }
          }
        }

        return this.option("expression") && e.process_expression(!1), e;
      }
    }, {
      key: "info",
      value: function info() {
        "verbose" == this.options.warnings && le.warn.apply(le, arguments);
      }
    }, {
      key: "warn",
      value: function warn(e, t) {
        if (this.options.warnings) {
          var n = _(e, t);

          n in this.warnings_produced || (this.warnings_produced[n] = !0, le.warn.apply(le, arguments));
        }
      }
    }, {
      key: "clear_warnings",
      value: function clear_warnings() {
        this.warnings_produced = {};
      }
    }, {
      key: "before",
      value: function before(e, t, n) {
        if (jn(e, Wn)) return e;
        var i = !1;
        e instanceof Re && (e = (e = e.hoist_properties(this)).hoist_declarations(this), i = !0), t(e, this), t(e, this);
        var r = e.optimize(this);
        return i && r instanceof Re && (r.drop_unused(this), t(r, this)), r === e && Zn(r, Wn), r;
      }
    }]);

    return Qn;
  }(Sn);

  function ei(e, t) {
    e.DEFMETHOD("optimize", function (e) {
      if (jn(this, Yn)) return this;
      if (e.has_directive("use asm")) return this;
      var n = t(this, e);
      return Zn(n, Yn), n;
    });
  }

  function ti(e, t) {
    if (!((t = yi(t)) instanceof le)) {
      var n;

      if (e instanceof bt) {
        var i = e.elements;
        if ("length" == t) return li(i.length, e);
        "number" == typeof t && t in i && (n = i[t]);
      } else if (e instanceof yt) {
        t = "" + t;

        for (var r = e.properties, o = r.length; --o >= 0;) {
          if (!(r[o] instanceof Ot)) return;
          n || r[o].key !== t || (n = r[o].value);
        }
      }

      return n instanceof Zt && n.fixed_value() || n;
    }
  }

  function ni(e, t, n, i, r, o) {
    var a = t.parent(r),
        s = Mi(n, a);
    if (s) return s;
    if (!o && a instanceof ft && a.expression === n && !(i instanceof Le) && !(i instanceof wt) && !a.is_expr_pure(e) && (!(i instanceof Ie) || !(a instanceof pt) && i.contains_this())) return !0;
    if (a instanceof bt) return ni(e, t, a, a, r + 1);

    if (a instanceof Ot && n === a.value) {
      var u = t.parent(r + 1);
      return ni(e, t, u, u, r + 2);
    }

    if (a instanceof dt && a.expression === n) {
      var c = ti(i, a.property);
      return !o && ni(e, t, a, c, r + 1);
    }
  }

  function ii(e) {
    return e instanceof Le || e instanceof Ie;
  }

  function ri(e) {
    if (e instanceof tn) return !0;
    if (e instanceof Zt) return e.definition().orig[0] instanceof Xt;

    if (e instanceof dt) {
      if ((e = e.expression) instanceof Zt) {
        if (e.is_immutable()) return !1;
        e = e.fixed_value();
      }

      return !e || !(e instanceof un) && (e instanceof rn || ri(e));
    }

    return !1;
  }

  function oi(e, t) {
    if (!(e instanceof Zt)) return !1;

    for (var n = e.definition().orig, i = n.length; --i >= 0;) {
      if (n[i] instanceof t) return !0;
    }
  }

  function ai(e, t) {
    for (var _n4 = 0;; _n4++) {
      var _i4 = e.parent(_n4);

      if (_i4 instanceof we) return t ? _i4 : void 0;
      if (_i4 instanceof xe) return _i4;
      if (_i4.block_scope) return _i4.block_scope;
    }
  }

  function si(e, t) {
    for (var n, i = 0; (n = e.parent(i++)) && !(n instanceof Re);) {
      if (n instanceof tt && n.argname) {
        n = n.argname.definition().scope;
        break;
      }
    }

    return n.find_variable(t);
  }

  function ui(e, t, n) {
    return n || (n = {}), t && (n.start || (n.start = t.start), n.end || (n.end = t.end)), new e(n);
  }

  function ci(e, t) {
    if (1 == t.length) return t[0];
    if (0 == t.length) throw new Error("trying to create a sequence with length zero!");
    return ui(_t, e, {
      expressions: t.reduce(pi, [])
    });
  }

  function li(e, t) {
    switch (_typeof(e)) {
      case "string":
        return ui(on, t, {
          value: e
        });

      case "number":
        return isNaN(e) ? ui(fn, t) : isFinite(e) ? 1 / e < 0 ? ui(Dt, t, {
          operator: "-",
          expression: ui(an, t, {
            value: -e
          })
        }) : ui(an, t, {
          value: e
        }) : e < 0 ? ui(Dt, t, {
          operator: "-",
          expression: ui(dn, t)
        }) : ui(dn, t);

      case "boolean":
        return ui(e ? hn : En, t);

      case "undefined":
        return ui(pn, t);

      default:
        if (null === e) return ui(ln, t, {
          value: null
        });
        if (e instanceof RegExp) return ui(un, t, {
          value: {
            source: A(e.source),
            flags: e.flags
          }
        });
        throw new Error(_("Can't handle constant of type: {type}", {
          type: _typeof(e)
        }));
    }
  }

  function fi(e, t, n) {
    return e instanceof Dt && "delete" == e.operator || e instanceof ft && e.expression === t && (n instanceof dt || n instanceof Zt && "eval" == n.name) ? ci(t, [ui(an, t, {
      value: 0
    }), n]) : n;
  }

  function pi(e, t) {
    return t instanceof _t ? e.push.apply(e, _toConsumableArray(t.expressions)) : e.push(t), e;
  }

  function _i(e) {
    if (null === e) return [];
    if (e instanceof De) return e.body;
    if (e instanceof ge) return [];
    if (e instanceof fe) return [e];
    throw new Error("Can't convert thing to statement array");
  }

  function di(e) {
    return null === e || e instanceof ge || e instanceof De && 0 == e.body.length;
  }

  function mi(e) {
    return !(e instanceof Nt || e instanceof Ve || e instanceof ot || e instanceof at || e instanceof ct || e instanceof ut);
  }

  function Ei(e) {
    return e instanceof ve && e.body instanceof De ? e.body : e;
  }

  function hi(e) {
    return "Call" == e.TYPE && (e.expression instanceof Ie || hi(e.expression));
  }

  function Di(e) {
    return e instanceof Zt && e.definition().undeclared;
  }

  ei(le, function (e, t) {
    return e;
  }), we.DEFMETHOD("drop_console", function () {
    return this.transform(new An(function (e) {
      if ("Call" == e.TYPE) {
        var t = e.expression;

        if (t instanceof dt) {
          for (var n = t.expression; n.expression;) {
            n = n.expression;
          }

          if (Di(n) && "console" == n.name) return ui(pn, e);
        }
      }
    }));
  }), le.DEFMETHOD("equivalent_to", function (e) {
    return this.TYPE == e.TYPE && this.print_to_string() == e.print_to_string();
  }), Re.DEFMETHOD("process_expression", function (e, t) {
    var n = this,
        i = new An(function (r) {
      if (e && r instanceof de) return ui(Xe, r, {
        value: r.body
      });

      if (!e && r instanceof Xe) {
        if (t) {
          var o = r.value && r.value.drop_side_effect_free(t, !0);
          return o ? ui(de, r, {
            body: o
          }) : ui(ge, r);
        }

        return ui(de, r, {
          body: r.value || ui(Dt, r, {
            operator: "void",
            expression: ui(an, r, {
              value: 0
            })
          })
        });
      }

      if (r instanceof wt || r instanceof xe && r !== n) return r;

      if (r instanceof he) {
        var a = r.body.length - 1;
        a >= 0 && (r.body[a] = r.body[a].transform(i));
      } else r instanceof $e ? (r.body = r.body.transform(i), r.alternative && (r.alternative = r.alternative.transform(i))) : r instanceof Me && (r.body = r.body.transform(i));

      return r;
    });
    n.transform(i);
  }), function (e) {
    function t(e, t) {
      t.assignments = 0, t.chained = !1, t.direct_access = !1, t.escaped = 0, t.recursive_refs = 0, t.references = [], t.should_replace = void 0, t.single_use = void 0, t.scope.pinned() ? t.fixed = !1 : t.orig[0] instanceof Bt || !e.exposed(t) ? t.fixed = t.init : t.fixed = !1;
    }

    function n(e, n, i) {
      i.variables.forEach(function (i) {
        t(n, i), null === i.fixed ? (e.defs_to_safe_ids.set(i, e.safe_ids), s(e, i, !0)) : i.fixed && (e.loop_ids.set(i.id, e.in_loop), s(e, i, !0));
      });
    }

    function i(e, n) {
      n.block_scope && n.block_scope.variables.forEach(function (n) {
        t(e, n);
      });
    }

    function r(e) {
      e.safe_ids = Object.create(e.safe_ids);
    }

    function o(e) {
      e.safe_ids = Object.getPrototypeOf(e.safe_ids);
    }

    function s(e, t, n) {
      e.safe_ids[t.id] = n;
    }

    function u(e, t) {
      if ("m" == t.single_use) return !1;

      if (e.safe_ids[t.id]) {
        if (null == t.fixed) {
          var n = t.orig[0];
          if (n instanceof Ut || "arguments" == n.name) return !1;
          t.fixed = ui(pn, n);
        }

        return !0;
      }

      return t.fixed instanceof Ve;
    }

    function c(e, t, n, i) {
      if (void 0 === t.fixed) return !0;
      var r;
      return null === t.fixed && (r = e.defs_to_safe_ids.get(t)) ? (r[t.id] = !1, e.defs_to_safe_ids.delete(t), !0) : !!D(e.safe_ids, t.id) && !!u(e, t) && !1 !== t.fixed && !(null != t.fixed && (!i || t.references.length > t.assignments)) && (t.fixed instanceof Ve ? i instanceof le && t.fixed.parent_scope === n : t.orig.every(function (e) {
        return !(e instanceof Bt || e instanceof Gt || e instanceof Xt);
      }));
    }

    function l(e, t, n, i, r, o, a) {
      var s = e.parent(o);

      if (r) {
        if (r.is_constant()) return;
        if (r instanceof xt) return;
      }

      if (s instanceof vt && "=" == s.operator && i === s.right || s instanceof ft && (i !== s.expression || s instanceof pt) || s instanceof He && i === s.value && i.scope !== t.scope || s instanceof lt && i === s.value || s instanceof gn && i === s.value && i.scope !== t.scope) return !(a > 1) || r && r.is_constant_expression(n) || (a = 1), void ((!t.escaped || t.escaped > a) && (t.escaped = a));
      if (s instanceof bt || s instanceof Dn || s instanceof St && Oi.has(s.operator) || s instanceof At && i !== s.condition || s instanceof Ne || s instanceof _t && i === s.tail_node()) l(e, t, n, s, s, o + 1, a);else if (s instanceof Ot && i === s.value) {
        var u = e.parent(o + 1);
        l(e, t, n, u, u, o + 2, a);
      } else if (s instanceof dt && i === s.expression && (l(e, t, n, s, r = ti(r, s.property), o + 1, a + 1), r)) return;
      o > 0 || s instanceof _t && i !== s.tail_node() || s instanceof de || (t.direct_access = !0);
    }

    e(le, a);
    var f = new Sn(function (e) {
      if (e instanceof kt) {
        var t = e.definition();
        t && (e instanceof Zt && t.references.push(e), t.fixed = !1);
      }
    });

    function p(e, t, i) {
      Jn(this, Xn);
      var r = e.safe_ids;
      return e.safe_ids = Object.create(null), n(e, i, this), t(), e.safe_ids = r, !0;
    }

    function _(e, t, i) {
      var a,
          u = this;
      return Jn(this, Xn), r(e), n(e, i, u), u.uses_arguments ? (t(), void o(e)) : (!u.name && (a = e.parent()) instanceof ft && a.expression === u && !a.args.some(function (e) {
        return e instanceof Ne;
      }) && u.argnames.every(function (e) {
        return e instanceof kt;
      }) && u.argnames.forEach(function (t, n) {
        if (t.definition) {
          var i = t.definition();
          i.orig.length > 1 || (void 0 !== i.fixed || u.uses_arguments && !e.has_directive("use strict") ? i.fixed = !1 : (i.fixed = function () {
            return a.args[n] || ui(pn, a);
          }, e.loop_ids.set(i.id, e.in_loop), s(e, i, !0)));
        }
      }), t(), o(e), !0);
    }

    e(ke, function (e, t, i) {
      return r(e), n(e, i, this), t(), o(e), !0;
    }), e(vt, function (e, t, n) {
      var i = this;
      if (i.left instanceof Pe) i.left.walk(f);else {
        var r = i.left;

        if (r instanceof Zt) {
          var o = r.definition(),
              a = c(e, o, r.scope, i.right);

          if (o.assignments++, a) {
            var u = o.fixed;

            if (u || "=" == i.operator) {
              var p = "=" == i.operator,
                  _ = p ? i.right : i;

              if (!ni(n, e, i, _, 0)) return o.references.push(r), p || (o.chained = !0), o.fixed = p ? function () {
                return i.right;
              } : function () {
                return ui(St, i, {
                  operator: i.operator.slice(0, -1),
                  left: u instanceof le ? u : u(),
                  right: i.right
                });
              }, s(e, o, !1), i.right.walk(e), s(e, o, !0), l(e, o, r.scope, i, _, 0, 1), !0;
            }
          }
        }
      }
    }), e(St, function (e) {
      if (Oi.has(this.operator)) return this.left.walk(e), r(e), this.right.walk(e), o(e), !0;
    }), e(he, function (e, t, n) {
      i(n, this);
    }), e(Qe, function (e) {
      return r(e), this.expression.walk(e), o(e), r(e), me(this, e), o(e), !0;
    }), e(xt, function (e, t) {
      return Jn(this, Xn), r(e), t(), o(e), !0;
    }), e(At, function (e) {
      return this.condition.walk(e), r(e), this.consequent.walk(e), o(e), r(e), this.alternative.walk(e), o(e), !0;
    }), e(Je, function (e, t) {
      return r(e), t(), o(e), !0;
    }), e(Nt, p), e(Ve, p), e(be, function (e, t, n) {
      i(n, this);
      var a = e.in_loop;
      return e.in_loop = this, r(e), this.body.walk(e), Hi(this) && (o(e), r(e)), this.condition.walk(e), o(e), e.in_loop = a, !0;
    }), e(Ce, function (e, t, n) {
      i(n, this), this.init && this.init.walk(e);
      var a = e.in_loop;
      return e.in_loop = this, r(e), this.condition && this.condition.walk(e), this.body.walk(e), this.step && (Hi(this) && (o(e), r(e)), this.step.walk(e)), o(e), e.in_loop = a, !0;
    }), e(Oe, function (e, t, n) {
      i(n, this), this.init.walk(f), this.object.walk(e);
      var a = e.in_loop;
      return e.in_loop = this, r(e), this.body.walk(e), o(e), e.in_loop = a, !0;
    }), e(Ie, _), e(Le, _), e($e, function (e) {
      return this.condition.walk(e), r(e), this.body.walk(e), o(e), this.alternative && (r(e), this.alternative.walk(e), o(e)), !0;
    }), e(Ae, function (e) {
      return r(e), this.body.walk(e), o(e), !0;
    }), e(Yt, function () {
      this.definition().fixed = !1;
    }), e(Zt, function (e, t, n) {
      var i,
          r,
          o = this.definition();
      o.references.push(this), 1 == o.references.length && !o.fixed && o.orig[0] instanceof Gt && e.loop_ids.set(o.id, e.in_loop), void 0 !== o.fixed && u(e, o) ? o.fixed && ((i = this.fixed_value()) instanceof xe && Wi(e, o) ? o.recursive_refs++ : i && !n.exposed(o) && function (e, t, n) {
        return t.option("unused") && !n.scope.pinned() && n.references.length - n.recursive_refs == 1 && e.loop_ids.get(n.id) === e.in_loop;
      }(e, n, o) ? o.single_use = !(i instanceof xe && function (e, t, n) {
        var i = ai(e);
        var r = t.enclosed.filter(function (e) {
          return !t.variables.has(e.name);
        }).map(function (e) {
          return e.name;
        });
        if (!r.length) return !1;

        for (; i && !(i instanceof we) && i !== n;) {
          if (r.some(function (e) {
            return i.variables.has(e);
          })) return !0;
          i = i.parent_scope;
        }

        return !1;
      }(e, i, o.scope)) && (i instanceof xe && !i.pinned() || i instanceof wt || o.scope === this.scope && i.is_constant_expression()) : o.single_use = !1, ni(n, e, this, i, 0, !!(r = i) && (r.is_constant() || r instanceof xe || r instanceof tn)) && (o.single_use ? o.single_use = "m" : o.fixed = !1)) : o.fixed = !1, l(e, o, this.scope, this, i, 0, 1);
    }), e(we, function (e, i, r) {
      this.globals.forEach(function (e) {
        t(r, e);
      }), n(e, r, this);
    }), e(et, function (e, t, n) {
      return i(n, this), r(e), me(this, e), o(e), this.bcatch && (r(e), this.bcatch.walk(e), o(e)), this.bfinally && this.bfinally.walk(e), !0;
    }), e(ht, function (e, t) {
      var n = this;

      if ("++" === n.operator || "--" === n.operator) {
        var i = n.expression;

        if (i instanceof Zt) {
          var r = i.definition(),
              o = c(e, r, i.scope, !0);

          if (r.assignments++, o) {
            var a = r.fixed;
            if (a) return r.references.push(i), r.chained = !0, r.fixed = function () {
              return ui(St, n, {
                operator: n.operator.slice(0, -1),
                left: ui(Dt, n, {
                  operator: "+",
                  expression: a instanceof le ? a : a()
                }),
                right: ui(an, n, {
                  value: 1
                })
              });
            }, s(e, r, !0), !0;
          }
        }
      }
    }), e(lt, function (e, t) {
      var n = this;
      if (n.name instanceof Pe) n.name.walk(f);else {
        var i = n.name.definition();

        if (n.value) {
          if (c(e, i, n.name.scope, n.value)) return i.fixed = function () {
            return n.value;
          }, e.loop_ids.set(i.id, e.in_loop), s(e, i, !1), t(), s(e, i, !0), !0;
          i.fixed = !1;
        }
      }
    }), e(ye, function (e, t, n) {
      i(n, this);
      var a = e.in_loop;
      return e.in_loop = this, r(e), t(), o(e), e.in_loop = a, !0;
    });
  }(function (e, t) {
    e.DEFMETHOD("reduce_vars", t);
  }), we.DEFMETHOD("reset_opt_flags", function (e) {
    var t = this,
        n = e.option("reduce_vars"),
        i = new Sn(function (r, o) {
      if (Jn(r, $n), n) return e.top_retain && r instanceof Ve && i.parent() === t && Zn(r, qn), r.reduce_vars(i, o, e);
    });
    i.safe_ids = Object.create(null), i.in_loop = null, i.loop_ids = new Map(), i.defs_to_safe_ids = new Map(), t.walk(i);
  }), kt.DEFMETHOD("fixed_value", function () {
    var e = this.definition().fixed;
    return !e || e instanceof le ? e : e();
  }), Zt.DEFMETHOD("is_immutable", function () {
    var e = this.definition().orig;
    return 1 == e.length && e[0] instanceof Xt;
  });
  var gi = E("Array Boolean clearInterval clearTimeout console Date decodeURI decodeURIComponent encodeURI encodeURIComponent Error escape eval EvalError Function isFinite isNaN JSON Math Number parseFloat parseInt RangeError ReferenceError RegExp Object setInterval setTimeout String SyntaxError TypeError unescape URIError");
  Zt.DEFMETHOD("is_declared", function (e) {
    return !this.definition().undeclared || e.option("unsafe") && gi.has(this.name);
  });
  var Si,
      Ai = E("Infinity NaN undefined");

  function vi(e) {
    return e instanceof dn || e instanceof fn || e instanceof pn;
  }

  function Ti(e, t) {
    var n,
        r,
        o = t.find_parent(Re).get_defun_scope();
    !function () {
      var e = t.self(),
          i = 0;

      do {
        if (e instanceof tt || e instanceof nt) i++;else if (e instanceof ve) n = !0;else {
          if (e instanceof Re) {
            o = e;
            break;
          }

          e instanceof et && (r = !0);
        }
      } while (e = t.parent(i++));
    }();
    var a,
        s = 10;

    do {
      a = !1, c(e), t.option("dead_code") && p(e, t), t.option("if_return") && l(e, t), t.sequences_limit > 0 && (m(e, t), h(e, t)), t.option("join_vars") && g(e), t.option("collapse_vars") && u(e, t);
    } while (a && s-- > 0);

    function u(e, t) {
      if (o.pinned()) return e;

      for (var s, u = [], c = e.length, l = new An(function (e, n) {
        if (O) return e;
        if (!C) return e !== _[d] ? e : ++d < _.length ? x(e) : (C = !0, (h = function e(t, n, i) {
          var r = l.parent(n);
          if (r instanceof vt) return i && !(r.left instanceof dt || S.has(r.left.name)) ? e(r, n + 1, i) : t;
          if (r instanceof St) return !i || Oi.has(r.operator) && r.left !== t ? t : e(r, n + 1, i);
          if (r instanceof ft) return t;
          if (r instanceof Qe) return t;
          if (r instanceof At) return i && r.condition === t ? e(r, n + 1, i) : t;
          if (r instanceof it) return e(r, n + 1, !0);
          if (r instanceof He) return i ? e(r, n + 1, i) : t;
          if (r instanceof $e) return i && r.condition === t ? e(r, n + 1, i) : t;
          if (r instanceof ve) return t;
          if (r instanceof _t) return e(r, n + 1, r.tail_node() !== t);
          if (r instanceof de) return e(r, n + 1, !0);
          if (r instanceof je) return t;
          if (r instanceof lt) return t;
          return null;
        }(e, 0)) === e && (O = !0), e);
        var i,
            s = l.parent();
        if (e instanceof vt && "=" != e.operator && g.equivalent_to(e.left) || e instanceof Dn || e instanceof ft && g instanceof dt && g.equivalent_to(e.expression) || e instanceof pe || e instanceof Pe || e instanceof Ne && e.expression instanceof kt && e.expression.definition().references.length > 1 || e instanceof ve && !(e instanceof Ce) || e instanceof We || e instanceof et || e instanceof Me || e instanceof gn || e instanceof ct || s instanceof Ce && e !== s.init || !T && e instanceof Zt && !e.is_declared(t) && !Pi.has(e)) return O = !0, e;

        if (D || A && T || !(s instanceof St && Oi.has(s.operator) && s.left !== e || s instanceof At && s.condition !== e || s instanceof $e && s.condition !== e) || (D = s), M && !(e instanceof Lt) && g.equivalent_to(e)) {
          if (D) return O = !0, e;
          if (Mi(e, s)) return E && F++, e;
          if (F++, E && m instanceof lt) return e;
          if (a = O = !0, t.info("Collapsing {name} [{file}:{line},{col}]", {
            name: e.print_to_string(),
            file: e.start.file,
            line: e.start.line,
            col: e.start.col
          }), m instanceof gt) return ui(Dt, m, m);

          if (m instanceof lt) {
            var u = m.name.definition(),
                c = m.value;
            return u.references.length - u.replaced != 1 || t.exposed(u) ? ui(vt, m, {
              operator: "=",
              left: ui(Zt, m.name, m.name),
              right: c
            }) : (u.replaced++, y && vi(c) ? c.transform(t) : fi(s, e, c));
          }

          return Jn(m, zn), m;
        }

        return (e instanceof ft || e instanceof He && (v || g instanceof dt || X(g)) || e instanceof dt && (v || e.expression.may_throw_on_access(t)) || e instanceof Zt && (S.get(e.name) || v && X(e)) || e instanceof lt && e.value && (S.has(e.name.name) || v && X(e.name)) || (i = Mi(e.left, e)) && (i instanceof dt || S.has(i.name)) || b && (r ? e.has_side_effects(t) : function e(t, n) {
          if (t instanceof vt) return e(t.left, !0);
          if (t instanceof ht) return e(t.expression, !0);
          if (t instanceof lt) return t.value && e(t.value);

          if (n) {
            if (t instanceof mt) return e(t.expression, !0);
            if (t instanceof Et) return e(t.expression, !0);
            if (t instanceof Zt) return t.definition().scope !== o;
          }

          return !1;
        }(e))) && (h = e, e instanceof Re && (O = !0)), x(e);
      }, function (e) {
        O || (h === e && (O = !0), D === e && (D = null));
      }), p = new An(function (e) {
        if (O) return e;

        if (!C) {
          if (e !== _[d]) return e;
          if (++d < _.length) return;
          return C = !0, e;
        }

        return e instanceof Zt && e.name == N.name ? (--F || (O = !0), Mi(e, p.parent()) ? e : (N.replaced++, E.replaced--, m.value)) : e instanceof Je || e instanceof Re ? e : void 0;
      }); --c >= 0;) {
        0 == c && t.option("unused") && I();
        var _ = [];

        for (L(e[c]); u.length > 0;) {
          _ = u.pop();
          var d = 0,
              m = _[_.length - 1],
              E = null,
              h = null,
              D = null,
              g = V(m);

          if (g && !ri(g) && !g.has_side_effects(t)) {
            var S = B(m),
                A = U(g);
            g instanceof Zt && S.set(g.name, !1);
            var v = G(m),
                T = H(),
                b = m.may_throw(t),
                y = m.name instanceof Ut,
                C = y,
                O = !1,
                F = 0,
                M = !s || !C;

            if (!M) {
              for (var R = t.self().argnames.lastIndexOf(m.name) + 1; !O && R < s.length; R++) {
                s[R].transform(l);
              }

              M = !0;
            }

            for (var w = c; !O && w < e.length; w++) {
              e[w].transform(l);
            }

            if (E) {
              var N = m.name.definition();
              if (O && N.references.length - N.replaced > F) F = !1;else {
                O = !1, d = 0, C = y;

                for (w = c; !O && w < e.length; w++) {
                  e[w].transform(p);
                }

                E.single_use = !1;
              }
            }

            F && !K(m) && e.splice(c, 1);
          }
        }
      }

      function x(e) {
        if (e instanceof Re) return e;

        if (e instanceof je) {
          e.expression = e.expression.transform(l);

          for (var t = 0, n = e.body.length; !O && t < n; t++) {
            var i = e.body[t];

            if (i instanceof Qe) {
              if (!C) {
                if (i !== _[d]) continue;
                d++;
              }

              if (i.expression = i.expression.transform(l), !T) break;
            }
          }

          return O = !0, e;
        }
      }

      function k(e, t, n) {
        var i = !1,
            r = !(e instanceof Le);
        return t.walk(new Sn(function (t, a) {
          if (i) return !0;

          if (t instanceof Zt && (e.variables.has(t.name) || function (e, t) {
            if (e.global) return !1;
            var n = e.scope;

            for (; n && n !== t;) {
              if (n.variables.has(e.name)) return !0;
              n = n.parent_scope;
            }

            return !1;
          }(t.definition(), e))) {
            var s = t.definition().scope;
            if (s !== o) for (; s = s.parent_scope;) {
              if (s === o) return !0;
            }
            return i = !0;
          }

          if ((n || r) && t instanceof tn) return i = !0;

          if (t instanceof Re && !(t instanceof Le)) {
            var u = r;
            return r = !1, a(), r = u, !0;
          }
        })), i;
      }

      function I() {
        var e,
            n = t.self();

        if (ii(n) && !n.name && !n.uses_arguments && !n.pinned() && (e = t.parent()) instanceof ft && e.expression === n && e.args.every(function (e) {
          return !(e instanceof Ne);
        })) {
          var r = t.has_directive("use strict");
          r && !i(r, n.body) && (r = !1);
          var o = n.argnames.length;
          s = e.args.slice(o);

          for (var a = new Set(), c = o; --c >= 0;) {
            var l = n.argnames[c],
                f = e.args[c];

            var _i5 = l.definition && l.definition();

            if (!(_i5 && _i5.orig.length > 1) && (s.unshift(ui(lt, l, {
              name: l,
              value: f
            })), !a.has(l.name))) if (a.add(l.name), l instanceof Ne) {
              var p = e.args.slice(c);
              p.every(function (e) {
                return !k(n, e, r);
              }) && u.unshift([ui(lt, l, {
                name: l.expression,
                value: ui(bt, e, {
                  elements: p
                })
              })]);
            } else f ? (f instanceof xe && f.pinned() || k(n, f, r)) && (f = null) : f = ui(pn, l).transform(t), f && u.unshift([ui(lt, l, {
              name: l,
              value: f
            })]);
          }
        }
      }

      function L(e) {
        if (_.push(e), e instanceof vt) e.left.has_side_effects(t) || u.push(_.slice()), L(e.right);else if (e instanceof St) L(e.left), L(e.right);else if (e instanceof ft) L(e.expression), e.args.forEach(L);else if (e instanceof Qe) L(e.expression);else if (e instanceof At) L(e.condition), L(e.consequent), L(e.alternative);else if (!(e instanceof it) || !t.option("unused") && e instanceof at) e instanceof Te ? (L(e.condition), e.body instanceof he || L(e.body)) : e instanceof He ? e.value && L(e.value) : e instanceof Ce ? (e.init && L(e.init), e.condition && L(e.condition), e.step && L(e.step), e.body instanceof he || L(e.body)) : e instanceof Oe ? (L(e.object), e.body instanceof he || L(e.body)) : e instanceof $e ? (L(e.condition), e.body instanceof he || L(e.body), !e.alternative || e.alternative instanceof he || L(e.alternative)) : e instanceof _t ? e.expressions.forEach(L) : e instanceof de ? L(e.body) : e instanceof je ? (L(e.expression), e.body.forEach(L)) : e instanceof ht ? "++" != e.operator && "--" != e.operator || u.push(_.slice()) : e instanceof lt && e.value && (u.push(_.slice()), L(e.value));else {
          var n = e.definitions.length,
              i = n - 200;

          for (i < 0 && (i = 0); i < n; i++) {
            L(e.definitions[i]);
          }
        }

        _.pop();
      }

      function V(e) {
        if (!(e instanceof lt && e.name instanceof Lt)) {
          var n = e[e instanceof vt ? "left" : "expression"];
          return !oi(n, Bt) && n;
        }

        var r = e.name.definition();

        if (i(e.name, r.orig)) {
          var o = r.references.length - r.replaced;
          if (o) return r.orig.length - r.eliminated > 1 && !(e.name instanceof Ut) || (o > 1 ? function (e) {
            var t = e.value;

            if (t instanceof Zt && "arguments" != t.name) {
              var n = t.definition();
              if (!n.undeclared) return E = n;
            }
          }(e) : !t.exposed(r)) ? ui(Zt, e.name, e.name) : void 0;
        }
      }

      function P(e) {
        return e[e instanceof vt ? "right" : "value"];
      }

      function B(e) {
        var n = new Map();
        if (e instanceof ht) return n;
        var i = new Sn(function (e, r) {
          for (var o = e; o instanceof dt;) {
            o = o.expression;
          }

          (o instanceof Zt || o instanceof tn) && n.set(o.name, n.get(o.name) || ni(t, i, e, e, 0));
        });
        return P(e).walk(i), n;
      }

      function K(n) {
        if (n.name instanceof Ut) {
          var i = t.parent(),
              r = t.self().argnames,
              o = r.indexOf(n.name);
          if (o < 0) i.args.length = Math.min(i.args.length, r.length - 1);else {
            var a = i.args;
            a[o] && (a[o] = ui(an, a[o], {
              value: 0
            }));
          }
          return !0;
        }

        var s = !1;
        return e[c].transform(new An(function (e, t, i) {
          return s ? e : e === n || e.body === n ? (s = !0, e instanceof lt ? (e.value = null, e) : i ? f.skip : null) : void 0;
        }, function (e) {
          if (e instanceof _t) switch (e.expressions.length) {
            case 0:
              return null;

            case 1:
              return e.expressions[0];
          }
        }));
      }

      function U(e) {
        for (; e instanceof dt;) {
          e = e.expression;
        }

        return e instanceof Zt && e.definition().scope === o && !(n && (S.has(e.name) || m instanceof ht || m instanceof vt && "=" != m.operator));
      }

      function G(e) {
        return e instanceof ht ? Fi.has(e.operator) : P(e).has_side_effects(t);
      }

      function H() {
        if (v) return !1;
        if (E) return !0;

        if (g instanceof Zt) {
          var e = g.definition();
          if (e.references.length - e.replaced == (m instanceof lt ? 1 : 2)) return !0;
        }

        return !1;
      }

      function X(e) {
        if (!e.definition) return !0;
        var t = e.definition();
        return !(1 == t.orig.length && t.orig[0] instanceof Gt) && (t.scope.get_defun_scope() !== o || !t.references.every(function (e) {
          var t = e.scope.get_defun_scope();
          return "Scope" == t.TYPE && (t = t.parent_scope), t === o;
        }));
      }
    }

    function c(e) {
      for (var t = [], n = 0; n < e.length;) {
        var i = e[n];
        i instanceof De && i.body.every(mi) ? (a = !0, c(i.body), e.splice.apply(e, [n, 1].concat(_toConsumableArray(i.body))), n += i.body.length) : i instanceof ge ? (a = !0, e.splice(n, 1)) : i instanceof _e ? t.indexOf(i.value) < 0 ? (n++, t.push(i.value)) : (a = !0, e.splice(n, 1)) : n++;
      }
    }

    function l(e, t) {
      for (var n = t.self(), i = function (e) {
        for (var t = 0, n = e.length; --n >= 0;) {
          var i = e[n];
          if (i instanceof $e && i.body instanceof Xe && ++t > 1) return !0;
        }

        return !1;
      }(e), r = n instanceof xe, o = e.length; --o >= 0;) {
        var s = e[o],
            u = g(o),
            c = e[u];

        if (r && !c && s instanceof Xe) {
          if (!s.value) {
            a = !0, e.splice(o, 1);
            continue;
          }

          if (s.value instanceof Dt && "void" == s.value.operator) {
            a = !0, e[o] = ui(de, s, {
              body: s.value.expression
            });
            continue;
          }
        }

        if (s instanceof $e) {
          var l;

          if (E(l = Bi(s.body))) {
            l.label && d(l.label.thedef.references, l), a = !0, (s = s.clone()).condition = s.condition.negate(t);
            var f = D(s.body, l);
            s.body = ui(De, s, {
              body: _i(s.alternative).concat(h())
            }), s.alternative = ui(De, s, {
              body: f
            }), e[o] = s.transform(t);
            continue;
          }

          if (E(l = Bi(s.alternative))) {
            l.label && d(l.label.thedef.references, l), a = !0, (s = s.clone()).body = ui(De, s.body, {
              body: _i(s.body).concat(h())
            });
            f = D(s.alternative, l);
            s.alternative = ui(De, s.alternative, {
              body: f
            }), e[o] = s.transform(t);
            continue;
          }
        }

        if (s instanceof $e && s.body instanceof Xe) {
          var p = s.body.value;

          if (!p && !s.alternative && (r && !c || c instanceof Xe && !c.value)) {
            a = !0, e[o] = ui(de, s.condition, {
              body: s.condition
            });
            continue;
          }

          if (p && !s.alternative && c instanceof Xe && c.value) {
            a = !0, (s = s.clone()).alternative = c, e[o] = s.transform(t), e.splice(u, 1);
            continue;
          }

          if (p && !s.alternative && (!c && r && i || c instanceof Xe)) {
            a = !0, (s = s.clone()).alternative = c || ui(Xe, s, {
              value: null
            }), e[o] = s.transform(t), c && e.splice(u, 1);
            continue;
          }

          var m = e[S(o)];

          if (t.option("sequences") && r && !s.alternative && m instanceof $e && m.body instanceof Xe && g(u) == e.length && c instanceof de) {
            a = !0, (s = s.clone()).alternative = ui(De, c, {
              body: [c, ui(Xe, c, {
                value: null
              })]
            }), e[o] = s.transform(t), e.splice(u, 1);
            continue;
          }
        }
      }

      function E(i) {
        if (!i) return !1;

        for (var a = o + 1, s = e.length; a < s; a++) {
          var u = e[a];
          if (u instanceof at || u instanceof ot) return !1;
        }

        var c = i instanceof We ? t.loopcontrol_target(i) : null;
        return i instanceof Xe && r && function (e) {
          return !e || e instanceof Dt && "void" == e.operator;
        }(i.value) || i instanceof qe && n === Ei(c) || i instanceof Ye && c instanceof De && n === c;
      }

      function h() {
        var t = e.slice(o + 1);
        return e.length = o + 1, t.filter(function (t) {
          return !(t instanceof Ve) || (e.push(t), !1);
        });
      }

      function D(e, t) {
        var n = _i(e).slice(0, -1);

        return t.value && n.push(ui(de, t.value, {
          body: t.value.expression
        })), n;
      }

      function g(t) {
        for (var n = t + 1, i = e.length; n < i; n++) {
          var r = e[n];
          if (!(r instanceof rt && _(r))) break;
        }

        return n;
      }

      function S(t) {
        for (var n = t; --n >= 0;) {
          var i = e[n];
          if (!(i instanceof rt && _(i))) break;
        }

        return n;
      }
    }

    function p(e, t) {
      for (var n, i = t.self(), r = 0, o = 0, s = e.length; r < s; r++) {
        var u = e[r];

        if (u instanceof We) {
          var c = t.loopcontrol_target(u);
          u instanceof Ye && !(c instanceof ve) && Ei(c) === i || u instanceof qe && Ei(c) === i ? u.label && d(u.label.thedef.references, u) : e[o++] = u;
        } else e[o++] = u;

        if (Bi(u)) {
          n = e.slice(r + 1);
          break;
        }
      }

      e.length = o, a = o != s, n && n.forEach(function (n) {
        bi(t, n, e);
      });
    }

    function _(e) {
      return e.definitions.every(function (e) {
        return !e.value;
      });
    }

    function m(e, t) {
      if (!(e.length < 2)) {
        for (var n = [], i = 0, r = 0, o = e.length; r < o; r++) {
          var s = e[r];

          if (s instanceof de) {
            n.length >= t.sequences_limit && c();
            var u = s.body;
            n.length > 0 && (u = u.drop_side_effect_free(t)), u && pi(n, u);
          } else s instanceof it && _(s) || s instanceof Ve ? e[i++] = s : (c(), e[i++] = s);
        }

        c(), e.length = i, i != o && (a = !0);
      }

      function c() {
        if (n.length) {
          var t = ci(n[0], n);
          e[i++] = ui(de, t, {
            body: t
          }), n = [];
        }
      }
    }

    function E(e, t) {
      if (!(e instanceof De)) return e;

      for (var n = null, i = 0, r = e.body.length; i < r; i++) {
        var o = e.body[i];
        if (o instanceof rt && _(o)) t.push(o);else {
          if (n) return !1;
          n = o;
        }
      }

      return n;
    }

    function h(e, t) {
      function n(e) {
        r--, a = !0;
        var n = i.body;
        return ci(n, [n, e]).transform(t);
      }

      for (var i, r = 0, o = 0; o < e.length; o++) {
        var s = e[o];
        if (i) if (s instanceof He) s.value = n(s.value || ui(pn, s).transform(t));else if (s instanceof Ce) {
          if (!(s.init instanceof it)) {
            var u = !1;
            i.body.walk(new Sn(function (e) {
              return !!(u || e instanceof Re) || (e instanceof St && "in" == e.operator ? (u = !0, !0) : void 0);
            })), u || (s.init ? s.init = n(s.init) : (s.init = i.body, r--, a = !0));
          }
        } else s instanceof Oe ? s.init instanceof at || s.init instanceof ot || (s.object = n(s.object)) : s instanceof $e ? s.condition = n(s.condition) : s instanceof je ? s.expression = n(s.expression) : s instanceof Me && (s.expression = n(s.expression));

        if (t.option("conditionals") && s instanceof $e) {
          var c = [],
              l = E(s.body, c),
              f = E(s.alternative, c);

          if (!1 !== l && !1 !== f && c.length > 0) {
            var p = c.length;
            c.push(ui($e, s, {
              condition: s.condition,
              body: l || ui(ge, s.body),
              alternative: f
            })), c.unshift(r, 1), [].splice.apply(e, c), o += p, r += p + 1, i = null, a = !0;
            continue;
          }
        }

        e[r++] = s, i = s instanceof de ? s : null;
      }

      e.length = r;
    }

    function D(e, n) {
      if (e instanceof it) {
        var i,
            r = e.definitions[e.definitions.length - 1];
        if (r.value instanceof yt) if (n instanceof vt ? i = [n] : n instanceof _t && (i = n.expressions.slice()), i) {
          var a = !1;

          do {
            var s = i[0];
            if (!(s instanceof vt)) break;
            if ("=" != s.operator) break;
            if (!(s.left instanceof dt)) break;
            var u = s.left.expression;
            if (!(u instanceof Zt)) break;
            if (r.name.name != u.name) break;
            if (!s.right.is_constant_expression(o)) break;
            var c = s.left.property;
            if (c instanceof le && (c = c.evaluate(t)), c instanceof le) break;
            c = "" + c;
            var l = t.option("ecma") < 6 && t.has_directive("use strict") ? function (e) {
              return e.key != c && e.key && e.key.name != c;
            } : function (e) {
              return e.key && e.key.name != c;
            };
            if (!r.value.properties.every(l)) break;
            var f = r.value.properties.filter(function (e) {
              return e.key === c;
            })[0];
            f ? f.value = new _t({
              start: f.start,
              expressions: [f.value.clone(), s.right.clone()],
              end: f.end
            }) : r.value.properties.push(ui(Ot, s, {
              key: c,
              value: s.right
            })), i.shift(), a = !0;
          } while (i.length);

          return a && i;
        }
      }
    }

    function g(e) {
      for (var t, n = 0, i = -1, r = e.length; n < r; n++) {
        var o = e[n],
            s = e[i];
        if (o instanceof it) s && s.TYPE == o.TYPE ? (s.definitions = s.definitions.concat(o.definitions), a = !0) : t && t.TYPE == o.TYPE && _(o) ? (t.definitions = t.definitions.concat(o.definitions), a = !0) : (e[++i] = o, t = o);else if (o instanceof He) o.value = c(o.value);else if (o instanceof Ce) {
          (u = D(s, o.init)) ? (a = !0, o.init = u.length ? ci(o.init, u) : null, e[++i] = o) : s instanceof rt && (!o.init || o.init.TYPE == s.TYPE) ? (o.init && (s.definitions = s.definitions.concat(o.init.definitions)), o.init = s, e[i] = o, a = !0) : t && o.init && t.TYPE == o.init.TYPE && _(o.init) ? (t.definitions = t.definitions.concat(o.init.definitions), o.init = null, e[++i] = o, a = !0) : e[++i] = o;
        } else if (o instanceof Oe) o.object = c(o.object);else if (o instanceof $e) o.condition = c(o.condition);else if (o instanceof de) {
          var u;

          if (u = D(s, o.body)) {
            if (a = !0, !u.length) continue;
            o.body = ci(o.body, u);
          }

          e[++i] = o;
        } else o instanceof je ? o.expression = c(o.expression) : o instanceof Me ? o.expression = c(o.expression) : e[++i] = o;
      }

      function c(t) {
        e[++i] = o;
        var n = D(s, t);
        return n ? (a = !0, n.length ? ci(t, n) : t instanceof _t ? t.tail_node().left : t.left) : t;
      }

      e.length = i + 1;
    }
  }

  function bi(e, t, n) {
    t instanceof Ve || e.warn("Dropping unreachable code [{file}:{line},{col}]", t.start), t.walk(new Sn(function (i) {
      return i instanceof rt ? (e.warn("Declarations in unreachable code! [{file}:{line},{col}]", i.start), i.remove_initializers(), n.push(i), !0) : i instanceof Ve && (i === t || !e.has_directive("use strict")) ? (n.push(i === t ? i : ui(rt, i, {
        definitions: [ui(lt, i, {
          name: ui(Vt, i.name, i.name),
          value: null
        })]
      })), !0) : i instanceof Re || void 0;
    }));
  }

  function yi(e) {
    return e instanceof rn ? e.getValue() : e instanceof Dt && "void" == e.operator && e.expression instanceof rn ? void 0 : e;
  }

  function Ci(e, t) {
    return jn(e, Hn) || e instanceof pn || e instanceof Dt && "void" == e.operator && !e.expression.has_side_effects(t);
  }

  !function (e) {
    function t(e) {
      return /strict/.test(e.option("pure_getters"));
    }

    le.DEFMETHOD("may_throw_on_access", function (e) {
      return !e.option("pure_getters") || this._dot_throw(e);
    }), e(le, t), e(ln, u), e(pn, u), e(rn, s), e(bt, s), e(yt, function (e) {
      if (!t(e)) return !1;

      for (var n = this.properties.length; --n >= 0;) {
        if (this.properties[n]._dot_throw(e)) return !0;
      }

      return !1;
    }), e(Ct, s), e(Mt, u), e(Ne, function (e) {
      return this.expression._dot_throw(e);
    }), e(Ie, s), e(Le, s), e(gt, s), e(Dt, function () {
      return "void" == this.operator;
    }), e(St, function (e) {
      return ("&&" == this.operator || "||" == this.operator) && (this.left._dot_throw(e) || this.right._dot_throw(e));
    }), e(vt, function (e) {
      return "=" == this.operator && this.right._dot_throw(e);
    }), e(At, function (e) {
      return this.consequent._dot_throw(e) || this.alternative._dot_throw(e);
    }), e(mt, function (e) {
      return !!t(e) && !(this.expression instanceof Ie && "prototype" == this.property);
    }), e(_t, function (e) {
      return this.tail_node()._dot_throw(e);
    }), e(Zt, function (e) {
      if (jn(this, Hn)) return !0;
      if (!t(e)) return !1;
      if (Di(this) && this.is_declared(e)) return !1;
      if (this.is_immutable()) return !1;
      var n = this.fixed_value();
      return !n || n._dot_throw(e);
    });
  }(function (e, t) {
    e.DEFMETHOD("_dot_throw", t);
  }), function (e) {
    var t = E("! delete"),
        n = E("in instanceof == != === !== < <= >= >");
    e(le, s), e(Dt, function () {
      return t.has(this.operator);
    }), e(St, function () {
      return n.has(this.operator) || Oi.has(this.operator) && this.left.is_boolean() && this.right.is_boolean();
    }), e(At, function () {
      return this.consequent.is_boolean() && this.alternative.is_boolean();
    }), e(vt, function () {
      return "=" == this.operator && this.right.is_boolean();
    }), e(_t, function () {
      return this.tail_node().is_boolean();
    }), e(hn, u), e(En, u);
  }(function (e, t) {
    e.DEFMETHOD("is_boolean", t);
  }), function (e) {
    e(le, s), e(an, u);
    var t = E("+ - ~ ++ --");
    e(ht, function () {
      return t.has(this.operator);
    });
    var n = E("- * / % & | ^ << >> >>>");
    e(St, function (e) {
      return n.has(this.operator) || "+" == this.operator && this.left.is_number(e) && this.right.is_number(e);
    }), e(vt, function (e) {
      return n.has(this.operator.slice(0, -1)) || "=" == this.operator && this.right.is_number(e);
    }), e(_t, function (e) {
      return this.tail_node().is_number(e);
    }), e(At, function (e) {
      return this.consequent.is_number(e) && this.alternative.is_number(e);
    });
  }(function (e, t) {
    e.DEFMETHOD("is_number", t);
  }), (Si = function Si(e, t) {
    e.DEFMETHOD("is_string", t);
  })(le, s), Si(on, u), Si(Ke, function () {
    return 1 === this.segments.length;
  }), Si(Dt, function () {
    return "typeof" == this.operator;
  }), Si(St, function (e) {
    return "+" == this.operator && (this.left.is_string(e) || this.right.is_string(e));
  }), Si(vt, function (e) {
    return ("=" == this.operator || "+=" == this.operator) && this.right.is_string(e);
  }), Si(_t, function (e) {
    return this.tail_node().is_string(e);
  }), Si(At, function (e) {
    return this.consequent.is_string(e) && this.alternative.is_string(e);
  });
  var Oi = E("&& ||"),
      Fi = E("delete ++ --");

  function Mi(e, t) {
    return t instanceof ht && Fi.has(t.operator) ? t.expression : t instanceof vt && t.left === e ? e : void 0;
  }

  function Ri(e, t) {
    return e.print_to_string().length > t.print_to_string().length ? t : e;
  }

  function wi(e, t) {
    return Ri(ui(de, e, {
      body: e
    }), ui(de, t, {
      body: t
    })).body;
  }

  function Ni(e, t, n) {
    return (Fn(e) ? wi : Ri)(t, n);
  }

  function xi(e) {
    for (var _i6 = 0, _Object$keys = Object.keys(e); _i6 < _Object$keys.length; _i6++) {
      var t = _Object$keys[_i6];
      e[t] = E(e[t]);
    }
  }

  !function (e) {
    function t(e, t) {
      e.warn("global_defs " + t.print_to_string() + " redefined [{file}:{line},{col}]", t.start);
    }

    we.DEFMETHOD("resolve_defines", function (e) {
      return e.option("global_defs") ? (this.figure_out_scope({
        ie8: e.option("ie8")
      }), this.transform(new An(function (n) {
        var i = n._find_defs(e, "");

        if (i) {
          for (var r, o = 0, a = n; (r = this.parent(o++)) && r instanceof dt && r.expression === a;) {
            a = r;
          }

          if (!Mi(a, r)) return i;
          t(e, n);
        }
      }))) : this;
    }), e(le, a), e(mt, function (e, t) {
      return this.expression._find_defs(e, "." + this.property + t);
    }), e(Lt, function (e) {
      this.global() && D(e.option("global_defs"), this.name) && t(e, this);
    }), e(Zt, function (e, t) {
      if (this.global()) {
        var n = e.option("global_defs"),
            i = this.name + t;
        return D(n, i) ? function e(t, n) {
          if (t instanceof le) return ui(t.CTOR, n, t);
          if (Array.isArray(t)) return ui(bt, n, {
            elements: t.map(function (t) {
              return e(t, n);
            })
          });

          if (t && "object" == _typeof(t)) {
            var i = [];

            for (var r in t) {
              D(t, r) && i.push(ui(Ot, n, {
                key: r,
                value: e(t[r], n)
              }));
            }

            return ui(yt, n, {
              properties: i
            });
          }

          return li(t, n);
        }(n[i], this) : void 0;
      }
    });
  }(function (e, t) {
    e.DEFMETHOD("_find_defs", t);
  });
  var ki = ["constructor", "toString", "valueOf"],
      Ii = {
    Array: ["indexOf", "join", "lastIndexOf", "slice"].concat(ki),
    Boolean: ki,
    Function: ki,
    Number: ["toExponential", "toFixed", "toPrecision"].concat(ki),
    Object: ki,
    RegExp: ["test"].concat(ki),
    String: ["charAt", "charCodeAt", "concat", "indexOf", "italics", "lastIndexOf", "match", "replace", "search", "slice", "split", "substr", "substring", "toLowerCase", "toUpperCase", "trim"].concat(ki)
  };
  xi(Ii);
  var Li = {
    Array: ["isArray"],
    Math: ["abs", "acos", "asin", "atan", "ceil", "cos", "exp", "floor", "log", "round", "sin", "sqrt", "tan", "atan2", "pow", "max", "min"],
    Number: ["isFinite", "isNaN"],
    Object: ["create", "getOwnPropertyDescriptor", "getOwnPropertyNames", "getPrototypeOf", "isExtensible", "isFrozen", "isSealed", "keys"],
    String: ["fromCharCode"]
  };
  xi(Li), function (e) {
    le.DEFMETHOD("evaluate", function (e) {
      if (!e.option("evaluate")) return this;

      var t = this._eval(e, 1);

      return !t || t instanceof RegExp ? t : "function" == typeof t || "object" == _typeof(t) ? this : t;
    });
    var t = E("! ~ - + void");
    le.DEFMETHOD("is_constant", function () {
      return this instanceof rn ? !(this instanceof un) : this instanceof Dt && this.expression instanceof rn && t.has(this.operator);
    }), e(fe, function () {
      throw new Error(_("Cannot evaluate a statement [{file}:{line},{col}]", this.start));
    }), e(xe, c), e(wt, c), e(le, c), e(rn, function () {
      return this.getValue();
    }), e(un, function (e) {
      var t = e.evaluated_regexps.get(this);

      if (void 0 === t) {
        try {
          t = (0, eval)(this.print_to_string());
        } catch (e) {
          t = null;
        }

        e.evaluated_regexps.set(this, t);
      }

      return t || this;
    }), e(Ke, function () {
      return 1 !== this.segments.length ? this : this.segments[0].value;
    }), e(Ie, function (e) {
      if (e.option("unsafe")) {
        var t = function t() {};

        return t.node = this, t.toString = function () {
          return this.node.print_to_string();
        }, t;
      }

      return this;
    }), e(bt, function (e, t) {
      if (e.option("unsafe")) {
        for (var n = [], i = 0, r = this.elements.length; i < r; i++) {
          var o = this.elements[i],
              a = o._eval(e, t);

          if (o === a) return this;
          n.push(a);
        }

        return n;
      }

      return this;
    }), e(yt, function (e, t) {
      if (e.option("unsafe")) {
        for (var n = {}, i = 0, r = this.properties.length; i < r; i++) {
          var o = this.properties[i];
          if (o instanceof Ne) return this;
          var a = o.key;
          if (a instanceof kt) a = a.name;else if (a instanceof le && (a = a._eval(e, t)) === o.key) return this;
          if ("function" == typeof Object.prototype[a]) return this;
          if (!(o.value instanceof Ie) && (n[a] = o.value._eval(e, t), n[a] === o.value)) return this;
        }

        return n;
      }

      return this;
    });
    var n = E("! typeof void");
    e(Dt, function (e, t) {
      var i = this.expression;
      if (e.option("typeofs") && "typeof" == this.operator && (i instanceof xe || i instanceof Zt && i.fixed_value() instanceof xe)) return "function";
      if (n.has(this.operator) || t++, (i = i._eval(e, t)) === this.expression) return this;

      switch (this.operator) {
        case "!":
          return !i;

        case "typeof":
          return i instanceof RegExp ? this : _typeof(i);

        case "void":
          return;

        case "~":
          return ~i;

        case "-":
          return -i;

        case "+":
          return +i;
      }

      return this;
    });
    var i = E("&& || === !==");
    e(St, function (e, t) {
      i.has(this.operator) || t++;

      var n = this.left._eval(e, t);

      if (n === this.left) return this;

      var r,
          o = this.right._eval(e, t);

      if (o === this.right) return this;

      switch (this.operator) {
        case "&&":
          r = n && o;
          break;

        case "||":
          r = n || o;
          break;

        case "|":
          r = n | o;
          break;

        case "&":
          r = n & o;
          break;

        case "^":
          r = n ^ o;
          break;

        case "+":
          r = n + o;
          break;

        case "*":
          r = n * o;
          break;

        case "**":
          r = Math.pow(n, o);
          break;

        case "/":
          r = n / o;
          break;

        case "%":
          r = n % o;
          break;

        case "-":
          r = n - o;
          break;

        case "<<":
          r = n << o;
          break;

        case ">>":
          r = n >> o;
          break;

        case ">>>":
          r = n >>> o;
          break;

        case "==":
          r = n == o;
          break;

        case "===":
          r = n === o;
          break;

        case "!=":
          r = n != o;
          break;

        case "!==":
          r = n !== o;
          break;

        case "<":
          r = n < o;
          break;

        case "<=":
          r = n <= o;
          break;

        case ">":
          r = n > o;
          break;

        case ">=":
          r = n >= o;
          break;

        default:
          return this;
      }

      return isNaN(r) && e.find_parent(Me) ? this : r;
    }), e(At, function (e, t) {
      var n = this.condition._eval(e, t);

      if (n === this.condition) return this;

      var i = n ? this.consequent : this.alternative,
          r = i._eval(e, t);

      return r === i ? this : r;
    }), e(Zt, function (e, t) {
      var n,
          i = this.fixed_value();
      if (!i) return this;
      if (D(i, "_eval")) n = i._eval();else {
        if (this._eval = c, n = i._eval(e, t), delete this._eval, n === i) return this;

        i._eval = function () {
          return n;
        };
      }

      if (n && "object" == _typeof(n)) {
        var r = this.definition().escaped;
        if (r && t > r) return this;
      }

      return n;
    });
    var r = {
      Array: Array,
      Math: Math,
      Number: Number,
      Object: Object,
      String: String
    },
        o = {
      Math: ["E", "LN10", "LN2", "LOG2E", "LOG10E", "PI", "SQRT1_2", "SQRT2"],
      Number: ["MAX_VALUE", "MIN_VALUE", "NaN", "NEGATIVE_INFINITY", "POSITIVE_INFINITY"]
    };
    xi(o), e(dt, function (e, t) {
      if (e.option("unsafe")) {
        var n = this.property;
        if (n instanceof le && (n = n._eval(e, t)) === this.property) return this;
        var i,
            a = this.expression;

        if (Di(a)) {
          var s,
              u = "hasOwnProperty" === a.name && "call" === n && (s = e.parent() && e.parent().args) && s && s[0] && s[0].evaluate(e);
          if (null == (u = u instanceof mt ? u.expression : u) || u.thedef && u.thedef.undeclared) return this.clone();
          var c = o[a.name];
          if (!c || !c.has(n)) return this;
          i = r[a.name];
        } else {
          if (!(i = a._eval(e, t + 1)) || i === a || !D(i, n)) return this;
          if ("function" == typeof i) switch (n) {
            case "name":
              return i.node.name ? i.node.name.name : "";

            case "length":
              return i.node.argnames.length;

            default:
              return this;
          }
        }

        return i[n];
      }

      return this;
    }), e(ft, function (e, t) {
      var n = this.expression;

      if (e.option("unsafe") && n instanceof dt) {
        var i,
            o = n.property;
        if (o instanceof le && (o = o._eval(e, t)) === n.property) return this;
        var a = n.expression;

        if (Di(a)) {
          var s = "hasOwnProperty" === a.name && "call" === o && this.args[0] && this.args[0].evaluate(e);
          if (null == (s = s instanceof mt ? s.expression : s) || s.thedef && s.thedef.undeclared) return this.clone();
          var u = Li[a.name];
          if (!u || !u.has(o)) return this;
          i = r[a.name];
        } else {
          if ((i = a._eval(e, t + 1)) === a || !i) return this;
          var c = Ii[i.constructor.name];
          if (!c || !c.has(o)) return this;
        }

        for (var l = [], f = 0, p = this.args.length; f < p; f++) {
          var _ = this.args[f],
              d = _._eval(e, t);

          if (_ === d) return this;
          l.push(d);
        }

        try {
          return i[o].apply(i, l);
        } catch (t) {
          e.warn("Error evaluating {code} [{file}:{line},{col}]", {
            code: this.print_to_string(),
            file: this.start.file,
            line: this.start.line,
            col: this.start.col
          });
        }
      }

      return this;
    }), e(pt, c);
  }(function (e, t) {
    e.DEFMETHOD("_eval", t);
  }), function (e) {
    function t(e) {
      return ui(Dt, e, {
        operator: "!",
        expression: e
      });
    }

    function n(e, n, i) {
      var r = t(e);

      if (i) {
        var o = ui(de, n, {
          body: n
        });
        return Ri(r, o) === o ? n : r;
      }

      return Ri(r, n);
    }

    e(le, function () {
      return t(this);
    }), e(fe, function () {
      throw new Error("Cannot negate a statement");
    }), e(Ie, function () {
      return t(this);
    }), e(Le, function () {
      return t(this);
    }), e(Dt, function () {
      return "!" == this.operator ? this.expression : t(this);
    }), e(_t, function (e) {
      var t = this.expressions.slice();
      return t.push(t.pop().negate(e)), ci(this, t);
    }), e(At, function (e, t) {
      var i = this.clone();
      return i.consequent = i.consequent.negate(e), i.alternative = i.alternative.negate(e), n(this, i, t);
    }), e(St, function (e, i) {
      var r = this.clone(),
          o = this.operator;
      if (e.option("unsafe_comps")) switch (o) {
        case "<=":
          return r.operator = ">", r;

        case "<":
          return r.operator = ">=", r;

        case ">=":
          return r.operator = "<", r;

        case ">":
          return r.operator = "<=", r;
      }

      switch (o) {
        case "==":
          return r.operator = "!=", r;

        case "!=":
          return r.operator = "==", r;

        case "===":
          return r.operator = "!==", r;

        case "!==":
          return r.operator = "===", r;

        case "&&":
          return r.operator = "||", r.left = r.left.negate(e, i), r.right = r.right.negate(e), n(this, r, i);

        case "||":
          return r.operator = "&&", r.left = r.left.negate(e, i), r.right = r.right.negate(e), n(this, r, i);
      }

      return t(this);
    });
  }(function (e, t) {
    e.DEFMETHOD("negate", function (e, n) {
      return t.call(this, e, n);
    });
  });
  var Vi = E("Boolean decodeURI decodeURIComponent Date encodeURI encodeURIComponent Error escape EvalError isFinite isNaN Number Object parseFloat parseInt RangeError ReferenceError String SyntaxError TypeError unescape URIError");
  ft.DEFMETHOD("is_expr_pure", function (e) {
    if (e.option("unsafe")) {
      var t = this.expression,
          n = this.args && this.args[0] && this.args[0].evaluate(e);
      if (t.expression && "hasOwnProperty" === t.expression.name && (null == n || n.thedef && n.thedef.undeclared)) return !1;
      if (Di(t) && Vi.has(t.name)) return !0;
      if (t instanceof mt && Di(t.expression) && Li.hasOwnProperty(t.expression.name) && Li[t.expression.name].has(t.property)) return !0;
    }

    return !!T(this, vn) || !e.pure_funcs(this);
  }), le.DEFMETHOD("is_call_pure", s), mt.DEFMETHOD("is_call_pure", function (e) {
    if (!e.option("unsafe")) return;
    var t = this.expression;
    var n;
    return t instanceof bt ? n = Ii.Array : t.is_boolean() ? n = Ii.Boolean : t.is_number(e) ? n = Ii.Number : t instanceof un ? n = Ii.RegExp : t.is_string(e) ? n = Ii.String : this.may_throw_on_access(e) || (n = Ii.Object), n && n.has(this.property);
  });
  var Pi = new Set(["Number", "String", "Array", "Object", "Function", "Promise"]);

  function Bi(e) {
    return e && e.aborts();
  }

  !function (e) {
    function t(e, t) {
      for (var n = e.length; --n >= 0;) {
        if (e[n].has_side_effects(t)) return !0;
      }

      return !1;
    }

    e(le, u), e(ge, s), e(rn, s), e(tn, s), e(he, function (e) {
      return t(this.body, e);
    }), e(ft, function (e) {
      return !(this.is_expr_pure(e) || this.expression.is_call_pure(e) && !this.expression.has_side_effects(e)) || t(this.args, e);
    }), e(je, function (e) {
      return this.expression.has_side_effects(e) || t(this.body, e);
    }), e(Qe, function (e) {
      return this.expression.has_side_effects(e) || t(this.body, e);
    }), e(et, function (e) {
      return t(this.body, e) || this.bcatch && this.bcatch.has_side_effects(e) || this.bfinally && this.bfinally.has_side_effects(e);
    }), e($e, function (e) {
      return this.condition.has_side_effects(e) || this.body && this.body.has_side_effects(e) || this.alternative && this.alternative.has_side_effects(e);
    }), e(Ae, function (e) {
      return this.body.has_side_effects(e);
    }), e(de, function (e) {
      return this.body.has_side_effects(e);
    }), e(xe, s), e(wt, function (e) {
      return !!this.extends && this.extends.has_side_effects(e);
    }), e(Nt, u), e(St, function (e) {
      return this.left.has_side_effects(e) || this.right.has_side_effects(e);
    }), e(vt, u), e(At, function (e) {
      return this.condition.has_side_effects(e) || this.consequent.has_side_effects(e) || this.alternative.has_side_effects(e);
    }), e(ht, function (e) {
      return Fi.has(this.operator) || this.expression.has_side_effects(e);
    }), e(Zt, function (e) {
      return !this.is_declared(e) && !Pi.has(this.name);
    }), e(Lt, s), e(yt, function (e) {
      return t(this.properties, e);
    }), e(Ct, function (e) {
      return !!(this instanceof Ot && this.key instanceof le && this.key.has_side_effects(e)) || this.value.has_side_effects(e);
    }), e(bt, function (e) {
      return t(this.elements, e);
    }), e(mt, function (e) {
      return this.expression.may_throw_on_access(e) || this.expression.has_side_effects(e);
    }), e(Et, function (e) {
      return this.expression.may_throw_on_access(e) || this.expression.has_side_effects(e) || this.property.has_side_effects(e);
    }), e(_t, function (e) {
      return t(this.expressions, e);
    }), e(it, function (e) {
      return t(this.definitions, e);
    }), e(lt, function (e) {
      return this.value;
    }), e(Ue, s), e(Ke, function (e) {
      return t(this.segments, e);
    });
  }(function (e, t) {
    e.DEFMETHOD("has_side_effects", t);
  }), function (e) {
    function t(e, t) {
      for (var n = e.length; --n >= 0;) {
        if (e[n].may_throw(t)) return !0;
      }

      return !1;
    }

    e(le, u), e(wt, s), e(rn, s), e(ge, s), e(xe, s), e(Lt, s), e(tn, s), e(bt, function (e) {
      return t(this.elements, e);
    }), e(vt, function (e) {
      return !!this.right.may_throw(e) || !(!e.has_directive("use strict") && "=" == this.operator && this.left instanceof Zt) && this.left.may_throw(e);
    }), e(St, function (e) {
      return this.left.may_throw(e) || this.right.may_throw(e);
    }), e(he, function (e) {
      return t(this.body, e);
    }), e(ft, function (e) {
      return !!t(this.args, e) || !this.is_expr_pure(e) && (!!this.expression.may_throw(e) || !(this.expression instanceof xe) || t(this.expression.body, e));
    }), e(Qe, function (e) {
      return this.expression.may_throw(e) || t(this.body, e);
    }), e(At, function (e) {
      return this.condition.may_throw(e) || this.consequent.may_throw(e) || this.alternative.may_throw(e);
    }), e(it, function (e) {
      return t(this.definitions, e);
    }), e(mt, function (e) {
      return this.expression.may_throw_on_access(e) || this.expression.may_throw(e);
    }), e($e, function (e) {
      return this.condition.may_throw(e) || this.body && this.body.may_throw(e) || this.alternative && this.alternative.may_throw(e);
    }), e(Ae, function (e) {
      return this.body.may_throw(e);
    }), e(yt, function (e) {
      return t(this.properties, e);
    }), e(Ct, function (e) {
      return this.value.may_throw(e);
    }), e(Xe, function (e) {
      return this.value && this.value.may_throw(e);
    }), e(_t, function (e) {
      return t(this.expressions, e);
    }), e(de, function (e) {
      return this.body.may_throw(e);
    }), e(Et, function (e) {
      return this.expression.may_throw_on_access(e) || this.expression.may_throw(e) || this.property.may_throw(e);
    }), e(je, function (e) {
      return this.expression.may_throw(e) || t(this.body, e);
    }), e(Zt, function (e) {
      return !this.is_declared(e) && !Pi.has(this.name);
    }), e(et, function (e) {
      return this.bcatch ? this.bcatch.may_throw(e) : t(this.body, e) || this.bfinally && this.bfinally.may_throw(e);
    }), e(ht, function (e) {
      return !("typeof" == this.operator && this.expression instanceof Zt) && this.expression.may_throw(e);
    }), e(lt, function (e) {
      return !!this.value && this.value.may_throw(e);
    });
  }(function (e, t) {
    e.DEFMETHOD("may_throw", t);
  }), function (e) {
    function t(e) {
      var t = this,
          n = !0;
      return t.walk(new Sn(function (r) {
        if (!n) return !0;

        if (r instanceof Zt) {
          if (jn(t, Xn)) return n = !1, !0;
          var o = r.definition();

          if (i(o, t.enclosed) && !t.variables.has(o.name)) {
            if (e) {
              var a = e.find_variable(r);
              if (o.undeclared ? !a : a === o) return n = "f", !0;
            }

            n = !1;
          }

          return !0;
        }

        return r instanceof tn && t instanceof Le ? (n = !1, !0) : void 0;
      })), n;
    }

    e(le, s), e(rn, u), e(wt, function (e) {
      return !(this.extends && !this.extends.is_constant_expression(e)) && t.call(this, e);
    }), e(xe, t), e(ht, function () {
      return this.expression.is_constant_expression();
    }), e(St, function () {
      return this.left.is_constant_expression() && this.right.is_constant_expression();
    }), e(bt, function () {
      return this.elements.every(function (e) {
        return e.is_constant_expression();
      });
    }), e(yt, function () {
      return this.properties.every(function (e) {
        return e.is_constant_expression();
      });
    }), e(Ct, function () {
      return !(this.key instanceof le) && this.value.is_constant_expression();
    });
  }(function (e, t) {
    e.DEFMETHOD("is_constant_expression", t);
  }), function (e) {
    function t() {
      for (var e = 0; e < this.body.length; e++) {
        if (Bi(this.body[e])) return this.body[e];
      }

      return null;
    }

    e(fe, l), e(Ge, c), e(ut, function () {
      return null;
    }), e(De, t), e(Ze, t), e($e, function () {
      return this.alternative && Bi(this.body) && Bi(this.alternative) && this;
    });
  }(function (e, t) {
    e.DEFMETHOD("aborts", t);
  });
  var Ki = new Set(["use asm", "use strict"]);

  function Ui(e, t) {
    return Ti(e.body, t), t.option("side_effects") && 1 == e.body.length && e.body[0] === t.has_directive("use strict") && (e.body.length = 0), e;
  }

  ei(_e, function (e, t) {
    return !t.option("directives") || Ki.has(e.value) && t.has_directive(e.value) === e ? e : ui(ge, e);
  }), ei(pe, function (e, t) {
    return t.option("drop_debugger") ? ui(ge, e) : e;
  }), ei(Ae, function (e, t) {
    return e.body instanceof Ye && t.loopcontrol_target(e.body) === e.body ? ui(ge, e) : 0 == e.label.references.length ? e.body : e;
  }), ei(he, function (e, t) {
    return Ti(e.body, t), e;
  }), ei(De, function (e, t) {
    switch (Ti(e.body, t), e.body.length) {
      case 1:
        if (!t.has_directive("use strict") && t.parent() instanceof $e && !((n = e.body[0]) instanceof at || n instanceof ot || n instanceof wt) || mi(e.body[0])) return e.body[0];
        break;

      case 0:
        return ui(ge, e);
    }

    var n;
    return e;
  }), ei(xe, Ui);
  var Gi = /keep_assign/;

  function Hi(e, t) {
    var n = !1,
        i = new Sn(function (t) {
      return !!(n || t instanceof Re) || (t instanceof We && i.loopcontrol_target(t) === e ? n = !0 : void 0);
    });
    return t instanceof Ae && i.push(t), i.push(e), e.body.walk(i), n;
  }

  function Xi(e, t) {
    return t.top_retain && e instanceof Ve && jn(e, qn) && e.name && t.top_retain(e.name);
  }

  Re.DEFMETHOD("drop_unused", function (e) {
    if (!e.option("unused")) return;
    if (e.has_directive("use asm")) return;
    var t = this;
    if (t.pinned()) return;
    var n = !(t instanceof we) || e.toplevel.funcs,
        i = !(t instanceof we) || e.toplevel.vars;
    var r = Gi.test(e.option("unused")) ? s : function (e) {
      return e instanceof vt && (jn(e, zn) || "=" == e.operator) ? e.left : e instanceof ht && jn(e, zn) ? e.expression : void 0;
    };
    var o = new Map(),
        a = new Map();
    t instanceof we && e.top_retain && t.variables.forEach(function (t) {
      e.top_retain(t) && !o.has(t.id) && o.set(t.id, t);
    });
    var u = new Map(),
        c = new Map(),
        l = this,
        p = new Sn(function (r, s) {
      if (r instanceof xe && r.uses_arguments && !p.has_directive("use strict") && r.argnames.forEach(function (e) {
        if (e instanceof Lt) {
          var t = e.definition();
          o.has(t.id) || o.set(t.id, t);
        }
      }), r !== t) {
        if (r instanceof Ve || r instanceof Nt) {
          var f = r.name.definition();
          return (p.parent() instanceof ct || !n && l === t) && f.global && !o.has(f.id) && o.set(f.id, f), r instanceof Nt && r.extends && (r.extends.has_side_effects(e) || r.extends.may_throw(e)) && r.extends.walk(p), h(c, f.id, r), !0;
        }

        if (r instanceof Ut && l === t && h(u, r.definition().id, r), r instanceof it && l === t) {
          var _t6 = p.parent() instanceof ct;

          return r.definitions.forEach(function (n) {
            if (n.name instanceof Vt && h(u, n.name.definition().id, n), !_t6 && i || n.name.walk(new Sn(function (e) {
              if (e instanceof Lt) {
                var n = e.definition();
                !_t6 && !n.global || o.has(n.id) || o.set(n.id, n);
              }
            })), n.value) {
              if (n.name instanceof Pe) n.walk(p);else {
                var r = n.name.definition();
                h(c, r.id, n.value), r.chained || n.name.fixed_value() !== n.value || a.set(r.id, n);
              }
              n.value.has_side_effects(e) && n.value.walk(p);
            }
          }), !0;
        }

        return m(r, s);
      }
    });
    t.walk(p), p = new Sn(m), o.forEach(function (e) {
      var t = c.get(e.id);
      t && t.forEach(function (e) {
        e.walk(p);
      });
    });

    var _ = new An(function (s, c, p) {
      var m = _.parent();

      if (i) {
        var _e8 = r(s);

        if (_e8 instanceof Zt) {
          var E = _e8.definition(),
              h = o.has(E.id);

          if (s instanceof vt) {
            if (!h || a.has(E.id) && a.get(E.id) !== s) return fi(m, s, s.right.transform(_));
          } else if (!h) return p ? f.skip : ui(an, s, {
            value: 0
          });
        }
      }

      if (l === t) {
        if (s.name && (s instanceof xt && !g(e.option("keep_classnames"), (E = s.name.definition()).name) || s instanceof Ie && !g(e.option("keep_fnames"), (E = s.name.definition()).name)) && (!o.has(E.id) || E.orig.length > 1) && (s.name = null), s instanceof xe && !(s instanceof ke)) for (var D = !e.option("keep_fargs"), S = s.argnames, A = S.length; --A >= 0;) {
          var v = S[A];
          v instanceof Ne && (v = v.expression), v instanceof Tt && (v = v.left), v instanceof Pe || o.has(v.definition().id) ? D = !1 : (Zn(v, Gn), D && (S.pop(), e[v.unreferenced() ? "warn" : "info"]("Dropping unused function argument {name} [{file}:{line},{col}]", M(v))));
        }

        if ((s instanceof Ve || s instanceof Nt) && s !== t) {
          var _t7 = s.name.definition();

          if (!(_t7.global && !n || o.has(_t7.id))) {
            if (e[s.name.unreferenced() ? "warn" : "info"]("Dropping unused function {name} [{file}:{line},{col}]", M(s.name)), _t7.eliminated++, s instanceof Nt) {
              var _t8 = s.drop_side_effect_free(e);

              if (_t8) return ui(de, s, {
                body: _t8
              });
            }

            return p ? f.skip : ui(ge, s);
          }
        }

        if (s instanceof it && !(m instanceof Oe && m.init === s)) {
          var T = !(m instanceof we || s instanceof rt),
              b = [],
              y = [],
              C = [],
              O = [];

          switch (s.definitions.forEach(function (t) {
            t.value && (t.value = t.value.transform(_));
            var n = t.name instanceof Pe,
                r = n ? new Pn(null, {
              name: "<destructure>"
            }) : t.name.definition();
            if (T && r.global) return C.push(t);

            if (!i && !T || n && (t.name.names.length || t.name.is_array || 1 != e.option("pure_getters")) || o.has(r.id)) {
              if (t.value && a.has(r.id) && a.get(r.id) !== t && (t.value = t.value.drop_side_effect_free(e)), t.name instanceof Vt) {
                var c = u.get(r.id);

                if (c.length > 1 && (!t.value || r.orig.indexOf(t.name) > r.eliminated)) {
                  if (e.warn("Dropping duplicated definition of variable {name} [{file}:{line},{col}]", M(t.name)), t.value) {
                    var l = ui(Zt, t.name, t.name);
                    r.references.push(l);
                    var f = ui(vt, t, {
                      operator: "=",
                      left: l,
                      right: t.value
                    });
                    a.get(r.id) === t && a.set(r.id, f), O.push(f.transform(_));
                  }

                  return d(c, t), void r.eliminated++;
                }
              }

              t.value ? (O.length > 0 && (C.length > 0 ? (O.push(t.value), t.value = ci(t.value, O)) : b.push(ui(de, s, {
                body: ci(s, O)
              })), O = []), C.push(t)) : y.push(t);
            } else if (r.orig[0] instanceof Yt) {
              (p = t.value && t.value.drop_side_effect_free(e)) && O.push(p), t.value = null, y.push(t);
            } else {
              var p;
              (p = t.value && t.value.drop_side_effect_free(e)) ? (n || e.warn("Side effects in initialization of unused variable {name} [{file}:{line},{col}]", M(t.name)), O.push(p)) : n || e[t.name.unreferenced() ? "warn" : "info"]("Dropping unused variable {name} [{file}:{line},{col}]", M(t.name)), r.eliminated++;
            }
          }), (y.length > 0 || C.length > 0) && (s.definitions = y.concat(C), b.push(s)), O.length > 0 && b.push(ui(de, s, {
            body: ci(s, O)
          })), b.length) {
            case 0:
              return p ? f.skip : ui(ge, s);

            case 1:
              return b[0];

            default:
              return p ? f.splice(b) : ui(De, s, {
                body: b
              });
          }
        }

        if (s instanceof Ce) return c(s, this), s.init instanceof De && (F = s.init, s.init = F.body.pop(), F.body.push(s)), s.init instanceof de ? s.init = s.init.body : di(s.init) && (s.init = null), F ? p ? f.splice(F.body) : F : s;

        if (s instanceof Ae && s.body instanceof Ce) {
          if (c(s, this), s.body instanceof De) {
            var F = s.body;
            return s.body = F.body.pop(), F.body.push(s), p ? f.splice(F.body) : F;
          }

          return s;
        }

        if (s instanceof De) return c(s, this), p && s.body.every(mi) ? f.splice(s.body) : s;

        if (s instanceof Re) {
          var _e9 = l;
          return l = s, c(s, this), l = _e9, s;
        }
      }

      function M(e) {
        return {
          name: e.name,
          file: e.start.file,
          line: e.start.line,
          col: e.start.col
        };
      }
    });

    function m(e, n) {
      var i;
      var s = r(e);
      if (s instanceof Zt && !oi(e.left, Pt) && t.variables.get(s.name) === (i = s.definition())) return e instanceof vt && (e.right.walk(p), i.chained || e.left.fixed_value() !== e.right || a.set(i.id, e)), !0;

      if (e instanceof Zt) {
        if (i = e.definition(), !o.has(i.id) && (o.set(i.id, i), i.orig[0] instanceof Yt)) {
          var _e10 = i.scope.is_block_scope() && i.scope.get_defun_scope().variables.get(i.name);

          _e10 && o.set(_e10.id, _e10);
        }

        return !0;
      }

      if (e instanceof Re) {
        var u = l;
        return l = e, n(), l = u, !0;
      }
    }

    t.transform(_);
  }), Re.DEFMETHOD("hoist_declarations", function (e) {
    var t = this;
    if (e.has_directive("use asm")) return t;
    if (!Array.isArray(t.body)) return t;
    var n = e.option("hoist_funs"),
        i = e.option("hoist_vars");

    if (n || i) {
      var r = [],
          o = [],
          a = new Map(),
          s = 0,
          u = 0;
      t.walk(new Sn(function (e) {
        return e instanceof Re && e !== t || (e instanceof rt ? (++u, !0) : void 0);
      })), i = i && u > 1;
      var c = new An(function (u) {
        if (u !== t) {
          if (u instanceof _e) return r.push(u), ui(ge, u);
          if (n && u instanceof Ve && !(c.parent() instanceof ct) && c.parent() === t) return o.push(u), ui(ge, u);

          if (i && u instanceof rt) {
            u.definitions.forEach(function (e) {
              e.name instanceof Pe || (a.set(e.name.name, e), ++s);
            });
            var l = u.to_assignments(e),
                f = c.parent();

            if (f instanceof Oe && f.init === u) {
              if (null == l) {
                var p = u.definitions[0].name;
                return ui(Zt, p, p);
              }

              return l;
            }

            return f instanceof Ce && f.init === u ? l : l ? ui(de, u, {
              body: l
            }) : ui(ge, u);
          }

          if (u instanceof Re) return u;
        }
      });

      if (t = t.transform(c), s > 0) {
        var l = [];

        var _e11 = t instanceof xe,
            _n5 = _e11 ? t.args_as_names() : null;

        if (a.forEach(function (t, i) {
          _e11 && _n5.some(function (e) {
            return e.name === t.name.name;
          }) ? a.delete(i) : ((t = t.clone()).value = null, l.push(t), a.set(i, t));
        }), l.length > 0) {
          for (var f = 0; f < t.body.length;) {
            if (t.body[f] instanceof de) {
              var p,
                  _,
                  m = t.body[f].body;

              if (m instanceof vt && "=" == m.operator && (p = m.left) instanceof kt && a.has(p.name)) {
                if ((E = a.get(p.name)).value) break;
                E.value = m.right, d(l, E), l.push(E), t.body.splice(f, 1);
                continue;
              }

              if (m instanceof _t && (_ = m.expressions[0]) instanceof vt && "=" == _.operator && (p = _.left) instanceof kt && a.has(p.name)) {
                var E;
                if ((E = a.get(p.name)).value) break;
                E.value = _.right, d(l, E), l.push(E), t.body[f].body = ci(m, m.expressions.slice(1));
                continue;
              }
            }

            if (t.body[f] instanceof ge) t.body.splice(f, 1);else {
              if (!(t.body[f] instanceof De)) break;
              var h = [f, 1].concat(t.body[f].body);
              t.body.splice.apply(t.body, h);
            }
          }

          l = ui(rt, t, {
            definitions: l
          }), o.push(l);
        }
      }

      t.body = r.concat(o, t.body);
    }

    return t;
  }), Re.DEFMETHOD("make_var_name", function (e) {
    for (var t = this.var_names(), n = e = e.replace(/(?:^[^a-z_$]|[^a-z0-9_$])/gi, "_"), i = 0; t.has(n); i++) {
      n = e + "$" + i;
    }

    return this.add_var_name(n), n;
  }), Re.DEFMETHOD("hoist_properties", function (e) {
    var t = this;
    if (!e.option("hoist_props") || e.has_directive("use asm")) return t;
    var n = t instanceof we && e.top_retain || s,
        i = new Map(),
        r = new An(function (o, a) {
      if (o instanceof it && r.parent() instanceof ct) return o;

      if (o instanceof lt) {
        var _r3 = o.name;

        var _u, _c;

        if (_r3.scope === t && 1 != (_u = _r3.definition()).escaped && !_u.assignments && !_u.direct_access && !_u.single_use && !e.exposed(_u) && !n(_u) && (_c = _r3.fixed_value()) === o.value && _c instanceof yt && _c.properties.every(function (e) {
          return "string" == typeof e.key;
        })) {
          a(o, this);

          var _e12 = new Map(),
              _t9 = [];

          return _c.properties.forEach(function (n) {
            _t9.push(ui(lt, o, {
              name: s(_r3, n.key, _e12),
              value: n.value
            }));
          }), i.set(_u.id, _e12), f.splice(_t9);
        }
      } else if (o instanceof dt && o.expression instanceof Zt) {
        var _e13 = i.get(o.expression.definition().id);

        if (_e13) {
          var _t10 = _e13.get(String(yi(o.property))),
              _n6 = ui(Zt, o, {
            name: _t10.name,
            scope: o.expression.scope,
            thedef: _t10
          });

          return _n6.reference({}), _n6;
        }
      }

      function s(e, n, i) {
        var r = ui(e.CTOR, e, {
          name: t.make_var_name(e.name + "_" + n),
          scope: t
        }),
            o = t.def_variable(r);
        return i.set(String(n), o), t.enclosed.push(o), r;
      }
    });
    return t.transform(r);
  }), function (e) {
    function t(e, t, n) {
      var i = e.length;
      if (!i) return null;

      for (var r = [], o = !1, a = 0; a < i; a++) {
        var s = e[a].drop_side_effect_free(t, n);
        o |= s !== e[a], s && (r.push(s), n = !1);
      }

      return o ? r.length ? r : null : e;
    }

    e(le, c), e(rn, l), e(tn, l), e(ft, function (e, n) {
      if (!this.is_expr_pure(e)) {
        if (this.expression.is_call_pure(e)) {
          var i = this.args.slice();
          return i.unshift(this.expression.expression), (i = t(i, e, n)) && ci(this, i);
        }

        if (ii(this.expression) && (!this.expression.name || !this.expression.name.definition().references.length)) {
          var r = this.clone();
          return r.expression.process_expression(!1, e), r;
        }

        return this;
      }

      T(this, vn) && e.warn("Dropping __PURE__ call [{file}:{line},{col}]", this.start);
      var o = t(this.args, e, n);
      return o && ci(this, o);
    }), e(ke, l), e(Ie, l), e(Le, l), e(wt, function (e) {
      return this.extends ? this.extends.drop_side_effect_free(e) : null;
    }), e(St, function (e, t) {
      var n = this.right.drop_side_effect_free(e);
      if (!n) return this.left.drop_side_effect_free(e, t);

      if (Oi.has(this.operator)) {
        if (n === this.right) return this;
        var i = this.clone();
        return i.right = n, i;
      }

      var r = this.left.drop_side_effect_free(e, t);
      return r ? ci(this, [r, n]) : this.right.drop_side_effect_free(e, t);
    }), e(vt, function (e) {
      var t = this.left;
      if (t.has_side_effects(e) || e.has_directive("use strict") && t instanceof dt && t.expression.is_constant()) return this;

      for (Zn(this, zn); t instanceof dt;) {
        t = t.expression;
      }

      return t.is_constant_expression(e.find_parent(Re)) ? this.right.drop_side_effect_free(e) : this;
    }), e(At, function (e) {
      var t = this.consequent.drop_side_effect_free(e),
          n = this.alternative.drop_side_effect_free(e);
      if (t === this.consequent && n === this.alternative) return this;
      if (!t) return n ? ui(St, this, {
        operator: "||",
        left: this.condition,
        right: n
      }) : this.condition.drop_side_effect_free(e);
      if (!n) return ui(St, this, {
        operator: "&&",
        left: this.condition,
        right: t
      });
      var i = this.clone();
      return i.consequent = t, i.alternative = n, i;
    }), e(ht, function (e, t) {
      if (Fi.has(this.operator)) return this.expression.has_side_effects(e) ? Jn(this, zn) : Zn(this, zn), this;
      if ("typeof" == this.operator && this.expression instanceof Zt) return null;
      var n = this.expression.drop_side_effect_free(e, t);
      return t && n && hi(n) ? n === this.expression && "!" == this.operator ? this : n.negate(e, t) : n;
    }), e(Zt, function (e) {
      return this.is_declared(e) || Pi.has(this.name) ? null : this;
    }), e(yt, function (e, n) {
      var i = t(this.properties, e, n);
      return i && ci(this, i);
    }), e(Ct, function (e, t) {
      var n = this instanceof Ot && this.key instanceof le && this.key.drop_side_effect_free(e, t),
          i = this.value.drop_side_effect_free(e, t);
      return n && i ? ci(this, [n, i]) : n || i;
    }), e(bt, function (e, n) {
      var i = t(this.elements, e, n);
      return i && ci(this, i);
    }), e(mt, function (e, t) {
      return this.expression.may_throw_on_access(e) ? this : this.expression.drop_side_effect_free(e, t);
    }), e(Et, function (e, t) {
      if (this.expression.may_throw_on_access(e)) return this;
      var n = this.expression.drop_side_effect_free(e, t);
      if (!n) return this.property.drop_side_effect_free(e, t);
      var i = this.property.drop_side_effect_free(e);
      return i ? ci(this, [n, i]) : n;
    }), e(_t, function (e) {
      var t = this.tail_node(),
          n = t.drop_side_effect_free(e);
      if (n === t) return this;
      var i = this.expressions.slice(0, -1);
      return n && i.push(n), i.length ? ci(this, i) : ui(an, this, {
        value: 0
      });
    }), e(Ne, function (e, t) {
      return this.expression.drop_side_effect_free(e, t);
    }), e(Ue, l), e(Ke, function (e) {
      var n = t(this.segments, e, Fn);
      return n && ci(this, n);
    });
  }(function (e, t) {
    e.DEFMETHOD("drop_side_effect_free", t);
  }), ei(de, function (e, t) {
    if (t.option("side_effects")) {
      var n = e.body,
          i = n.drop_side_effect_free(t, !0);
      if (!i) return t.warn("Dropping side-effect-free statement [{file}:{line},{col}]", e.start), ui(ge, e);
      if (i !== n) return ui(de, e, {
        body: i
      });
    }

    return e;
  }), ei(ye, function (e, t) {
    return t.option("loops") ? ui(Ce, e, e).optimize(t) : e;
  }), ei(be, function (e, t) {
    if (!t.option("loops")) return e;
    var n = e.condition.tail_node().evaluate(t);

    if (!(n instanceof le)) {
      if (n) return ui(Ce, e, {
        body: ui(De, e.body, {
          body: [e.body, ui(de, e.condition, {
            body: e.condition
          })]
        })
      }).optimize(t);
      if (!Hi(e, t.parent())) return ui(De, e.body, {
        body: [e.body, ui(de, e.condition, {
          body: e.condition
        })]
      }).optimize(t);
    }

    return e;
  }), ei(Ce, function (e, t) {
    if (!t.option("loops")) return e;

    if (t.option("side_effects") && e.init && (e.init = e.init.drop_side_effect_free(t)), e.condition) {
      var n = e.condition.evaluate(t);
      if (!(n instanceof le)) if (n) e.condition = null;else if (!t.option("dead_code")) {
        var i = e.condition;
        e.condition = li(n, e.condition), e.condition = Ri(e.condition.transform(t), i);
      }

      if (t.option("dead_code") && (n instanceof le && (n = e.condition.tail_node().evaluate(t)), !n)) {
        var r = [];
        return bi(t, e.body, r), e.init instanceof fe ? r.push(e.init) : e.init && r.push(ui(de, e.init, {
          body: e.init
        })), r.push(ui(de, e.condition, {
          body: e.condition
        })), ui(De, e, {
          body: r
        }).optimize(t);
      }
    }

    return function e(t, n) {
      var i = t.body instanceof De ? t.body.body[0] : t.body;

      if (n.option("dead_code") && o(i)) {
        var r = [];
        return t.init instanceof fe ? r.push(t.init) : t.init && r.push(ui(de, t.init, {
          body: t.init
        })), t.condition && r.push(ui(de, t.condition, {
          body: t.condition
        })), bi(n, t.body, r), ui(De, t, {
          body: r
        });
      }

      return i instanceof $e && (o(i.body) ? (t.condition ? t.condition = ui(St, t.condition, {
        left: t.condition,
        operator: "&&",
        right: i.condition.negate(n)
      }) : t.condition = i.condition.negate(n), a(i.alternative)) : o(i.alternative) && (t.condition ? t.condition = ui(St, t.condition, {
        left: t.condition,
        operator: "&&",
        right: i.condition
      }) : t.condition = i.condition, a(i.body))), t;

      function o(e) {
        return e instanceof Ye && n.loopcontrol_target(e) === n.self();
      }

      function a(i) {
        i = _i(i), t.body instanceof De ? (t.body = t.body.clone(), t.body.body = i.concat(t.body.body.slice(1)), t.body = t.body.transform(n)) : t.body = ui(De, t.body, {
          body: i
        }).transform(n), t = e(t, n);
      }
    }(e, t);
  }), ei($e, function (e, t) {
    if (di(e.alternative) && (e.alternative = null), !t.option("conditionals")) return e;
    var n = e.condition.evaluate(t);

    if (!(t.option("dead_code") || n instanceof le)) {
      var i = e.condition;
      e.condition = li(n, i), e.condition = Ri(e.condition.transform(t), i);
    }

    if (t.option("dead_code")) {
      if (n instanceof le && (n = e.condition.tail_node().evaluate(t)), !n) {
        t.warn("Condition always false [{file}:{line},{col}]", e.condition.start);
        var r = [];
        return bi(t, e.body, r), r.push(ui(de, e.condition, {
          body: e.condition
        })), e.alternative && r.push(e.alternative), ui(De, e, {
          body: r
        }).optimize(t);
      }

      if (!(n instanceof le)) return t.warn("Condition always true [{file}:{line},{col}]", e.condition.start), (r = []).push(ui(de, e.condition, {
        body: e.condition
      })), r.push(e.body), e.alternative && bi(t, e.alternative, r), ui(De, e, {
        body: r
      }).optimize(t);
    }

    var o = e.condition.negate(t),
        a = e.condition.print_to_string().length,
        s = o.print_to_string().length,
        u = s < a;

    if (e.alternative && u) {
      u = !1, e.condition = o;
      var c = e.body;
      e.body = e.alternative || ui(ge, e), e.alternative = c;
    }

    if (di(e.body) && di(e.alternative)) return ui(de, e.condition, {
      body: e.condition.clone()
    }).optimize(t);
    if (e.body instanceof de && e.alternative instanceof de) return ui(de, e, {
      body: ui(At, e, {
        condition: e.condition,
        consequent: e.body.body,
        alternative: e.alternative.body
      })
    }).optimize(t);
    if (di(e.alternative) && e.body instanceof de) return a === s && !u && e.condition instanceof St && "||" == e.condition.operator && (u = !0), u ? ui(de, e, {
      body: ui(St, e, {
        operator: "||",
        left: o,
        right: e.body.body
      })
    }).optimize(t) : ui(de, e, {
      body: ui(St, e, {
        operator: "&&",
        left: e.condition,
        right: e.body.body
      })
    }).optimize(t);
    if (e.body instanceof ge && e.alternative instanceof de) return ui(de, e, {
      body: ui(St, e, {
        operator: "||",
        left: e.condition,
        right: e.alternative.body
      })
    }).optimize(t);
    if (e.body instanceof He && e.alternative instanceof He && e.body.TYPE == e.alternative.TYPE) return ui(e.body.CTOR, e, {
      value: ui(At, e, {
        condition: e.condition,
        consequent: e.body.value || ui(pn, e.body),
        alternative: e.alternative.value || ui(pn, e.alternative)
      }).transform(t)
    }).optimize(t);

    if (e.body instanceof $e && !e.body.alternative && !e.alternative && (e = ui($e, e, {
      condition: ui(St, e.condition, {
        operator: "&&",
        left: e.condition,
        right: e.body.condition
      }),
      body: e.body.body,
      alternative: null
    })), Bi(e.body) && e.alternative) {
      var l = e.alternative;
      return e.alternative = null, ui(De, e, {
        body: [e, l]
      }).optimize(t);
    }

    if (Bi(e.alternative)) {
      r = e.body;
      return e.body = e.alternative, e.condition = u ? o : e.condition.negate(t), e.alternative = null, ui(De, e, {
        body: [e, r]
      }).optimize(t);
    }

    return e;
  }), ei(je, function (e, t) {
    if (!t.option("switches")) return e;
    var n,
        i = e.expression.evaluate(t);

    if (!(i instanceof le)) {
      var r = e.expression;
      e.expression = li(i, r), e.expression = Ri(e.expression.transform(t), r);
    }

    if (!t.option("dead_code")) return e;
    i instanceof le && (i = e.expression.tail_node().evaluate(t));

    for (var o, a, s = [], u = [], c = 0, l = e.body.length; c < l && !a; c++) {
      if ((n = e.body[c]) instanceof Je) o ? D(n, u[u.length - 1]) : o = n;else if (!(i instanceof le)) {
        if (!((E = n.expression.evaluate(t)) instanceof le) && E !== i) {
          D(n, u[u.length - 1]);
          continue;
        }

        if (E instanceof le && (E = n.expression.tail_node().evaluate(t)), E === i && (a = n, o)) {
          var f = u.indexOf(o);
          u.splice(f, 1), D(o, u[f - 1]), o = null;
        }
      }

      if (Bi(n)) {
        var p = u[u.length - 1];
        Bi(p) && p.body.length == n.body.length && ui(De, p, p).equivalent_to(ui(De, n, n)) && (p.body = []);
      }

      u.push(n);
    }

    for (; c < l;) {
      D(e.body[c++], u[u.length - 1]);
    }

    for (u.length > 0 && (u[0].body = s.concat(u[0].body)), e.body = u; n = u[u.length - 1];) {
      var _ = n.body[n.body.length - 1];
      if (_ instanceof Ye && t.loopcontrol_target(_) === e && n.body.pop(), n.body.length || n instanceof Qe && (o || n.expression.has_side_effects(t))) break;
      u.pop() === o && (o = null);
    }

    if (0 == u.length) return ui(De, e, {
      body: s.concat(ui(de, e.expression, {
        body: e.expression
      }))
    }).optimize(t);

    if (1 == u.length && (u[0] === a || u[0] === o)) {
      var d = !1,
          m = new Sn(function (t) {
        if (d || t instanceof xe || t instanceof de) return !0;
        t instanceof Ye && m.loopcontrol_target(t) === e && (d = !0);
      });

      if (e.walk(m), !d) {
        var E,
            h = u[0].body.slice();
        return (E = u[0].expression) && h.unshift(ui(de, E, {
          body: E
        })), h.unshift(ui(de, e.expression, {
          body: e.expression
        })), ui(De, e, {
          body: h
        }).optimize(t);
      }
    }

    return e;

    function D(e, n) {
      n && !Bi(n) ? n.body = n.body.concat(e.body) : bi(t, e, s);
    }
  }), ei(et, function (e, t) {
    if (Ti(e.body, t), e.bcatch && e.bfinally && e.bfinally.body.every(di) && (e.bfinally = null), t.option("dead_code") && e.body.every(di)) {
      var n = [];
      return e.bcatch && bi(t, e.bcatch, n), e.bfinally && n.push.apply(n, _toConsumableArray(e.bfinally.body)), ui(De, e, {
        body: n
      }).optimize(t);
    }

    return e;
  }), it.DEFMETHOD("remove_initializers", function () {
    var e = [];
    this.definitions.forEach(function (t) {
      t.name instanceof Lt ? (t.value = null, e.push(t)) : t.name.walk(new Sn(function (n) {
        n instanceof Lt && e.push(ui(lt, t, {
          name: n,
          value: null
        }));
      }));
    }), this.definitions = e;
  }), it.DEFMETHOD("to_assignments", function (e) {
    var t = e.option("reduce_vars"),
        n = this.definitions.reduce(function (e, n) {
      if (!n.value || n.name instanceof Pe) {
        if (n.value) {
          var i = ui(lt, n, {
            name: n.name,
            value: n.value
          }),
              r = ui(rt, n, {
            definitions: [i]
          });
          e.push(r);
        }
      } else {
        var o = ui(Zt, n.name, n.name);
        e.push(ui(vt, n, {
          operator: "=",
          left: o,
          right: n.value
        })), t && (o.definition().fixed = !1);
      }

      return (n = n.name.definition()).eliminated++, n.replaced--, e;
    }, []);
    return 0 == n.length ? null : ci(this, n);
  }), ei(it, function (e, t) {
    return 0 == e.definitions.length ? ui(ge, e) : e;
  }), ei(ut, function (e, t) {
    return e;
  }), ei(ft, function (e, t) {
    var n = e.expression,
        i = n;
    Qi(e, t, e.args);
    var r = e.args.every(function (e) {
      return !(e instanceof Ne);
    });

    if (t.option("reduce_vars") && i instanceof Zt && !T(e, bn)) {
      var _e14 = i.fixed_value();

      Xi(_e14, t) || (i = _e14);
    }

    var o = i instanceof xe;

    if (t.option("unused") && r && o && !i.uses_arguments && !i.pinned()) {
      for (var a = 0, s = 0, u = 0, c = e.args.length; u < c; u++) {
        if (i.argnames[u] instanceof Ne) {
          if (jn(i.argnames[u].expression, Gn)) for (; u < c;) {
            (D = e.args[u++].drop_side_effect_free(t)) && (e.args[a++] = D);
          } else for (; u < c;) {
            e.args[a++] = e.args[u++];
          }
          s = a;
          break;
        }

        var l = u >= i.argnames.length;

        if (l || jn(i.argnames[u], Gn)) {
          if (D = e.args[u].drop_side_effect_free(t)) e.args[a++] = D;else if (!l) {
            e.args[a++] = ui(an, e.args[u], {
              value: 0
            });
            continue;
          }
        } else e.args[a++] = e.args[u];

        s = a;
      }

      e.args.length = s;
    }

    if (t.option("unsafe")) if (Di(n)) switch (n.name) {
      case "Array":
        if (1 != e.args.length) return ui(bt, e, {
          elements: e.args
        }).optimize(t);

        if (e.args[0] instanceof an && e.args[0].value <= 11) {
          var _t11 = [];

          for (var _n7 = 0; _n7 < e.args[0].value; _n7++) {
            _t11.push(new _n());
          }

          return new bt({
            elements: _t11
          });
        }

        break;

      case "Object":
        if (0 == e.args.length) return ui(yt, e, {
          properties: []
        });
        break;

      case "String":
        if (0 == e.args.length) return ui(on, e, {
          value: ""
        });
        if (e.args.length <= 1) return ui(St, e, {
          left: e.args[0],
          operator: "+",
          right: ui(on, e, {
            value: ""
          })
        }).optimize(t);
        break;

      case "Number":
        if (0 == e.args.length) return ui(an, e, {
          value: 0
        });
        if (1 == e.args.length && t.option("unsafe_math")) return ui(Dt, e, {
          expression: e.args[0],
          operator: "+"
        }).optimize(t);
        break;

      case "Boolean":
        if (0 == e.args.length) return ui(En, e);
        if (1 == e.args.length) return ui(Dt, e, {
          expression: ui(Dt, e, {
            expression: e.args[0],
            operator: "!"
          }),
          operator: "!"
        }).optimize(t);
        break;

      case "RegExp":
        var f = [];

        if (e.args.length >= 1 && e.args.length <= 2 && e.args.every(function (e) {
          var n = e.evaluate(t);
          return f.push(n), e !== n;
        })) {
          var _n8 = f[0],
              _i7 = f[1],
              _r4 = ui(un, e, {
            value: {
              source: _n8,
              flags: _i7
            }
          });

          if (_r4._eval(t) !== _r4) return _r4;
          t.warn("Error converting {expr} [{file}:{line},{col}]", {
            expr: e.print_to_string(),
            file: e.start.file,
            line: e.start.line,
            col: e.start.col
          });
        }

    } else if (n instanceof mt) switch (n.property) {
      case "toString":
        if (0 == e.args.length && !n.expression.may_throw_on_access(t)) return ui(St, e, {
          left: ui(on, e, {
            value: ""
          }),
          operator: "+",
          right: n.expression
        }).optimize(t);
        break;

      case "join":
        if (n.expression instanceof bt) e: {
          var p;

          if (!(e.args.length > 0 && (p = e.args[0].evaluate(t)) === e.args[0])) {
            var _,
                d = [],
                m = [];

            for (u = 0, c = n.expression.elements.length; u < c; u++) {
              var E = n.expression.elements[u];
              if (E instanceof Ne) break e;
              var h = E.evaluate(t);
              h !== E ? m.push(h) : (m.length > 0 && (d.push(ui(on, e, {
                value: m.join(p)
              })), m.length = 0), d.push(E));
            }

            return m.length > 0 && d.push(ui(on, e, {
              value: m.join(p)
            })), 0 == d.length ? ui(on, e, {
              value: ""
            }) : 1 == d.length ? d[0].is_string(t) ? d[0] : ui(St, d[0], {
              operator: "+",
              left: ui(on, e, {
                value: ""
              }),
              right: d[0]
            }) : "" == p ? (_ = d[0].is_string(t) || d[1].is_string(t) ? d.shift() : ui(on, e, {
              value: ""
            }), d.reduce(function (e, t) {
              return ui(St, t, {
                operator: "+",
                left: e,
                right: t
              });
            }, _).optimize(t)) : ((D = e.clone()).expression = D.expression.clone(), D.expression.expression = D.expression.expression.clone(), D.expression.expression.elements = d, Ni(t, e, D));
            var D;
          }
        }
        break;

      case "charAt":
        if (n.expression.is_string(t)) {
          var g = e.args[0],
              S = g ? g.evaluate(t) : 0;
          if (S !== g) return ui(Et, n, {
            expression: n.expression,
            property: li(0 | S, g || n)
          }).optimize(t);
        }

        break;

      case "apply":
        if (2 == e.args.length && e.args[1] instanceof bt) return (w = e.args[1].elements.slice()).unshift(e.args[0]), ui(ft, e, {
          expression: ui(mt, n, {
            expression: n.expression,
            property: "call"
          }),
          args: w
        }).optimize(t);
        break;

      case "call":
        var A = n.expression;
        if (A instanceof Zt && (A = A.fixed_value()), A instanceof xe && !A.contains_this()) return (e.args.length ? ci(this, [e.args[0], ui(ft, e, {
          expression: n.expression,
          args: e.args.slice(1)
        })]) : ui(ft, e, {
          expression: n.expression,
          args: []
        })).optimize(t);
    }

    if (t.option("unsafe_Function") && Di(n) && "Function" == n.name) {
      if (0 == e.args.length) return ui(Ie, e, {
        argnames: [],
        body: []
      }).optimize(t);
      if (e.args.every(function (e) {
        return e instanceof on;
      })) try {
        var v = se(O = "n(function(" + e.args.slice(0, -1).map(function (e) {
          return e.value;
        }).join(",") + "){" + e.args[e.args.length - 1].value + "})"),
            b = {
          ie8: t.option("ie8")
        };
        v.figure_out_scope(b);
        var y,
            C = new Qn(t.options);
        (v = v.transform(C)).figure_out_scope(b), Un.reset(), v.compute_char_frequency(b), v.mangle_names(b), v.walk(new Sn(function (e) {
          return !!y || (ii(e) ? (y = e, !0) : void 0);
        })), y.body instanceof le && (y.body = [ui(Xe, y.body, {
          value: y.body
        })]);
        var O = kn();
        return De.prototype._codegen.call(y, y, O), e.args = [ui(on, e, {
          value: y.argnames.map(function (e) {
            return e.print_to_string();
          }).join(",")
        }), ui(on, e.args[e.args.length - 1], {
          value: O.get().replace(/^{|}$/g, "")
        })], e;
      } catch (n) {
        if (!(n instanceof Z)) throw n;
        t.warn("Error parsing code passed to new Function [{file}:{line},{col}]", e.args[e.args.length - 1].start), t.warn(n.toString());
      }
    }

    var F = o && i.body;
    F instanceof le ? F = ui(Xe, F, {
      value: F
    }) : F && (F = F[0]);
    var M = o && !i.is_generator && !i.async,
        R = M && t.option("inline") && !e.is_expr_pure(t);

    if (R && F instanceof Xe) {
      var _n9 = F.value;

      if (!_n9 || _n9.is_constant_expression()) {
        _n9 = _n9 ? _n9.clone(!0) : ui(pn, e);
        var w = e.args.concat(_n9);
        return ci(e, w).optimize(t);
      }
    }

    if (R) {
      var N,
          x,
          k = -1;

      var _o, _a;

      if (r && !i.uses_arguments && !i.pinned() && !(t.parent() instanceof wt) && !(i.name && i instanceof Ie) && (!(t.find_parent(xe) instanceof Le) || 0 == i.argnames.length && (i.body instanceof le || 1 == i.body.length)) && (_a = function (e) {
        var n = i.body instanceof le ? [i.body] : i.body,
            r = n.length;
        if (t.option("inline") < 3) return 1 == r && L(e);
        e = null;

        for (var o = 0; o < r; o++) {
          var a = n[o];

          if (a instanceof rt) {
            if (e && !a.definitions.every(function (e) {
              return !e.value;
            })) return !1;
          } else {
            if (e) return !1;
            a instanceof ge || (e = a);
          }
        }

        return L(e);
      }(F)) && (n === i || T(e, Tn) || t.option("unused") && 1 == (_o = n.definition()).references.length && !Wi(t, _o) && i.is_constant_expression(n.scope)) && !T(e, vn | bn) && !i.contains_this() && function () {
        var n = new Set();

        do {
          if (!(N = t.parent(++k)).is_block_scope() || t.parent(k - 1) instanceof Re || N.block_scope && N.block_scope.variables.forEach(function (e) {
            n.add(e.name);
          }), N instanceof tt) N.argname && n.add(N.argname.name);else if (N instanceof ve) x = [];else if (N instanceof Zt && N.fixed_value() instanceof Re) return !1;
        } while (!(N instanceof Re) || N instanceof Le);

        var r = !(N instanceof we) || t.toplevel.vars,
            o = t.option("inline");
        return !!function (e, t) {
          for (var n = i.body.length, r = 0; r < n; r++) {
            var o = i.body[r];

            if (o instanceof rt) {
              if (!t) return !1;

              for (var a = o.definitions.length; --a >= 0;) {
                var s = o.definitions[a].name;
                if (s instanceof Pe || e.has(s.name) || Ai.has(s.name) || N.var_names().has(s.name)) return !1;
                x && x.push(s.definition());
              }
            }
          }

          return !0;
        }(n, o >= 3 && r) && !!function (e, t) {
          for (var n = 0, r = i.argnames.length; n < r; n++) {
            var o = i.argnames[n];

            if (o instanceof Tt) {
              if (jn(o.left, Gn)) continue;
              return !1;
            }

            if (o instanceof Pe) return !1;

            if (o instanceof Ne) {
              if (jn(o.expression, Gn)) continue;
              return !1;
            }

            if (!jn(o, Gn)) {
              if (!t || e.has(o.name) || Ai.has(o.name) || N.var_names().has(o.name)) return !1;
              x && x.push(o.definition());
            }
          }

          return !0;
        }(n, o >= 2 && r) && !!function () {
          var t = new Set(),
              n = new Sn(function (e) {
            if (e instanceof Re) {
              var n = new Set();
              return e.enclosed.forEach(function (e) {
                n.add(e.name);
              }), e.variables.forEach(function (e) {
                n.delete(e);
              }), n.forEach(function (e) {
                t.add(e);
              }), !0;
            }

            return !1;
          });
          if (e.args.forEach(function (e) {
            e.walk(n);
          }), 0 == t.size) return !0;

          for (var r = 0, o = i.argnames.length; r < o; r++) {
            var a = i.argnames[r];
            if (!(a instanceof Tt && jn(a.left, Gn)) && !(a instanceof Ne && jn(a.expression, Gn)) && !jn(a, Gn) && t.has(a.name)) return !1;
          }

          for (r = 0, o = i.body.length; r < o; r++) {
            var s = i.body[r];
            if (s instanceof rt) for (var u = s.definitions.length; --u >= 0;) {
              var c = s.definitions[u].name;
              if (c instanceof Pe || t.has(c.name)) return !1;
            }
          }

          return !0;
        }() && (!x || 0 == x.length || !qi(i, x));
      }() && !(N instanceof wt)) return Zn(i, Wn), ai(t, !0).add_child_scope(i), ci(e, function (n) {
        var r = [],
            o = [];
        (function (t, n) {
          for (var r = i.argnames.length, o = e.args.length; --o >= r;) {
            n.push(e.args[o]);
          }

          for (o = r; --o >= 0;) {
            var a = i.argnames[o],
                s = e.args[o];
            if (jn(a, Gn) || !a.name || N.var_names().has(a.name)) s && n.push(s);else {
              var u = ui(Vt, a, a);
              a.definition().orig.push(u), !s && x && (s = ui(pn, e)), V(t, n, u, s);
            }
          }

          t.reverse(), n.reverse();
        })(r, o), function (e, t) {
          for (var n = t.length, r = 0, o = i.body.length; r < o; r++) {
            var a = i.body[r];
            if (a instanceof rt) for (var s = 0, u = a.definitions.length; s < u; s++) {
              var c = a.definitions[s],
                  l = c.name;

              if (V(e, t, l, c.value), x && i.argnames.every(function (e) {
                return e.name != l.name;
              })) {
                var f = i.variables.get(l.name),
                    p = ui(Zt, l, l);
                f.references.push(p), t.splice(n++, 0, ui(vt, c, {
                  operator: "=",
                  left: p,
                  right: ui(pn, l)
                }));
              }
            }
          }
        }(r, o), o.push(n), r.length && (u = N.body.indexOf(t.parent(k - 1)) + 1, N.body.splice(u, 0, ui(rt, i, {
          definitions: r
        })));
        return o.map(function (e) {
          return e.clone(!0);
        });
      }(_a)).optimize(t);
    }

    if (M && t.option("side_effects") && !(i.body instanceof le) && i.body.every(di)) {
      w = e.args.concat(ui(pn, e));
      return ci(e, w).optimize(t);
    }

    if (t.option("negate_iife") && t.parent() instanceof de && hi(e)) return e.negate(t, !0);
    var I = e.evaluate(t);
    return I !== e ? (I = li(I, e).optimize(t), Ni(t, I, e)) : e;

    function L(t) {
      return t ? t instanceof Xe ? t.value ? t.value.clone(!0) : ui(pn, e) : t instanceof de ? ui(Dt, t, {
        operator: "void",
        expression: t.body.clone(!0)
      }) : void 0 : ui(pn, e);
    }

    function V(t, n, i, r) {
      var o = i.definition();
      N.variables.set(i.name, o), N.enclosed.push(o), N.var_names().has(i.name) || (N.add_var_name(i.name), t.push(ui(lt, i, {
        name: i,
        value: null
      })));
      var a = ui(Zt, i, i);
      o.references.push(a), r && n.push(ui(vt, e, {
        operator: "=",
        left: a,
        right: r.clone()
      }));
    }
  }), ei(pt, function (e, t) {
    return t.option("unsafe") && Di(e.expression) && ["Object", "RegExp", "Function", "Error", "Array"].includes(e.expression.name) ? ui(ft, e, e).transform(t) : e;
  }), ei(_t, function (e, t) {
    if (!t.option("side_effects")) return e;
    var n,
        i,
        r = [];
    n = Fn(t), i = e.expressions.length - 1, e.expressions.forEach(function (e, o) {
      o < i && (e = e.drop_side_effect_free(t, n)), e && (pi(r, e), n = !1);
    });
    var o = r.length - 1;
    return function () {
      for (; o > 0 && Ci(r[o], t);) {
        o--;
      }

      o < r.length - 1 && (r[o] = ui(Dt, e, {
        operator: "void",
        expression: r[o]
      }), r.length = o + 1);
    }(), 0 == o ? ((e = fi(t.parent(), t.self(), r[0])) instanceof _t || (e = e.optimize(t)), e) : (e.expressions = r, e);
  }), ht.DEFMETHOD("lift_sequences", function (e) {
    if (e.option("sequences") && this.expression instanceof _t) {
      var t = this.expression.expressions.slice(),
          n = this.clone();
      return n.expression = t.pop(), t.push(n), ci(this, t).optimize(e);
    }

    return this;
  }), ei(gt, function (e, t) {
    return e.lift_sequences(t);
  }), ei(Dt, function (e, t) {
    var n = e.expression;

    if ("delete" == e.operator && !(n instanceof Zt || n instanceof dt || vi(n))) {
      if (n instanceof _t) {
        var _i8 = n.expressions.slice();

        return _i8.push(ui(hn, e)), ci(e, _i8).optimize(t);
      }

      return ci(e, [n, ui(hn, e)]).optimize(t);
    }

    var i = e.lift_sequences(t);
    if (i !== e) return i;
    if (t.option("side_effects") && "void" == e.operator) return (n = n.drop_side_effect_free(t)) ? (e.expression = n, e) : ui(pn, e).optimize(t);
    if (t.in_boolean_context()) switch (e.operator) {
      case "!":
        if (n instanceof Dt && "!" == n.operator) return n.expression;
        n instanceof St && (e = Ni(t, e, n.negate(t, Fn(t))));
        break;

      case "typeof":
        return t.warn("Boolean expression always true [{file}:{line},{col}]", e.start), (n instanceof Zt ? ui(hn, e) : ci(e, [n, ui(hn, e)])).optimize(t);
    }
    if ("-" == e.operator && n instanceof dn && (n = n.transform(t)), n instanceof St && ("+" == e.operator || "-" == e.operator) && ("*" == n.operator || "/" == n.operator || "%" == n.operator)) return ui(St, e, {
      operator: n.operator,
      left: ui(Dt, n.left, {
        operator: e.operator,
        expression: n.left
      }),
      right: n.right
    });

    if ("-" != e.operator || !(n instanceof an || n instanceof dn || n instanceof sn)) {
      var r = e.evaluate(t);
      if (r !== e) return Ni(t, r = li(r, e).optimize(t), e);
    }

    return e;
  }), St.DEFMETHOD("lift_sequences", function (e) {
    if (e.option("sequences")) {
      if (this.left instanceof _t) {
        var t = this.left.expressions.slice();
        return (n = this.clone()).left = t.pop(), t.push(n), ci(this, t).optimize(e);
      }

      if (this.right instanceof _t && !this.left.has_side_effects(e)) {
        for (var n, i = "=" == this.operator && this.left instanceof Zt, r = (t = this.right.expressions).length - 1, o = 0; o < r && (i || !t[o].has_side_effects(e)); o++) {
          ;
        }

        if (o == r) return t = t.slice(), (n = this.clone()).right = t.pop(), t.push(n), ci(this, t).optimize(e);
        if (o > 0) return (n = this.clone()).right = ci(this.right, t.slice(o)), (t = t.slice(0, o)).push(n), ci(this, t).optimize(e);
      }
    }

    return this;
  });
  var zi = E("== === != !== * & | ^");

  function Wi(e, t) {
    for (var n, i = 0; n = e.parent(i); i++) {
      if (n instanceof xe) {
        var r = n.name;
        if (r && r.definition() === t) break;
      }
    }

    return n;
  }

  function Yi(e, t) {
    return e instanceof Zt || e.TYPE === t.TYPE;
  }

  function qi(e, t) {
    var n = !1,
        r = new Sn(function (e) {
      return !!n || (e instanceof Zt && i(e.definition(), t) ? n = !0 : void 0);
    }),
        o = new Sn(function (t) {
      if (n) return !0;

      if (t instanceof Re && t !== e) {
        var i = o.parent();
        if (i instanceof ft && i.expression === t) return;
        return t.walk(r), !0;
      }
    });
    return e.walk(o), n;
  }

  ei(St, function (e, t) {
    function n() {
      return e.left.is_constant() || e.right.is_constant() || !e.left.has_side_effects(t) && !e.right.has_side_effects(t);
    }

    function i(t) {
      if (n()) {
        t && (e.operator = t);
        var i = e.left;
        e.left = e.right, e.right = i;
      }
    }

    if (zi.has(e.operator) && e.right.is_constant() && !e.left.is_constant() && (e.left instanceof St && oe[e.left.operator] >= oe[e.operator] || i()), e = e.lift_sequences(t), t.option("comparisons")) switch (e.operator) {
      case "===":
      case "!==":
        var r = !0;
        (e.left.is_string(t) && e.right.is_string(t) || e.left.is_number(t) && e.right.is_number(t) || e.left.is_boolean() && e.right.is_boolean() || e.left.equivalent_to(e.right)) && (e.operator = e.operator.substr(0, 2));

      case "==":
      case "!=":
        if (!r && Ci(e.left, t)) e.left = ui(ln, e.left);else if (t.option("typeofs") && e.left instanceof on && "undefined" == e.left.value && e.right instanceof Dt && "typeof" == e.right.operator) {
          var o = e.right.expression;
          (o instanceof Zt ? !o.is_declared(t) : o instanceof dt && t.option("ie8")) || (e.right = o, e.left = ui(pn, e.left).optimize(t), 2 == e.operator.length && (e.operator += "="));
        } else if (e.left instanceof Zt && e.right instanceof Zt && e.left.definition() === e.right.definition() && ((u = e.left.fixed_value()) instanceof bt || u instanceof xe || u instanceof yt || u instanceof wt)) return ui("=" == e.operator[0] ? hn : En, e);
        break;

      case "&&":
      case "||":
        var a = e.left;

        if (a.operator == e.operator && (a = a.right), a instanceof St && a.operator == ("&&" == e.operator ? "!==" : "===") && e.right instanceof St && a.operator == e.right.operator && (Ci(a.left, t) && e.right.left instanceof ln || a.left instanceof ln && Ci(e.right.left, t)) && !a.right.has_side_effects(t) && a.right.equivalent_to(e.right.right)) {
          var s = ui(St, e, {
            operator: a.operator.slice(0, -1),
            left: ui(ln, e),
            right: a.right
          });
          return a !== e.left && (s = ui(St, e, {
            operator: e.operator,
            left: e.left.left,
            right: s
          })), s;
        }

    }
    var u;

    if ("+" == e.operator && t.in_boolean_context()) {
      var c = e.left.evaluate(t),
          l = e.right.evaluate(t);
      if (c && "string" == typeof c) return t.warn("+ in boolean context always true [{file}:{line},{col}]", e.start), ci(e, [e.right, ui(hn, e)]).optimize(t);
      if (l && "string" == typeof l) return t.warn("+ in boolean context always true [{file}:{line},{col}]", e.start), ci(e, [e.left, ui(hn, e)]).optimize(t);
    }

    if (t.option("comparisons") && e.is_boolean()) {
      if (!(t.parent() instanceof St) || t.parent() instanceof vt) {
        var f = ui(Dt, e, {
          operator: "!",
          expression: e.negate(t, Fn(t))
        });
        e = Ni(t, e, f);
      }

      if (t.option("unsafe_comps")) switch (e.operator) {
        case "<":
          i(">");
          break;

        case "<=":
          i(">=");
      }
    }

    if ("+" == e.operator) {
      if (e.right instanceof on && "" == e.right.getValue() && e.left.is_string(t)) return e.left;
      if (e.left instanceof on && "" == e.left.getValue() && e.right.is_string(t)) return e.right;
      if (e.left instanceof St && "+" == e.left.operator && e.left.left instanceof on && "" == e.left.left.getValue() && e.right.is_string(t)) return e.left = e.left.right, e.transform(t);
    }

    if (t.option("evaluate")) {
      switch (e.operator) {
        case "&&":
          if (!(c = !!jn(e.left, 2) || !jn(e.left, 4) && e.left.evaluate(t))) return t.warn("Condition left of && always false [{file}:{line},{col}]", e.start), fi(t.parent(), t.self(), e.left).optimize(t);
          if (!(c instanceof le)) return t.warn("Condition left of && always true [{file}:{line},{col}]", e.start), ci(e, [e.left, e.right]).optimize(t);

          if (l = e.right.evaluate(t)) {
            if (!(l instanceof le)) {
              if ("&&" == (p = t.parent()).operator && p.left === t.self() || t.in_boolean_context()) return t.warn("Dropping side-effect-free && [{file}:{line},{col}]", e.start), e.left.optimize(t);
            }
          } else {
            if (t.in_boolean_context()) return t.warn("Boolean && always false [{file}:{line},{col}]", e.start), ci(e, [e.left, ui(En, e)]).optimize(t);
            Zn(e, 4);
          }

          if ("||" == e.left.operator) if (!(_ = e.left.right.evaluate(t))) return ui(At, e, {
            condition: e.left.left,
            consequent: e.right,
            alternative: e.left.right
          }).optimize(t);
          break;

        case "||":
          var p, _;

          if (!(c = !!jn(e.left, 2) || !jn(e.left, 4) && e.left.evaluate(t))) return t.warn("Condition left of || always false [{file}:{line},{col}]", e.start), ci(e, [e.left, e.right]).optimize(t);
          if (!(c instanceof le)) return t.warn("Condition left of || always true [{file}:{line},{col}]", e.start), fi(t.parent(), t.self(), e.left).optimize(t);

          if (l = e.right.evaluate(t)) {
            if (!(l instanceof le)) {
              if (t.in_boolean_context()) return t.warn("Boolean || always true [{file}:{line},{col}]", e.start), ci(e, [e.left, ui(hn, e)]).optimize(t);
              Zn(e, 2);
            }
          } else if ("||" == (p = t.parent()).operator && p.left === t.self() || t.in_boolean_context()) return t.warn("Dropping side-effect-free || [{file}:{line},{col}]", e.start), e.left.optimize(t);

          if ("&&" == e.left.operator) if ((_ = e.left.right.evaluate(t)) && !(_ instanceof le)) return ui(At, e, {
            condition: e.left.left,
            consequent: e.left.right,
            alternative: e.right
          }).optimize(t);
      }

      var d = !0;

      switch (e.operator) {
        case "+":
          if (e.left instanceof rn && e.right instanceof St && "+" == e.right.operator && e.right.left instanceof rn && e.right.is_string(t) && (e = ui(St, e, {
            operator: "+",
            left: ui(on, e.left, {
              value: "" + e.left.getValue() + e.right.left.getValue(),
              start: e.left.start,
              end: e.right.left.end
            }),
            right: e.right.right
          })), e.right instanceof rn && e.left instanceof St && "+" == e.left.operator && e.left.right instanceof rn && e.left.is_string(t) && (e = ui(St, e, {
            operator: "+",
            left: e.left.left,
            right: ui(on, e.right, {
              value: "" + e.left.right.getValue() + e.right.getValue(),
              start: e.left.right.start,
              end: e.right.end
            })
          })), e.left instanceof St && "+" == e.left.operator && e.left.is_string(t) && e.left.right instanceof rn && e.right instanceof St && "+" == e.right.operator && e.right.left instanceof rn && e.right.is_string(t) && (e = ui(St, e, {
            operator: "+",
            left: ui(St, e.left, {
              operator: "+",
              left: e.left.left,
              right: ui(on, e.left.right, {
                value: "" + e.left.right.getValue() + e.right.left.getValue(),
                start: e.left.right.start,
                end: e.right.left.end
              })
            }),
            right: e.right.right
          })), e.right instanceof Dt && "-" == e.right.operator && e.left.is_number(t)) {
            e = ui(St, e, {
              operator: "-",
              left: e.left,
              right: e.right.expression
            });
            break;
          }

          if (e.left instanceof Dt && "-" == e.left.operator && n() && e.right.is_number(t)) {
            e = ui(St, e, {
              operator: "-",
              left: e.right,
              right: e.left.expression
            });
            break;
          }

        case "*":
          d = t.option("unsafe_math");

        case "&":
        case "|":
        case "^":
          if (e.left.is_number(t) && e.right.is_number(t) && n() && !(e.left instanceof St && e.left.operator != e.operator && oe[e.left.operator] >= oe[e.operator])) {
            var m = ui(St, e, {
              operator: e.operator,
              left: e.right,
              right: e.left
            });
            e = e.right instanceof rn && !(e.left instanceof rn) ? Ni(t, m, e) : Ni(t, e, m);
          }

          d && e.is_number(t) && (e.right instanceof St && e.right.operator == e.operator && (e = ui(St, e, {
            operator: e.operator,
            left: ui(St, e.left, {
              operator: e.operator,
              left: e.left,
              right: e.right.left,
              start: e.left.start,
              end: e.right.left.end
            }),
            right: e.right.right
          })), e.right instanceof rn && e.left instanceof St && e.left.operator == e.operator && (e.left.left instanceof rn ? e = ui(St, e, {
            operator: e.operator,
            left: ui(St, e.left, {
              operator: e.operator,
              left: e.left.left,
              right: e.right,
              start: e.left.left.start,
              end: e.right.end
            }),
            right: e.left.right
          }) : e.left.right instanceof rn && (e = ui(St, e, {
            operator: e.operator,
            left: ui(St, e.left, {
              operator: e.operator,
              left: e.left.right,
              right: e.right,
              start: e.left.right.start,
              end: e.right.end
            }),
            right: e.left.left
          }))), e.left instanceof St && e.left.operator == e.operator && e.left.right instanceof rn && e.right instanceof St && e.right.operator == e.operator && e.right.left instanceof rn && (e = ui(St, e, {
            operator: e.operator,
            left: ui(St, e.left, {
              operator: e.operator,
              left: ui(St, e.left.left, {
                operator: e.operator,
                left: e.left.right,
                right: e.right.left,
                start: e.left.right.start,
                end: e.right.left.end
              }),
              right: e.left.left
            }),
            right: e.right.right
          })));
      }
    }

    if (e.right instanceof St && e.right.operator == e.operator && (Oi.has(e.operator) || "+" == e.operator && (e.right.left.is_string(t) || e.left.is_string(t) && e.right.right.is_string(t)))) return e.left = ui(St, e.left, {
      operator: e.operator,
      left: e.left,
      right: e.right.left
    }), e.right = e.right.right, e.transform(t);
    var E = e.evaluate(t);
    return E !== e ? (E = li(E, e).optimize(t), Ni(t, E, e)) : e;
  }), ei(Jt, function (e, t) {
    return e;
  }), ei(Zt, function (e, t) {
    if (!t.option("ie8") && Di(e) && (!e.scope.uses_with || !t.find_parent(Me))) switch (e.name) {
      case "undefined":
        return ui(pn, e).optimize(t);

      case "NaN":
        return ui(fn, e).optimize(t);

      case "Infinity":
        return ui(dn, e).optimize(t);
    }
    var n,
        i = t.parent();

    if (t.option("reduce_vars") && Mi(e, i) !== e) {
      var _p = e.definition();

      if (t.top_retain && _p.global && t.top_retain(_p)) return _p.fixed = !1, _p.should_replace = !1, _p.single_use = !1, e;
      var r = e.fixed_value(),
          o = _p.single_use && !(i instanceof ft && i.is_expr_pure(t));
      if (o && (r instanceof xe || r instanceof wt)) if (Xi(r, t)) o = !1;else if (_p.scope !== e.scope && (1 == _p.escaped || jn(r, Xn) || function (e) {
        for (var t, n = 0; t = e.parent(n++);) {
          if (t instanceof fe) return !1;
          if (t instanceof bt || t instanceof Ot || t instanceof yt) return !0;
        }

        return !1;
      }(t))) o = !1;else if (Wi(t, _p)) o = !1;else if ((_p.scope !== e.scope || _p.orig[0] instanceof Ut) && "f" == (o = r.is_constant_expression(e.scope))) {
        var a = e.scope;

        do {
          (a instanceof Ve || ii(a)) && Zn(a, Xn);
        } while (a = a.parent_scope);
      }

      if (o && r instanceof xe && (o = _p.scope === e.scope || i instanceof ft && i.expression === e), o && r instanceof wt && r.extends && (o = !r.extends.may_throw(t) && (!(r.extends instanceof ft) || r.extends.is_expr_pure(t))), o && r) {
        if (r instanceof Nt && (r = ui(xt, r, r)), r instanceof Ve && (Zn(r, Wn), r = ui(Ie, r, r)), _p.recursive_refs > 0 && r.name instanceof Gt) {
          var _e15 = r.name.definition();

          var _t12 = r.variables.get(r.name.name),
              _n10 = _t12 && _t12.orig[0];

          _n10 instanceof Xt || ((_n10 = ui(Xt, r.name, r.name)).scope = r, r.name = _n10, _t12 = r.def_function(_n10)), r.walk(new Sn(function (n) {
            n instanceof Zt && n.definition() === _e15 && (n.thedef = _t12, _t12.references.push(n));
          }));
        }

        return (r instanceof xe || r instanceof wt) && ai(t, !0).add_child_scope(r), r.optimize(t);
      }

      if (r && void 0 === _p.should_replace) {
        var _e16;

        if (r instanceof tn) _p.orig[0] instanceof Ut || !_p.references.every(function (e) {
          return _p.scope === e.scope;
        }) || (_e16 = r);else {
          var s = r.evaluate(t);
          s === r || !t.option("unsafe_regexp") && s instanceof RegExp || (_e16 = li(s, r));
        }

        if (_e16) {
          var u,
              c = _e16.optimize(t).print_to_string().length;

          r.walk(new Sn(function (e) {
            if (e instanceof Zt && (n = !0), n) return !0;
          })), n ? u = function u() {
            var n = _e16.optimize(t);

            return n === _e16 ? n.clone(!0) : n;
          } : (c = Math.min(c, r.print_to_string().length), u = function u() {
            var n = Ri(_e16.optimize(t), r);
            return n === _e16 || n === r ? n.clone(!0) : n;
          });
          var l = _p.name.length,
              f = 0;
          t.option("unused") && !t.exposed(_p) && (f = (l + 2 + c) / (_p.references.length - _p.assignments)), _p.should_replace = c <= l + f && u;
        } else _p.should_replace = !1;
      }

      if (_p.should_replace) return _p.should_replace();
    }

    return e;
  }), ei(pn, function (e, t) {
    if (t.option("unsafe_undefined")) {
      var n = si(t, "undefined");

      if (n) {
        var i = ui(Zt, e, {
          name: "undefined",
          scope: n.scope,
          thedef: n
        });
        return Zn(i, Hn), i;
      }
    }

    var r = Mi(t.self(), t.parent());
    return r && Yi(r, e) ? e : ui(Dt, e, {
      operator: "void",
      expression: ui(an, e, {
        value: 0
      })
    });
  }), ei(dn, function (e, t) {
    var n = Mi(t.self(), t.parent());
    return n && Yi(n, e) ? e : !t.option("keep_infinity") || n && !Yi(n, e) || si(t, "Infinity") ? ui(St, e, {
      operator: "/",
      left: ui(an, e, {
        value: 1
      }),
      right: ui(an, e, {
        value: 0
      })
    }) : e;
  }), ei(fn, function (e, t) {
    var n = Mi(t.self(), t.parent());
    return n && !Yi(n, e) || si(t, "NaN") ? ui(St, e, {
      operator: "/",
      left: ui(an, e, {
        value: 0
      }),
      right: ui(an, e, {
        value: 0
      })
    }) : e;
  });
  var $i = E("+ - / * % >> << >>> | ^ &"),
      ji = E("* | ^ &");

  function Zi(e, t) {
    return e instanceof Zt && (e = e.fixed_value()), !!e && (!(e instanceof xe || e instanceof wt) || t.parent() instanceof pt || !e.contains_this());
  }

  function Ji(e, t) {
    return t.in_boolean_context() ? Ni(t, e, ci(e, [e, ui(hn, e)]).optimize(t)) : e;
  }

  function Qi(e, t, n) {
    for (var i = 0; i < n.length; i++) {
      var r = n[i];

      if (r instanceof Ne) {
        var o = r.expression;
        o instanceof bt && (n.splice.apply(n, [i, 1].concat(_toConsumableArray(o.elements))), i--);
      }
    }

    return e;
  }

  function er(e, t) {
    if (!t.option("computed_props")) return e;
    if (!(e.key instanceof rn)) return e;

    if (e.key instanceof on || e.key instanceof an) {
      if ("__proto__" === e.key.value) return e;
      if ("constructor" == e.key.value && t.parent() instanceof wt) return e;
      e.key = e instanceof Ot ? e.key.value : ui(Ht, e.key, {
        name: e.key.value
      });
    }

    return e;
  }

  ei(vt, function (e, t) {
    var n;

    if (t.option("dead_code") && e.left instanceof Zt && (n = e.left.definition()).scope === t.find_parent(xe)) {
      var i,
          r = 0,
          o = e;

      do {
        if (i = o, (o = t.parent(r++)) instanceof He) {
          if (a(r, o)) break;
          if (qi(n.scope, [n])) break;
          return "=" == e.operator ? e.right : (n.fixed = !1, ui(St, e, {
            operator: e.operator.slice(0, -1),
            left: e.left,
            right: e.right
          }).optimize(t));
        }
      } while (o instanceof St && o.right === i || o instanceof _t && o.tail_node() === i);
    }

    return "=" == (e = e.lift_sequences(t)).operator && e.left instanceof Zt && e.right instanceof St && (e.right.left instanceof Zt && e.right.left.name == e.left.name && $i.has(e.right.operator) ? (e.operator = e.right.operator + "=", e.right = e.right.right) : e.right.right instanceof Zt && e.right.right.name == e.left.name && ji.has(e.right.operator) && !e.right.left.has_side_effects(t) && (e.operator = e.right.operator + "=", e.right = e.right.left)), e;

    function a(n, i) {
      var r = e.right;
      e.right = ui(ln, r);
      var o = i.may_throw(t);
      e.right = r;

      for (var a, s = e.left.definition().scope; (a = t.parent(n++)) !== s;) {
        if (a instanceof et) {
          if (a.bfinally) return !0;
          if (o && a.bcatch) return !0;
        }
      }
    }
  }), ei(Tt, function (e, t) {
    if (!t.option("evaluate")) return e;
    var n = e.right.evaluate(t);
    return void 0 === n ? e = e.left : n !== e.right && (n = li(n, e.right), e.right = Ri(n, e.right)), e;
  }), ei(At, function (e, t) {
    if (!t.option("conditionals")) return e;

    if (e.condition instanceof _t) {
      var n = e.condition.expressions.slice();
      return e.condition = n.pop(), n.push(e), ci(e, n);
    }

    var i = e.condition.evaluate(t);
    if (i !== e.condition) return i ? (t.warn("Condition always true [{file}:{line},{col}]", e.start), fi(t.parent(), t.self(), e.consequent)) : (t.warn("Condition always false [{file}:{line},{col}]", e.start), fi(t.parent(), t.self(), e.alternative));
    var r = i.negate(t, Fn(t));
    Ni(t, i, r) === r && (e = ui(At, e, {
      condition: r,
      consequent: e.alternative,
      alternative: e.consequent
    }));
    var o,
        a = e.condition,
        s = e.consequent,
        u = e.alternative;
    if (a instanceof Zt && s instanceof Zt && a.definition() === s.definition()) return ui(St, e, {
      operator: "||",
      left: a,
      right: u
    });
    if (s instanceof vt && u instanceof vt && s.operator == u.operator && s.left.equivalent_to(u.left) && (!e.condition.has_side_effects(t) || "=" == s.operator && !s.left.has_side_effects(t))) return ui(vt, e, {
      operator: s.operator,
      left: s.left,
      right: ui(At, e, {
        condition: e.condition,
        consequent: s.right,
        alternative: u.right
      })
    });

    if (s instanceof ft && u.TYPE === s.TYPE && s.args.length > 0 && s.args.length == u.args.length && s.expression.equivalent_to(u.expression) && !e.condition.has_side_effects(t) && !s.expression.has_side_effects(t) && "number" == typeof (o = function () {
      for (var e = s.args, t = u.args, n = 0, i = e.length; n < i; n++) {
        if (e[n] instanceof Ne) return;

        if (!e[n].equivalent_to(t[n])) {
          if (t[n] instanceof Ne) return;

          for (var r = n + 1; r < i; r++) {
            if (e[r] instanceof Ne) return;
            if (!e[r].equivalent_to(t[r])) return;
          }

          return n;
        }
      }
    }())) {
      var c = s.clone();
      return c.args[o] = ui(At, e, {
        condition: e.condition,
        consequent: s.args[o],
        alternative: u.args[o]
      }), c;
    }

    if (s instanceof At && s.alternative.equivalent_to(u)) return ui(At, e, {
      condition: ui(St, e, {
        left: e.condition,
        operator: "&&",
        right: s.condition
      }),
      consequent: s.consequent,
      alternative: u
    });
    if (s.equivalent_to(u)) return ci(e, [e.condition, s]).optimize(t);
    if (s instanceof St && "||" == s.operator && s.right.equivalent_to(u)) return ui(St, e, {
      operator: "||",
      left: ui(St, e, {
        operator: "&&",
        left: e.condition,
        right: s.left
      }),
      right: u
    }).optimize(t);
    var l = t.in_boolean_context();
    return p(e.consequent) ? _(e.alternative) ? f(e.condition) : ui(St, e, {
      operator: "||",
      left: f(e.condition),
      right: e.alternative
    }) : _(e.consequent) ? p(e.alternative) ? f(e.condition.negate(t)) : ui(St, e, {
      operator: "&&",
      left: f(e.condition.negate(t)),
      right: e.alternative
    }) : p(e.alternative) ? ui(St, e, {
      operator: "||",
      left: f(e.condition.negate(t)),
      right: e.consequent
    }) : _(e.alternative) ? ui(St, e, {
      operator: "&&",
      left: f(e.condition),
      right: e.consequent
    }) : e;

    function f(e) {
      return e.is_boolean() ? e : ui(Dt, e, {
        operator: "!",
        expression: e.negate(t)
      });
    }

    function p(e) {
      return e instanceof hn || l && e instanceof rn && e.getValue() || e instanceof Dt && "!" == e.operator && e.expression instanceof rn && !e.expression.getValue();
    }

    function _(e) {
      return e instanceof En || l && e instanceof rn && !e.getValue() || e instanceof Dt && "!" == e.operator && e.expression instanceof rn && e.expression.getValue();
    }
  }), ei(mn, function (e, t) {
    if (t.in_boolean_context()) return ui(an, e, {
      value: +e.value
    });
    var n = t.parent();
    return t.option("booleans_as_integers") ? (n instanceof St && ("===" == n.operator || "!==" == n.operator) && (n.operator = n.operator.replace(/=$/, "")), ui(an, e, {
      value: +e.value
    })) : t.option("booleans") ? n instanceof St && ("==" == n.operator || "!=" == n.operator) ? (t.warn("Non-strict equality against boolean: {operator} {value} [{file}:{line},{col}]", {
      operator: n.operator,
      value: e.value,
      file: n.start.file,
      line: n.start.line,
      col: n.start.col
    }), ui(an, e, {
      value: +e.value
    })) : ui(Dt, e, {
      operator: "!",
      expression: ui(an, e, {
        value: 1 - e.value
      })
    }) : e;
  }), ei(Et, function (e, t) {
    var n,
        i = e.expression,
        r = e.property;

    if (t.option("properties")) {
      var o = r.evaluate(t);

      if (o !== r) {
        if ("string" == typeof o) if ("undefined" == o) o = void 0;else (A = parseFloat(o)).toString() == o && (o = A);
        r = e.property = Ri(r, li(o, r).transform(t));
        var a = "" + o;
        if (j(a) && a.length <= r.print_to_string().length + 1) return ui(mt, e, {
          expression: i,
          property: a,
          quote: r.quote
        }).optimize(t);
      }
    }

    e: if (t.option("arguments") && i instanceof Zt && "arguments" == i.name && 1 == i.definition().orig.length && (n = i.scope) instanceof xe && n.uses_arguments && !(n instanceof Le) && r instanceof an) {
      for (var s = r.getValue(), u = new Set(), c = n.argnames, l = 0; l < c.length; l++) {
        if (!(c[l] instanceof Ut)) break e;
        var f = c[l].name;
        if (u.has(f)) break e;
        u.add(f);
      }

      var p = n.argnames[s];

      if (p && t.has_directive("use strict")) {
        var _ = p.definition();

        (!t.option("reduce_vars") || _.assignments || _.orig.length > 1) && (p = null);
      } else if (!p && !t.option("keep_fargs") && s < n.argnames.length + 5) for (; s >= n.argnames.length;) {
        p = ui(Ut, n, {
          name: n.make_var_name("argument_" + n.argnames.length),
          scope: n
        }), n.argnames.push(p), n.enclosed.push(n.def_variable(p));
      }

      if (p) {
        var d = ui(Zt, e, p);
        return d.reference({}), Jn(p, Gn), d;
      }
    }

    if (Mi(e, t.parent())) return e;

    if (o !== r) {
      var m = e.flatten_object(a, t);
      m && (i = e.expression = m.expression, r = e.property = m.property);
    }

    if (t.option("properties") && t.option("side_effects") && r instanceof an && i instanceof bt) {
      s = r.getValue();
      var E = i.elements,
          h = E[s];

      e: if (Zi(h, t)) {
        for (var D = !0, g = [], S = E.length; --S > s;) {
          (A = E[S].drop_side_effect_free(t)) && (g.unshift(A), D && A.has_side_effects(t) && (D = !1));
        }

        if (h instanceof Ne) break e;

        for (h = h instanceof _n ? ui(pn, h) : h, D || g.unshift(h); --S >= 0;) {
          var A;
          if ((A = E[S]) instanceof Ne) break e;
          (A = A.drop_side_effect_free(t)) ? g.unshift(A) : s--;
        }

        return D ? (g.push(h), ci(e, g).optimize(t)) : ui(Et, e, {
          expression: ui(bt, i, {
            elements: g
          }),
          property: ui(an, r, {
            value: s
          })
        });
      }
    }

    var v = e.evaluate(t);
    return v !== e ? Ni(t, v = li(v, e).optimize(t), e) : e;
  }), xe.DEFMETHOD("contains_this", function () {
    var e,
        t = this;
    return t.walk(new Sn(function (n) {
      return !!e || (n instanceof tn ? e = !0 : n !== t && n instanceof Re && !(n instanceof Le) || void 0);
    })), e;
  }), dt.DEFMETHOD("flatten_object", function (e, t) {
    if (t.option("properties")) {
      var n = t.option("unsafe_arrows") && t.option("ecma") >= 6,
          i = this.expression;
      if (i instanceof yt) for (var r = i.properties, o = r.length; --o >= 0;) {
        var a = r[o];

        if ("" + (a instanceof Rt ? a.key.name : a.key) == e) {
          if (!r.every(function (e) {
            return e instanceof Ot || n && e instanceof Rt && !e.is_generator;
          })) break;
          if (!Zi(a.value, t)) break;
          return ui(Et, this, {
            expression: ui(bt, i, {
              elements: r.map(function (e) {
                var t = e.value;
                t instanceof ke && (t = ui(Ie, t, t));
                var n = e.key;
                return n instanceof le && !(n instanceof Ht) ? ci(e, [n, t]) : t;
              })
            }),
            property: ui(an, this, {
              value: o
            })
          });
        }
      }
    }
  }), ei(mt, function (e, t) {
    if ("arguments" != e.property && "caller" != e.property || t.warn("Function.prototype.{prop} not supported [{file}:{line},{col}]", {
      prop: e.property,
      file: e.start.file,
      line: e.start.line,
      col: e.start.col
    }), Mi(e, t.parent())) return e;

    if (t.option("unsafe_proto") && e.expression instanceof mt && "prototype" == e.expression.property) {
      var n = e.expression.expression;
      if (Di(n)) switch (n.name) {
        case "Array":
          e.expression = ui(bt, e.expression, {
            elements: []
          });
          break;

        case "Function":
          e.expression = ui(Ie, e.expression, {
            argnames: [],
            body: []
          });
          break;

        case "Number":
          e.expression = ui(an, e.expression, {
            value: 0
          });
          break;

        case "Object":
          e.expression = ui(yt, e.expression, {
            properties: []
          });
          break;

        case "RegExp":
          e.expression = ui(un, e.expression, {
            value: {
              source: "t",
              flags: ""
            }
          });
          break;

        case "String":
          e.expression = ui(on, e.expression, {
            value: ""
          });
      }
    }

    var i = e.flatten_object(e.property, t);
    if (i) return i.optimize(t);
    var r = e.evaluate(t);
    return r !== e ? Ni(t, r = li(r, e).optimize(t), e) : e;
  }), ei(bt, function (e, t) {
    var n = Ji(e, t);
    return n !== e ? n : Qi(e, 0, e.elements);
  }), ei(yt, function (e, t) {
    var n = Ji(e, t);
    if (n !== e) return n;

    for (var i = e.properties, r = 0; r < i.length; r++) {
      var o = i[r];

      if (o instanceof Ne) {
        var a = o.expression;
        a instanceof yt ? (i.splice.apply(i, [r, 1].concat(o.expression.properties)), r--) : a instanceof rn && !(a instanceof on) && i.splice(r, 1);
      }
    }

    return e;
  }), ei(un, Ji), ei(Xe, function (e, t) {
    return e.value && Ci(e.value, t) && (e.value = null), e;
  }), ei(Le, function (e, t) {
    if (e.body instanceof le || (e = Ui(e, t)), t.option("arrows") && 1 == e.body.length && e.body[0] instanceof Xe) {
      var n = e.body[0].value;
      e.body = n || [];
    }

    return e;
  }), ei(Ie, function (e, t) {
    if (e = Ui(e, t), t.option("unsafe_arrows") && t.option("ecma") >= 6 && !e.name && !e.is_generator && !e.uses_arguments && !e.pinned()) {
      var n = !1;
      if (e.walk(new Sn(function (e) {
        return !!n || (e instanceof tn ? (n = !0, !0) : void 0);
      })), !n) return ui(Le, e, e).optimize(t);
    }

    return e;
  }), ei(wt, function (e, t) {
    return e;
  }), ei(gn, function (e, t) {
    return e.expression && !e.is_star && Ci(e.expression, t) && (e.expression = null), e;
  }), ei(Ke, function (e, t) {
    if (!t.option("evaluate") || t.parent() instanceof Be) return e;

    for (var n = [], i = 0; i < e.segments.length; i++) {
      var r = e.segments[i];

      if (r instanceof le) {
        var o = r.evaluate(t);

        if (o !== r && (o + "").length <= r.print_to_string().length + "${}".length) {
          n[n.length - 1].value = n[n.length - 1].value + o + e.segments[++i].value;
          continue;
        }
      }

      n.push(r);
    }

    return e.segments = n, 1 == n.length ? ui(on, e, n[0]) : e;
  }), ei(Be, function (e, t) {
    return e;
  }), ei(Ct, er), ei(Rt, function (e, t) {
    if (er(e, t), t.option("arrows") && t.parent() instanceof yt && !e.is_generator && !e.value.uses_arguments && !e.value.pinned() && 1 == e.value.body.length && e.value.body[0] instanceof Xe && e.value.body[0].value && !e.value.contains_this()) {
      var n = ui(Le, e.value, e.value);
      return n.async = e.async, n.is_generator = e.is_generator, ui(Ot, e, {
        key: e.key instanceof Ht ? e.key.name : e.key,
        value: n,
        quote: e.quote
      });
    }

    return e;
  }), ei(Ot, function (e, t) {
    er(e, t);
    var n = t.option("unsafe_methods");

    if (n && t.option("ecma") >= 6 && (!(n instanceof RegExp) || n.test(e.key + ""))) {
      var i = e.key,
          r = e.value;
      if ((r instanceof Le && Array.isArray(r.body) && !r.contains_this() || r instanceof Ie) && !r.name) return ui(Rt, e, {
        async: r.async,
        is_generator: r.is_generator,
        key: i instanceof le ? i : ui(Ht, e, {
          name: i
        }),
        value: ui(ke, r, r),
        quote: e.quote
      });
    }

    return e;
  }), ei(Pe, function (e, t) {
    if (1 == t.option("pure_getters") && t.option("unused") && !e.is_array && Array.isArray(e.names) && !function (e) {
      for (var t = [/^VarDef$/, /^(Const|Let|Var)$/, /^Export$/], n = 0, i = 0, r = t.length; n < r; i++) {
        var o = e.parent(i);
        if (!o) return !1;

        if (0 !== n || "Destructuring" != o.TYPE) {
          if (!t[n].test(o.TYPE)) return !1;
          n++;
        }
      }

      return !0;
    }(t)) {
      for (var n = [], i = 0; i < e.names.length; i++) {
        var r = e.names[i];
        r instanceof Ot && "string" == typeof r.key && r.value instanceof Lt && !o(t, r.value.definition()) || n.push(r);
      }

      n.length != e.names.length && (e.names = n);
    }

    return e;

    function o(e, t) {
      return !!t.references.length || !!t.global && (!e.toplevel.vars || !!e.top_retain && e.top_retain(t));
    }
  });
  var tr = ["$&", "$'", "$*", "$+", "$1", "$2", "$3", "$4", "$5", "$6", "$7", "$8", "$9", "$_", "$`", "$input", "@@iterator", "ABORT_ERR", "ACTIVE", "ACTIVE_ATTRIBUTES", "ACTIVE_TEXTURE", "ACTIVE_UNIFORMS", "ADDITION", "ALIASED_LINE_WIDTH_RANGE", "ALIASED_POINT_SIZE_RANGE", "ALLOW_KEYBOARD_INPUT", "ALLPASS", "ALPHA", "ALPHA_BITS", "ALT_MASK", "ALWAYS", "ANY_TYPE", "ANY_UNORDERED_NODE_TYPE", "ARRAY_BUFFER", "ARRAY_BUFFER_BINDING", "ATTACHED_SHADERS", "ATTRIBUTE_NODE", "AT_TARGET", "AddSearchProvider", "AnalyserNode", "AnimationEvent", "AnonXMLHttpRequest", "ApplicationCache", "ApplicationCacheErrorEvent", "Array", "ArrayBuffer", "Attr", "Audio", "AudioBuffer", "AudioBufferSourceNode", "AudioContext", "AudioDestinationNode", "AudioListener", "AudioNode", "AudioParam", "AudioProcessingEvent", "AudioStreamTrack", "AutocompleteErrorEvent", "BACK", "BAD_BOUNDARYPOINTS_ERR", "BANDPASS", "BLEND", "BLEND_COLOR", "BLEND_DST_ALPHA", "BLEND_DST_RGB", "BLEND_EQUATION", "BLEND_EQUATION_ALPHA", "BLEND_EQUATION_RGB", "BLEND_SRC_ALPHA", "BLEND_SRC_RGB", "BLUE_BITS", "BLUR", "BOOL", "BOOLEAN_TYPE", "BOOL_VEC2", "BOOL_VEC3", "BOOL_VEC4", "BOTH", "BROWSER_DEFAULT_WEBGL", "BUBBLING_PHASE", "BUFFER_SIZE", "BUFFER_USAGE", "BYTE", "BYTES_PER_ELEMENT", "BarProp", "BaseHref", "BatteryManager", "BeforeLoadEvent", "BeforeUnloadEvent", "BiquadFilterNode", "Blob", "BlobEvent", "Boolean", "CAPTURING_PHASE", "CCW", "CDATASection", "CDATA_SECTION_NODE", "CHANGE", "CHARSET_RULE", "CHECKING", "CLAMP_TO_EDGE", "CLICK", "CLOSED", "CLOSING", "COLOR_ATTACHMENT0", "COLOR_BUFFER_BIT", "COLOR_CLEAR_VALUE", "COLOR_WRITEMASK", "COMMENT_NODE", "COMPILE_STATUS", "COMPRESSED_RGBA_S3TC_DXT1_EXT", "COMPRESSED_RGBA_S3TC_DXT3_EXT", "COMPRESSED_RGBA_S3TC_DXT5_EXT", "COMPRESSED_RGB_S3TC_DXT1_EXT", "COMPRESSED_TEXTURE_FORMATS", "CONNECTING", "CONSTANT_ALPHA", "CONSTANT_COLOR", "CONSTRAINT_ERR", "CONTEXT_LOST_WEBGL", "CONTROL_MASK", "COUNTER_STYLE_RULE", "CSS", "CSS2Properties", "CSSCharsetRule", "CSSConditionRule", "CSSCounterStyleRule", "CSSFontFaceRule", "CSSFontFeatureValuesRule", "CSSGroupingRule", "CSSImportRule", "CSSKeyframeRule", "CSSKeyframesRule", "CSSMediaRule", "CSSMozDocumentRule", "CSSNameSpaceRule", "CSSPageRule", "CSSPrimitiveValue", "CSSRule", "CSSRuleList", "CSSStyleDeclaration", "CSSStyleRule", "CSSStyleSheet", "CSSSupportsRule", "CSSUnknownRule", "CSSValue", "CSSValueList", "CSSVariablesDeclaration", "CSSVariablesRule", "CSSViewportRule", "CSS_ATTR", "CSS_CM", "CSS_COUNTER", "CSS_CUSTOM", "CSS_DEG", "CSS_DIMENSION", "CSS_EMS", "CSS_EXS", "CSS_FILTER_BLUR", "CSS_FILTER_BRIGHTNESS", "CSS_FILTER_CONTRAST", "CSS_FILTER_CUSTOM", "CSS_FILTER_DROP_SHADOW", "CSS_FILTER_GRAYSCALE", "CSS_FILTER_HUE_ROTATE", "CSS_FILTER_INVERT", "CSS_FILTER_OPACITY", "CSS_FILTER_REFERENCE", "CSS_FILTER_SATURATE", "CSS_FILTER_SEPIA", "CSS_GRAD", "CSS_HZ", "CSS_IDENT", "CSS_IN", "CSS_INHERIT", "CSS_KHZ", "CSS_MATRIX", "CSS_MATRIX3D", "CSS_MM", "CSS_MS", "CSS_NUMBER", "CSS_PC", "CSS_PERCENTAGE", "CSS_PERSPECTIVE", "CSS_PRIMITIVE_VALUE", "CSS_PT", "CSS_PX", "CSS_RAD", "CSS_RECT", "CSS_RGBCOLOR", "CSS_ROTATE", "CSS_ROTATE3D", "CSS_ROTATEX", "CSS_ROTATEY", "CSS_ROTATEZ", "CSS_S", "CSS_SCALE", "CSS_SCALE3D", "CSS_SCALEX", "CSS_SCALEY", "CSS_SCALEZ", "CSS_SKEW", "CSS_SKEWX", "CSS_SKEWY", "CSS_STRING", "CSS_TRANSLATE", "CSS_TRANSLATE3D", "CSS_TRANSLATEX", "CSS_TRANSLATEY", "CSS_TRANSLATEZ", "CSS_UNKNOWN", "CSS_URI", "CSS_VALUE_LIST", "CSS_VH", "CSS_VMAX", "CSS_VMIN", "CSS_VW", "CULL_FACE", "CULL_FACE_MODE", "CURRENT_PROGRAM", "CURRENT_VERTEX_ATTRIB", "CUSTOM", "CW", "CanvasGradient", "CanvasPattern", "CanvasRenderingContext2D", "CaretPosition", "ChannelMergerNode", "ChannelSplitterNode", "CharacterData", "ClientRect", "ClientRectList", "Clipboard", "ClipboardEvent", "CloseEvent", "Collator", "CommandEvent", "Comment", "CompositionEvent", "Console", "Controllers", "ConvolverNode", "Counter", "Crypto", "CryptoKey", "CustomEvent", "DATABASE_ERR", "DATA_CLONE_ERR", "DATA_ERR", "DBLCLICK", "DECR", "DECR_WRAP", "DELETE_STATUS", "DEPTH_ATTACHMENT", "DEPTH_BITS", "DEPTH_BUFFER_BIT", "DEPTH_CLEAR_VALUE", "DEPTH_COMPONENT", "DEPTH_COMPONENT16", "DEPTH_FUNC", "DEPTH_RANGE", "DEPTH_STENCIL", "DEPTH_STENCIL_ATTACHMENT", "DEPTH_TEST", "DEPTH_WRITEMASK", "DIRECTION_DOWN", "DIRECTION_LEFT", "DIRECTION_RIGHT", "DIRECTION_UP", "DISABLED", "DISPATCH_REQUEST_ERR", "DITHER", "DOCUMENT_FRAGMENT_NODE", "DOCUMENT_NODE", "DOCUMENT_POSITION_CONTAINED_BY", "DOCUMENT_POSITION_CONTAINS", "DOCUMENT_POSITION_DISCONNECTED", "DOCUMENT_POSITION_FOLLOWING", "DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC", "DOCUMENT_POSITION_PRECEDING", "DOCUMENT_TYPE_NODE", "DOMCursor", "DOMError", "DOMException", "DOMImplementation", "DOMImplementationLS", "DOMMatrix", "DOMMatrixReadOnly", "DOMParser", "DOMPoint", "DOMPointReadOnly", "DOMQuad", "DOMRect", "DOMRectList", "DOMRectReadOnly", "DOMRequest", "DOMSTRING_SIZE_ERR", "DOMSettableTokenList", "DOMStringList", "DOMStringMap", "DOMTokenList", "DOMTransactionEvent", "DOM_DELTA_LINE", "DOM_DELTA_PAGE", "DOM_DELTA_PIXEL", "DOM_INPUT_METHOD_DROP", "DOM_INPUT_METHOD_HANDWRITING", "DOM_INPUT_METHOD_IME", "DOM_INPUT_METHOD_KEYBOARD", "DOM_INPUT_METHOD_MULTIMODAL", "DOM_INPUT_METHOD_OPTION", "DOM_INPUT_METHOD_PASTE", "DOM_INPUT_METHOD_SCRIPT", "DOM_INPUT_METHOD_UNKNOWN", "DOM_INPUT_METHOD_VOICE", "DOM_KEY_LOCATION_JOYSTICK", "DOM_KEY_LOCATION_LEFT", "DOM_KEY_LOCATION_MOBILE", "DOM_KEY_LOCATION_NUMPAD", "DOM_KEY_LOCATION_RIGHT", "DOM_KEY_LOCATION_STANDARD", "DOM_VK_0", "DOM_VK_1", "DOM_VK_2", "DOM_VK_3", "DOM_VK_4", "DOM_VK_5", "DOM_VK_6", "DOM_VK_7", "DOM_VK_8", "DOM_VK_9", "DOM_VK_A", "DOM_VK_ACCEPT", "DOM_VK_ADD", "DOM_VK_ALT", "DOM_VK_ALTGR", "DOM_VK_AMPERSAND", "DOM_VK_ASTERISK", "DOM_VK_AT", "DOM_VK_ATTN", "DOM_VK_B", "DOM_VK_BACKSPACE", "DOM_VK_BACK_QUOTE", "DOM_VK_BACK_SLASH", "DOM_VK_BACK_SPACE", "DOM_VK_C", "DOM_VK_CANCEL", "DOM_VK_CAPS_LOCK", "DOM_VK_CIRCUMFLEX", "DOM_VK_CLEAR", "DOM_VK_CLOSE_BRACKET", "DOM_VK_CLOSE_CURLY_BRACKET", "DOM_VK_CLOSE_PAREN", "DOM_VK_COLON", "DOM_VK_COMMA", "DOM_VK_CONTEXT_MENU", "DOM_VK_CONTROL", "DOM_VK_CONVERT", "DOM_VK_CRSEL", "DOM_VK_CTRL", "DOM_VK_D", "DOM_VK_DECIMAL", "DOM_VK_DELETE", "DOM_VK_DIVIDE", "DOM_VK_DOLLAR", "DOM_VK_DOUBLE_QUOTE", "DOM_VK_DOWN", "DOM_VK_E", "DOM_VK_EISU", "DOM_VK_END", "DOM_VK_ENTER", "DOM_VK_EQUALS", "DOM_VK_EREOF", "DOM_VK_ESCAPE", "DOM_VK_EXCLAMATION", "DOM_VK_EXECUTE", "DOM_VK_EXSEL", "DOM_VK_F", "DOM_VK_F1", "DOM_VK_F10", "DOM_VK_F11", "DOM_VK_F12", "DOM_VK_F13", "DOM_VK_F14", "DOM_VK_F15", "DOM_VK_F16", "DOM_VK_F17", "DOM_VK_F18", "DOM_VK_F19", "DOM_VK_F2", "DOM_VK_F20", "DOM_VK_F21", "DOM_VK_F22", "DOM_VK_F23", "DOM_VK_F24", "DOM_VK_F25", "DOM_VK_F26", "DOM_VK_F27", "DOM_VK_F28", "DOM_VK_F29", "DOM_VK_F3", "DOM_VK_F30", "DOM_VK_F31", "DOM_VK_F32", "DOM_VK_F33", "DOM_VK_F34", "DOM_VK_F35", "DOM_VK_F36", "DOM_VK_F4", "DOM_VK_F5", "DOM_VK_F6", "DOM_VK_F7", "DOM_VK_F8", "DOM_VK_F9", "DOM_VK_FINAL", "DOM_VK_FRONT", "DOM_VK_G", "DOM_VK_GREATER_THAN", "DOM_VK_H", "DOM_VK_HANGUL", "DOM_VK_HANJA", "DOM_VK_HASH", "DOM_VK_HELP", "DOM_VK_HK_TOGGLE", "DOM_VK_HOME", "DOM_VK_HYPHEN_MINUS", "DOM_VK_I", "DOM_VK_INSERT", "DOM_VK_J", "DOM_VK_JUNJA", "DOM_VK_K", "DOM_VK_KANA", "DOM_VK_KANJI", "DOM_VK_L", "DOM_VK_LEFT", "DOM_VK_LEFT_TAB", "DOM_VK_LESS_THAN", "DOM_VK_M", "DOM_VK_META", "DOM_VK_MODECHANGE", "DOM_VK_MULTIPLY", "DOM_VK_N", "DOM_VK_NONCONVERT", "DOM_VK_NUMPAD0", "DOM_VK_NUMPAD1", "DOM_VK_NUMPAD2", "DOM_VK_NUMPAD3", "DOM_VK_NUMPAD4", "DOM_VK_NUMPAD5", "DOM_VK_NUMPAD6", "DOM_VK_NUMPAD7", "DOM_VK_NUMPAD8", "DOM_VK_NUMPAD9", "DOM_VK_NUM_LOCK", "DOM_VK_O", "DOM_VK_OEM_1", "DOM_VK_OEM_102", "DOM_VK_OEM_2", "DOM_VK_OEM_3", "DOM_VK_OEM_4", "DOM_VK_OEM_5", "DOM_VK_OEM_6", "DOM_VK_OEM_7", "DOM_VK_OEM_8", "DOM_VK_OEM_COMMA", "DOM_VK_OEM_MINUS", "DOM_VK_OEM_PERIOD", "DOM_VK_OEM_PLUS", "DOM_VK_OPEN_BRACKET", "DOM_VK_OPEN_CURLY_BRACKET", "DOM_VK_OPEN_PAREN", "DOM_VK_P", "DOM_VK_PA1", "DOM_VK_PAGEDOWN", "DOM_VK_PAGEUP", "DOM_VK_PAGE_DOWN", "DOM_VK_PAGE_UP", "DOM_VK_PAUSE", "DOM_VK_PERCENT", "DOM_VK_PERIOD", "DOM_VK_PIPE", "DOM_VK_PLAY", "DOM_VK_PLUS", "DOM_VK_PRINT", "DOM_VK_PRINTSCREEN", "DOM_VK_PROCESSKEY", "DOM_VK_PROPERITES", "DOM_VK_Q", "DOM_VK_QUESTION_MARK", "DOM_VK_QUOTE", "DOM_VK_R", "DOM_VK_REDO", "DOM_VK_RETURN", "DOM_VK_RIGHT", "DOM_VK_S", "DOM_VK_SCROLL_LOCK", "DOM_VK_SELECT", "DOM_VK_SEMICOLON", "DOM_VK_SEPARATOR", "DOM_VK_SHIFT", "DOM_VK_SLASH", "DOM_VK_SLEEP", "DOM_VK_SPACE", "DOM_VK_SUBTRACT", "DOM_VK_T", "DOM_VK_TAB", "DOM_VK_TILDE", "DOM_VK_U", "DOM_VK_UNDERSCORE", "DOM_VK_UNDO", "DOM_VK_UNICODE", "DOM_VK_UP", "DOM_VK_V", "DOM_VK_VOLUME_DOWN", "DOM_VK_VOLUME_MUTE", "DOM_VK_VOLUME_UP", "DOM_VK_W", "DOM_VK_WIN", "DOM_VK_WINDOW", "DOM_VK_WIN_ICO_00", "DOM_VK_WIN_ICO_CLEAR", "DOM_VK_WIN_ICO_HELP", "DOM_VK_WIN_OEM_ATTN", "DOM_VK_WIN_OEM_AUTO", "DOM_VK_WIN_OEM_BACKTAB", "DOM_VK_WIN_OEM_CLEAR", "DOM_VK_WIN_OEM_COPY", "DOM_VK_WIN_OEM_CUSEL", "DOM_VK_WIN_OEM_ENLW", "DOM_VK_WIN_OEM_FINISH", "DOM_VK_WIN_OEM_FJ_JISHO", "DOM_VK_WIN_OEM_FJ_LOYA", "DOM_VK_WIN_OEM_FJ_MASSHOU", "DOM_VK_WIN_OEM_FJ_ROYA", "DOM_VK_WIN_OEM_FJ_TOUROKU", "DOM_VK_WIN_OEM_JUMP", "DOM_VK_WIN_OEM_PA1", "DOM_VK_WIN_OEM_PA2", "DOM_VK_WIN_OEM_PA3", "DOM_VK_WIN_OEM_RESET", "DOM_VK_WIN_OEM_WSCTRL", "DOM_VK_X", "DOM_VK_XF86XK_ADD_FAVORITE", "DOM_VK_XF86XK_APPLICATION_LEFT", "DOM_VK_XF86XK_APPLICATION_RIGHT", "DOM_VK_XF86XK_AUDIO_CYCLE_TRACK", "DOM_VK_XF86XK_AUDIO_FORWARD", "DOM_VK_XF86XK_AUDIO_LOWER_VOLUME", "DOM_VK_XF86XK_AUDIO_MEDIA", "DOM_VK_XF86XK_AUDIO_MUTE", "DOM_VK_XF86XK_AUDIO_NEXT", "DOM_VK_XF86XK_AUDIO_PAUSE", "DOM_VK_XF86XK_AUDIO_PLAY", "DOM_VK_XF86XK_AUDIO_PREV", "DOM_VK_XF86XK_AUDIO_RAISE_VOLUME", "DOM_VK_XF86XK_AUDIO_RANDOM_PLAY", "DOM_VK_XF86XK_AUDIO_RECORD", "DOM_VK_XF86XK_AUDIO_REPEAT", "DOM_VK_XF86XK_AUDIO_REWIND", "DOM_VK_XF86XK_AUDIO_STOP", "DOM_VK_XF86XK_AWAY", "DOM_VK_XF86XK_BACK", "DOM_VK_XF86XK_BACK_FORWARD", "DOM_VK_XF86XK_BATTERY", "DOM_VK_XF86XK_BLUE", "DOM_VK_XF86XK_BLUETOOTH", "DOM_VK_XF86XK_BOOK", "DOM_VK_XF86XK_BRIGHTNESS_ADJUST", "DOM_VK_XF86XK_CALCULATOR", "DOM_VK_XF86XK_CALENDAR", "DOM_VK_XF86XK_CD", "DOM_VK_XF86XK_CLOSE", "DOM_VK_XF86XK_COMMUNITY", "DOM_VK_XF86XK_CONTRAST_ADJUST", "DOM_VK_XF86XK_COPY", "DOM_VK_XF86XK_CUT", "DOM_VK_XF86XK_CYCLE_ANGLE", "DOM_VK_XF86XK_DISPLAY", "DOM_VK_XF86XK_DOCUMENTS", "DOM_VK_XF86XK_DOS", "DOM_VK_XF86XK_EJECT", "DOM_VK_XF86XK_EXCEL", "DOM_VK_XF86XK_EXPLORER", "DOM_VK_XF86XK_FAVORITES", "DOM_VK_XF86XK_FINANCE", "DOM_VK_XF86XK_FORWARD", "DOM_VK_XF86XK_FRAME_BACK", "DOM_VK_XF86XK_FRAME_FORWARD", "DOM_VK_XF86XK_GAME", "DOM_VK_XF86XK_GO", "DOM_VK_XF86XK_GREEN", "DOM_VK_XF86XK_HIBERNATE", "DOM_VK_XF86XK_HISTORY", "DOM_VK_XF86XK_HOME_PAGE", "DOM_VK_XF86XK_HOT_LINKS", "DOM_VK_XF86XK_I_TOUCH", "DOM_VK_XF86XK_KBD_BRIGHTNESS_DOWN", "DOM_VK_XF86XK_KBD_BRIGHTNESS_UP", "DOM_VK_XF86XK_KBD_LIGHT_ON_OFF", "DOM_VK_XF86XK_LAUNCH0", "DOM_VK_XF86XK_LAUNCH1", "DOM_VK_XF86XK_LAUNCH2", "DOM_VK_XF86XK_LAUNCH3", "DOM_VK_XF86XK_LAUNCH4", "DOM_VK_XF86XK_LAUNCH5", "DOM_VK_XF86XK_LAUNCH6", "DOM_VK_XF86XK_LAUNCH7", "DOM_VK_XF86XK_LAUNCH8", "DOM_VK_XF86XK_LAUNCH9", "DOM_VK_XF86XK_LAUNCH_A", "DOM_VK_XF86XK_LAUNCH_B", "DOM_VK_XF86XK_LAUNCH_C", "DOM_VK_XF86XK_LAUNCH_D", "DOM_VK_XF86XK_LAUNCH_E", "DOM_VK_XF86XK_LAUNCH_F", "DOM_VK_XF86XK_LIGHT_BULB", "DOM_VK_XF86XK_LOG_OFF", "DOM_VK_XF86XK_MAIL", "DOM_VK_XF86XK_MAIL_FORWARD", "DOM_VK_XF86XK_MARKET", "DOM_VK_XF86XK_MEETING", "DOM_VK_XF86XK_MEMO", "DOM_VK_XF86XK_MENU_KB", "DOM_VK_XF86XK_MENU_PB", "DOM_VK_XF86XK_MESSENGER", "DOM_VK_XF86XK_MON_BRIGHTNESS_DOWN", "DOM_VK_XF86XK_MON_BRIGHTNESS_UP", "DOM_VK_XF86XK_MUSIC", "DOM_VK_XF86XK_MY_COMPUTER", "DOM_VK_XF86XK_MY_SITES", "DOM_VK_XF86XK_NEW", "DOM_VK_XF86XK_NEWS", "DOM_VK_XF86XK_OFFICE_HOME", "DOM_VK_XF86XK_OPEN", "DOM_VK_XF86XK_OPEN_URL", "DOM_VK_XF86XK_OPTION", "DOM_VK_XF86XK_PASTE", "DOM_VK_XF86XK_PHONE", "DOM_VK_XF86XK_PICTURES", "DOM_VK_XF86XK_POWER_DOWN", "DOM_VK_XF86XK_POWER_OFF", "DOM_VK_XF86XK_RED", "DOM_VK_XF86XK_REFRESH", "DOM_VK_XF86XK_RELOAD", "DOM_VK_XF86XK_REPLY", "DOM_VK_XF86XK_ROCKER_DOWN", "DOM_VK_XF86XK_ROCKER_ENTER", "DOM_VK_XF86XK_ROCKER_UP", "DOM_VK_XF86XK_ROTATE_WINDOWS", "DOM_VK_XF86XK_ROTATION_KB", "DOM_VK_XF86XK_ROTATION_PB", "DOM_VK_XF86XK_SAVE", "DOM_VK_XF86XK_SCREEN_SAVER", "DOM_VK_XF86XK_SCROLL_CLICK", "DOM_VK_XF86XK_SCROLL_DOWN", "DOM_VK_XF86XK_SCROLL_UP", "DOM_VK_XF86XK_SEARCH", "DOM_VK_XF86XK_SEND", "DOM_VK_XF86XK_SHOP", "DOM_VK_XF86XK_SPELL", "DOM_VK_XF86XK_SPLIT_SCREEN", "DOM_VK_XF86XK_STANDBY", "DOM_VK_XF86XK_START", "DOM_VK_XF86XK_STOP", "DOM_VK_XF86XK_SUBTITLE", "DOM_VK_XF86XK_SUPPORT", "DOM_VK_XF86XK_SUSPEND", "DOM_VK_XF86XK_TASK_PANE", "DOM_VK_XF86XK_TERMINAL", "DOM_VK_XF86XK_TIME", "DOM_VK_XF86XK_TOOLS", "DOM_VK_XF86XK_TOP_MENU", "DOM_VK_XF86XK_TO_DO_LIST", "DOM_VK_XF86XK_TRAVEL", "DOM_VK_XF86XK_USER1KB", "DOM_VK_XF86XK_USER2KB", "DOM_VK_XF86XK_USER_PB", "DOM_VK_XF86XK_UWB", "DOM_VK_XF86XK_VENDOR_HOME", "DOM_VK_XF86XK_VIDEO", "DOM_VK_XF86XK_VIEW", "DOM_VK_XF86XK_WAKE_UP", "DOM_VK_XF86XK_WEB_CAM", "DOM_VK_XF86XK_WHEEL_BUTTON", "DOM_VK_XF86XK_WLAN", "DOM_VK_XF86XK_WORD", "DOM_VK_XF86XK_WWW", "DOM_VK_XF86XK_XFER", "DOM_VK_XF86XK_YELLOW", "DOM_VK_XF86XK_ZOOM_IN", "DOM_VK_XF86XK_ZOOM_OUT", "DOM_VK_Y", "DOM_VK_Z", "DOM_VK_ZOOM", "DONE", "DONT_CARE", "DOWNLOADING", "DRAGDROP", "DST_ALPHA", "DST_COLOR", "DYNAMIC_DRAW", "DataChannel", "DataTransfer", "DataTransferItem", "DataTransferItemList", "DataView", "Date", "DateTimeFormat", "DelayNode", "DesktopNotification", "DesktopNotificationCenter", "DeviceLightEvent", "DeviceMotionEvent", "DeviceOrientationEvent", "DeviceProximityEvent", "DeviceStorage", "DeviceStorageChangeEvent", "Document", "DocumentFragment", "DocumentType", "DragEvent", "DynamicsCompressorNode", "E", "ELEMENT_ARRAY_BUFFER", "ELEMENT_ARRAY_BUFFER_BINDING", "ELEMENT_NODE", "EMPTY", "ENCODING_ERR", "ENDED", "END_TO_END", "END_TO_START", "ENTITY_NODE", "ENTITY_REFERENCE_NODE", "EPSILON", "EQUAL", "EQUALPOWER", "ERROR", "EXPONENTIAL_DISTANCE", "Element", "ElementQuery", "Entity", "EntityReference", "Error", "ErrorEvent", "EvalError", "Event", "EventException", "EventSource", "EventTarget", "External", "FASTEST", "FIDOSDK", "FILTER_ACCEPT", "FILTER_INTERRUPT", "FILTER_REJECT", "FILTER_SKIP", "FINISHED_STATE", "FIRST_ORDERED_NODE_TYPE", "FLOAT", "FLOAT_MAT2", "FLOAT_MAT3", "FLOAT_MAT4", "FLOAT_VEC2", "FLOAT_VEC3", "FLOAT_VEC4", "FOCUS", "FONT_FACE_RULE", "FONT_FEATURE_VALUES_RULE", "FRAGMENT_SHADER", "FRAGMENT_SHADER_DERIVATIVE_HINT_OES", "FRAMEBUFFER", "FRAMEBUFFER_ATTACHMENT_OBJECT_NAME", "FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE", "FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE", "FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL", "FRAMEBUFFER_BINDING", "FRAMEBUFFER_COMPLETE", "FRAMEBUFFER_INCOMPLETE_ATTACHMENT", "FRAMEBUFFER_INCOMPLETE_DIMENSIONS", "FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT", "FRAMEBUFFER_UNSUPPORTED", "FRONT", "FRONT_AND_BACK", "FRONT_FACE", "FUNC_ADD", "FUNC_REVERSE_SUBTRACT", "FUNC_SUBTRACT", "Feed", "FeedEntry", "File", "FileError", "FileList", "FileReader", "FindInPage", "Float32Array", "Float64Array", "FocusEvent", "FontFace", "FormData", "Function", "GENERATE_MIPMAP_HINT", "GEQUAL", "GREATER", "GREEN_BITS", "GainNode", "Gamepad", "GamepadButton", "GamepadEvent", "GestureEvent", "HAVE_CURRENT_DATA", "HAVE_ENOUGH_DATA", "HAVE_FUTURE_DATA", "HAVE_METADATA", "HAVE_NOTHING", "HEADERS_RECEIVED", "HIDDEN", "HIERARCHY_REQUEST_ERR", "HIGHPASS", "HIGHSHELF", "HIGH_FLOAT", "HIGH_INT", "HORIZONTAL", "HORIZONTAL_AXIS", "HRTF", "HTMLAllCollection", "HTMLAnchorElement", "HTMLAppletElement", "HTMLAreaElement", "HTMLAudioElement", "HTMLBRElement", "HTMLBaseElement", "HTMLBaseFontElement", "HTMLBlockquoteElement", "HTMLBodyElement", "HTMLButtonElement", "HTMLCanvasElement", "HTMLCollection", "HTMLCommandElement", "HTMLContentElement", "HTMLDListElement", "HTMLDataElement", "HTMLDataListElement", "HTMLDetailsElement", "HTMLDialogElement", "HTMLDirectoryElement", "HTMLDivElement", "HTMLDocument", "HTMLElement", "HTMLEmbedElement", "HTMLFieldSetElement", "HTMLFontElement", "HTMLFormControlsCollection", "HTMLFormElement", "HTMLFrameElement", "HTMLFrameSetElement", "HTMLHRElement", "HTMLHeadElement", "HTMLHeadingElement", "HTMLHtmlElement", "HTMLIFrameElement", "HTMLImageElement", "HTMLInputElement", "HTMLIsIndexElement", "HTMLKeygenElement", "HTMLLIElement", "HTMLLabelElement", "HTMLLegendElement", "HTMLLinkElement", "HTMLMapElement", "HTMLMarqueeElement", "HTMLMediaElement", "HTMLMenuElement", "HTMLMenuItemElement", "HTMLMetaElement", "HTMLMeterElement", "HTMLModElement", "HTMLOListElement", "HTMLObjectElement", "HTMLOptGroupElement", "HTMLOptionElement", "HTMLOptionsCollection", "HTMLOutputElement", "HTMLParagraphElement", "HTMLParamElement", "HTMLPictureElement", "HTMLPreElement", "HTMLProgressElement", "HTMLPropertiesCollection", "HTMLQuoteElement", "HTMLScriptElement", "HTMLSelectElement", "HTMLShadowElement", "HTMLSourceElement", "HTMLSpanElement", "HTMLStyleElement", "HTMLTableCaptionElement", "HTMLTableCellElement", "HTMLTableColElement", "HTMLTableElement", "HTMLTableRowElement", "HTMLTableSectionElement", "HTMLTemplateElement", "HTMLTextAreaElement", "HTMLTimeElement", "HTMLTitleElement", "HTMLTrackElement", "HTMLUListElement", "HTMLUnknownElement", "HTMLVideoElement", "HashChangeEvent", "Headers", "History", "ICE_CHECKING", "ICE_CLOSED", "ICE_COMPLETED", "ICE_CONNECTED", "ICE_FAILED", "ICE_GATHERING", "ICE_WAITING", "IDBCursor", "IDBCursorWithValue", "IDBDatabase", "IDBDatabaseException", "IDBFactory", "IDBFileHandle", "IDBFileRequest", "IDBIndex", "IDBKeyRange", "IDBMutableFile", "IDBObjectStore", "IDBOpenDBRequest", "IDBRequest", "IDBTransaction", "IDBVersionChangeEvent", "IDLE", "IMPLEMENTATION_COLOR_READ_FORMAT", "IMPLEMENTATION_COLOR_READ_TYPE", "IMPORT_RULE", "INCR", "INCR_WRAP", "INDEX_SIZE_ERR", "INT", "INT_VEC2", "INT_VEC3", "INT_VEC4", "INUSE_ATTRIBUTE_ERR", "INVALID_ACCESS_ERR", "INVALID_CHARACTER_ERR", "INVALID_ENUM", "INVALID_EXPRESSION_ERR", "INVALID_FRAMEBUFFER_OPERATION", "INVALID_MODIFICATION_ERR", "INVALID_NODE_TYPE_ERR", "INVALID_OPERATION", "INVALID_STATE_ERR", "INVALID_VALUE", "INVERSE_DISTANCE", "INVERT", "IceCandidate", "Image", "ImageBitmap", "ImageData", "Infinity", "InputEvent", "InputMethodContext", "InstallTrigger", "Int16Array", "Int32Array", "Int8Array", "Intent", "InternalError", "Intl", "IsSearchProviderInstalled", "Iterator", "JSON", "KEEP", "KEYDOWN", "KEYFRAMES_RULE", "KEYFRAME_RULE", "KEYPRESS", "KEYUP", "KeyEvent", "KeyboardEvent", "LENGTHADJUST_SPACING", "LENGTHADJUST_SPACINGANDGLYPHS", "LENGTHADJUST_UNKNOWN", "LEQUAL", "LESS", "LINEAR", "LINEAR_DISTANCE", "LINEAR_MIPMAP_LINEAR", "LINEAR_MIPMAP_NEAREST", "LINES", "LINE_LOOP", "LINE_STRIP", "LINE_WIDTH", "LINK_STATUS", "LIVE", "LN10", "LN2", "LOADED", "LOADING", "LOG10E", "LOG2E", "LOWPASS", "LOWSHELF", "LOW_FLOAT", "LOW_INT", "LSException", "LSParserFilter", "LUMINANCE", "LUMINANCE_ALPHA", "LocalMediaStream", "Location", "MAX_COMBINED_TEXTURE_IMAGE_UNITS", "MAX_CUBE_MAP_TEXTURE_SIZE", "MAX_FRAGMENT_UNIFORM_VECTORS", "MAX_RENDERBUFFER_SIZE", "MAX_SAFE_INTEGER", "MAX_TEXTURE_IMAGE_UNITS", "MAX_TEXTURE_MAX_ANISOTROPY_EXT", "MAX_TEXTURE_SIZE", "MAX_VALUE", "MAX_VARYING_VECTORS", "MAX_VERTEX_ATTRIBS", "MAX_VERTEX_TEXTURE_IMAGE_UNITS", "MAX_VERTEX_UNIFORM_VECTORS", "MAX_VIEWPORT_DIMS", "MEDIA_ERR_ABORTED", "MEDIA_ERR_DECODE", "MEDIA_ERR_ENCRYPTED", "MEDIA_ERR_NETWORK", "MEDIA_ERR_SRC_NOT_SUPPORTED", "MEDIA_KEYERR_CLIENT", "MEDIA_KEYERR_DOMAIN", "MEDIA_KEYERR_HARDWARECHANGE", "MEDIA_KEYERR_OUTPUT", "MEDIA_KEYERR_SERVICE", "MEDIA_KEYERR_UNKNOWN", "MEDIA_RULE", "MEDIUM_FLOAT", "MEDIUM_INT", "META_MASK", "MIN_SAFE_INTEGER", "MIN_VALUE", "MIRRORED_REPEAT", "MODE_ASYNCHRONOUS", "MODE_SYNCHRONOUS", "MODIFICATION", "MOUSEDOWN", "MOUSEDRAG", "MOUSEMOVE", "MOUSEOUT", "MOUSEOVER", "MOUSEUP", "MOZ_KEYFRAMES_RULE", "MOZ_KEYFRAME_RULE", "MOZ_SOURCE_CURSOR", "MOZ_SOURCE_ERASER", "MOZ_SOURCE_KEYBOARD", "MOZ_SOURCE_MOUSE", "MOZ_SOURCE_PEN", "MOZ_SOURCE_TOUCH", "MOZ_SOURCE_UNKNOWN", "MSGESTURE_FLAG_BEGIN", "MSGESTURE_FLAG_CANCEL", "MSGESTURE_FLAG_END", "MSGESTURE_FLAG_INERTIA", "MSGESTURE_FLAG_NONE", "MSPOINTER_TYPE_MOUSE", "MSPOINTER_TYPE_PEN", "MSPOINTER_TYPE_TOUCH", "MS_ASYNC_CALLBACK_STATUS_ASSIGN_DELEGATE", "MS_ASYNC_CALLBACK_STATUS_CANCEL", "MS_ASYNC_CALLBACK_STATUS_CHOOSEANY", "MS_ASYNC_CALLBACK_STATUS_ERROR", "MS_ASYNC_CALLBACK_STATUS_JOIN", "MS_ASYNC_OP_STATUS_CANCELED", "MS_ASYNC_OP_STATUS_ERROR", "MS_ASYNC_OP_STATUS_SUCCESS", "MS_MANIPULATION_STATE_ACTIVE", "MS_MANIPULATION_STATE_CANCELLED", "MS_MANIPULATION_STATE_COMMITTED", "MS_MANIPULATION_STATE_DRAGGING", "MS_MANIPULATION_STATE_INERTIA", "MS_MANIPULATION_STATE_PRESELECT", "MS_MANIPULATION_STATE_SELECTING", "MS_MANIPULATION_STATE_STOPPED", "MS_MEDIA_ERR_ENCRYPTED", "MS_MEDIA_KEYERR_CLIENT", "MS_MEDIA_KEYERR_DOMAIN", "MS_MEDIA_KEYERR_HARDWARECHANGE", "MS_MEDIA_KEYERR_OUTPUT", "MS_MEDIA_KEYERR_SERVICE", "MS_MEDIA_KEYERR_UNKNOWN", "Map", "Math", "MediaController", "MediaDevices", "MediaElementAudioSourceNode", "MediaEncryptedEvent", "MediaError", "MediaKeyError", "MediaKeyEvent", "MediaKeyMessageEvent", "MediaKeyNeededEvent", "MediaKeySession", "MediaKeyStatusMap", "MediaKeySystemAccess", "MediaKeys", "MediaList", "MediaQueryList", "MediaQueryListEvent", "MediaRecorder", "MediaSource", "MediaStream", "MediaStreamAudioDestinationNode", "MediaStreamAudioSourceNode", "MediaStreamEvent", "MediaStreamTrack", "MediaStreamTrackEvent", "MessageChannel", "MessageEvent", "MessagePort", "Methods", "MimeType", "MimeTypeArray", "MouseEvent", "MouseScrollEvent", "MozAnimation", "MozAnimationDelay", "MozAnimationDirection", "MozAnimationDuration", "MozAnimationFillMode", "MozAnimationIterationCount", "MozAnimationName", "MozAnimationPlayState", "MozAnimationTimingFunction", "MozAppearance", "MozBackfaceVisibility", "MozBinding", "MozBorderBottomColors", "MozBorderEnd", "MozBorderEndColor", "MozBorderEndStyle", "MozBorderEndWidth", "MozBorderImage", "MozBorderLeftColors", "MozBorderRightColors", "MozBorderStart", "MozBorderStartColor", "MozBorderStartStyle", "MozBorderStartWidth", "MozBorderTopColors", "MozBoxAlign", "MozBoxDirection", "MozBoxFlex", "MozBoxOrdinalGroup", "MozBoxOrient", "MozBoxPack", "MozBoxSizing", "MozCSSKeyframeRule", "MozCSSKeyframesRule", "MozColumnCount", "MozColumnFill", "MozColumnGap", "MozColumnRule", "MozColumnRuleColor", "MozColumnRuleStyle", "MozColumnRuleWidth", "MozColumnWidth", "MozColumns", "MozContactChangeEvent", "MozFloatEdge", "MozFontFeatureSettings", "MozFontLanguageOverride", "MozForceBrokenImageIcon", "MozHyphens", "MozImageRegion", "MozMarginEnd", "MozMarginStart", "MozMmsEvent", "MozMmsMessage", "MozMobileMessageThread", "MozOSXFontSmoothing", "MozOrient", "MozOutlineRadius", "MozOutlineRadiusBottomleft", "MozOutlineRadiusBottomright", "MozOutlineRadiusTopleft", "MozOutlineRadiusTopright", "MozPaddingEnd", "MozPaddingStart", "MozPerspective", "MozPerspectiveOrigin", "MozPowerManager", "MozSettingsEvent", "MozSmsEvent", "MozSmsMessage", "MozStackSizing", "MozTabSize", "MozTextAlignLast", "MozTextDecorationColor", "MozTextDecorationLine", "MozTextDecorationStyle", "MozTextSizeAdjust", "MozTransform", "MozTransformOrigin", "MozTransformStyle", "MozTransition", "MozTransitionDelay", "MozTransitionDuration", "MozTransitionProperty", "MozTransitionTimingFunction", "MozUserFocus", "MozUserInput", "MozUserModify", "MozUserSelect", "MozWindowDragging", "MozWindowShadow", "MutationEvent", "MutationObserver", "MutationRecord", "NAMESPACE_ERR", "NAMESPACE_RULE", "NEAREST", "NEAREST_MIPMAP_LINEAR", "NEAREST_MIPMAP_NEAREST", "NEGATIVE_INFINITY", "NETWORK_EMPTY", "NETWORK_ERR", "NETWORK_IDLE", "NETWORK_LOADED", "NETWORK_LOADING", "NETWORK_NO_SOURCE", "NEVER", "NEW", "NEXT", "NEXT_NO_DUPLICATE", "NICEST", "NODE_AFTER", "NODE_BEFORE", "NODE_BEFORE_AND_AFTER", "NODE_INSIDE", "NONE", "NON_TRANSIENT_ERR", "NOTATION_NODE", "NOTCH", "NOTEQUAL", "NOT_ALLOWED_ERR", "NOT_FOUND_ERR", "NOT_READABLE_ERR", "NOT_SUPPORTED_ERR", "NO_DATA_ALLOWED_ERR", "NO_ERR", "NO_ERROR", "NO_MODIFICATION_ALLOWED_ERR", "NUMBER_TYPE", "NUM_COMPRESSED_TEXTURE_FORMATS", "NaN", "NamedNodeMap", "Navigator", "NearbyLinks", "NetworkInformation", "Node", "NodeFilter", "NodeIterator", "NodeList", "Notation", "Notification", "NotifyPaintEvent", "Number", "NumberFormat", "OBSOLETE", "ONE", "ONE_MINUS_CONSTANT_ALPHA", "ONE_MINUS_CONSTANT_COLOR", "ONE_MINUS_DST_ALPHA", "ONE_MINUS_DST_COLOR", "ONE_MINUS_SRC_ALPHA", "ONE_MINUS_SRC_COLOR", "OPEN", "OPENED", "OPENING", "ORDERED_NODE_ITERATOR_TYPE", "ORDERED_NODE_SNAPSHOT_TYPE", "OUT_OF_MEMORY", "Object", "OfflineAudioCompletionEvent", "OfflineAudioContext", "OfflineResourceList", "Option", "OscillatorNode", "OverflowEvent", "PACK_ALIGNMENT", "PAGE_RULE", "PARSE_ERR", "PATHSEG_ARC_ABS", "PATHSEG_ARC_REL", "PATHSEG_CLOSEPATH", "PATHSEG_CURVETO_CUBIC_ABS", "PATHSEG_CURVETO_CUBIC_REL", "PATHSEG_CURVETO_CUBIC_SMOOTH_ABS", "PATHSEG_CURVETO_CUBIC_SMOOTH_REL", "PATHSEG_CURVETO_QUADRATIC_ABS", "PATHSEG_CURVETO_QUADRATIC_REL", "PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS", "PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL", "PATHSEG_LINETO_ABS", "PATHSEG_LINETO_HORIZONTAL_ABS", "PATHSEG_LINETO_HORIZONTAL_REL", "PATHSEG_LINETO_REL", "PATHSEG_LINETO_VERTICAL_ABS", "PATHSEG_LINETO_VERTICAL_REL", "PATHSEG_MOVETO_ABS", "PATHSEG_MOVETO_REL", "PATHSEG_UNKNOWN", "PATH_EXISTS_ERR", "PEAKING", "PERMISSION_DENIED", "PERSISTENT", "PI", "PLAYING_STATE", "POINTS", "POLYGON_OFFSET_FACTOR", "POLYGON_OFFSET_FILL", "POLYGON_OFFSET_UNITS", "POSITION_UNAVAILABLE", "POSITIVE_INFINITY", "PREV", "PREV_NO_DUPLICATE", "PROCESSING_INSTRUCTION_NODE", "PageChangeEvent", "PageTransitionEvent", "PaintRequest", "PaintRequestList", "PannerNode", "Path2D", "Performance", "PerformanceEntry", "PerformanceMark", "PerformanceMeasure", "PerformanceNavigation", "PerformanceResourceTiming", "PerformanceTiming", "PeriodicWave", "Plugin", "PluginArray", "PopStateEvent", "PopupBlockedEvent", "ProcessingInstruction", "ProgressEvent", "Promise", "PropertyNodeList", "Proxy", "PushManager", "PushSubscription", "Q", "QUOTA_ERR", "QUOTA_EXCEEDED_ERR", "QueryInterface", "READ_ONLY", "READ_ONLY_ERR", "READ_WRITE", "RED_BITS", "REMOVAL", "RENDERBUFFER", "RENDERBUFFER_ALPHA_SIZE", "RENDERBUFFER_BINDING", "RENDERBUFFER_BLUE_SIZE", "RENDERBUFFER_DEPTH_SIZE", "RENDERBUFFER_GREEN_SIZE", "RENDERBUFFER_HEIGHT", "RENDERBUFFER_INTERNAL_FORMAT", "RENDERBUFFER_RED_SIZE", "RENDERBUFFER_STENCIL_SIZE", "RENDERBUFFER_WIDTH", "RENDERER", "RENDERING_INTENT_ABSOLUTE_COLORIMETRIC", "RENDERING_INTENT_AUTO", "RENDERING_INTENT_PERCEPTUAL", "RENDERING_INTENT_RELATIVE_COLORIMETRIC", "RENDERING_INTENT_SATURATION", "RENDERING_INTENT_UNKNOWN", "REPEAT", "REPLACE", "RGB", "RGB565", "RGB5_A1", "RGBA", "RGBA4", "RGBColor", "ROTATION_CLOCKWISE", "ROTATION_COUNTERCLOCKWISE", "RTCDataChannelEvent", "RTCIceCandidate", "RTCPeerConnectionIceEvent", "RTCRtpReceiver", "RTCRtpSender", "RTCSessionDescription", "RTCStatsReport", "RadioNodeList", "Range", "RangeError", "RangeException", "RecordErrorEvent", "Rect", "ReferenceError", "RegExp", "Request", "Response", "SAMPLER_2D", "SAMPLER_CUBE", "SAMPLES", "SAMPLE_ALPHA_TO_COVERAGE", "SAMPLE_BUFFERS", "SAMPLE_COVERAGE", "SAMPLE_COVERAGE_INVERT", "SAMPLE_COVERAGE_VALUE", "SAWTOOTH", "SCHEDULED_STATE", "SCISSOR_BOX", "SCISSOR_TEST", "SCROLL_PAGE_DOWN", "SCROLL_PAGE_UP", "SDP_ANSWER", "SDP_OFFER", "SDP_PRANSWER", "SECURITY_ERR", "SELECT", "SERIALIZE_ERR", "SEVERITY_ERROR", "SEVERITY_FATAL_ERROR", "SEVERITY_WARNING", "SHADER_COMPILER", "SHADER_TYPE", "SHADING_LANGUAGE_VERSION", "SHIFT_MASK", "SHORT", "SHOWING", "SHOW_ALL", "SHOW_ATTRIBUTE", "SHOW_CDATA_SECTION", "SHOW_COMMENT", "SHOW_DOCUMENT", "SHOW_DOCUMENT_FRAGMENT", "SHOW_DOCUMENT_TYPE", "SHOW_ELEMENT", "SHOW_ENTITY", "SHOW_ENTITY_REFERENCE", "SHOW_NOTATION", "SHOW_PROCESSING_INSTRUCTION", "SHOW_TEXT", "SINE", "SOUNDFIELD", "SQLException", "SQRT1_2", "SQRT2", "SQUARE", "SRC_ALPHA", "SRC_ALPHA_SATURATE", "SRC_COLOR", "START_TO_END", "START_TO_START", "STATIC_DRAW", "STENCIL_ATTACHMENT", "STENCIL_BACK_FAIL", "STENCIL_BACK_FUNC", "STENCIL_BACK_PASS_DEPTH_FAIL", "STENCIL_BACK_PASS_DEPTH_PASS", "STENCIL_BACK_REF", "STENCIL_BACK_VALUE_MASK", "STENCIL_BACK_WRITEMASK", "STENCIL_BITS", "STENCIL_BUFFER_BIT", "STENCIL_CLEAR_VALUE", "STENCIL_FAIL", "STENCIL_FUNC", "STENCIL_INDEX", "STENCIL_INDEX8", "STENCIL_PASS_DEPTH_FAIL", "STENCIL_PASS_DEPTH_PASS", "STENCIL_REF", "STENCIL_TEST", "STENCIL_VALUE_MASK", "STENCIL_WRITEMASK", "STREAM_DRAW", "STRING_TYPE", "STYLE_RULE", "SUBPIXEL_BITS", "SUPPORTS_RULE", "SVGAElement", "SVGAltGlyphDefElement", "SVGAltGlyphElement", "SVGAltGlyphItemElement", "SVGAngle", "SVGAnimateColorElement", "SVGAnimateElement", "SVGAnimateMotionElement", "SVGAnimateTransformElement", "SVGAnimatedAngle", "SVGAnimatedBoolean", "SVGAnimatedEnumeration", "SVGAnimatedInteger", "SVGAnimatedLength", "SVGAnimatedLengthList", "SVGAnimatedNumber", "SVGAnimatedNumberList", "SVGAnimatedPreserveAspectRatio", "SVGAnimatedRect", "SVGAnimatedString", "SVGAnimatedTransformList", "SVGAnimationElement", "SVGCircleElement", "SVGClipPathElement", "SVGColor", "SVGComponentTransferFunctionElement", "SVGCursorElement", "SVGDefsElement", "SVGDescElement", "SVGDiscardElement", "SVGDocument", "SVGElement", "SVGElementInstance", "SVGElementInstanceList", "SVGEllipseElement", "SVGException", "SVGFEBlendElement", "SVGFEColorMatrixElement", "SVGFEComponentTransferElement", "SVGFECompositeElement", "SVGFEConvolveMatrixElement", "SVGFEDiffuseLightingElement", "SVGFEDisplacementMapElement", "SVGFEDistantLightElement", "SVGFEDropShadowElement", "SVGFEFloodElement", "SVGFEFuncAElement", "SVGFEFuncBElement", "SVGFEFuncGElement", "SVGFEFuncRElement", "SVGFEGaussianBlurElement", "SVGFEImageElement", "SVGFEMergeElement", "SVGFEMergeNodeElement", "SVGFEMorphologyElement", "SVGFEOffsetElement", "SVGFEPointLightElement", "SVGFESpecularLightingElement", "SVGFESpotLightElement", "SVGFETileElement", "SVGFETurbulenceElement", "SVGFilterElement", "SVGFontElement", "SVGFontFaceElement", "SVGFontFaceFormatElement", "SVGFontFaceNameElement", "SVGFontFaceSrcElement", "SVGFontFaceUriElement", "SVGForeignObjectElement", "SVGGElement", "SVGGeometryElement", "SVGGlyphElement", "SVGGlyphRefElement", "SVGGradientElement", "SVGGraphicsElement", "SVGHKernElement", "SVGImageElement", "SVGLength", "SVGLengthList", "SVGLineElement", "SVGLinearGradientElement", "SVGMPathElement", "SVGMarkerElement", "SVGMaskElement", "SVGMatrix", "SVGMetadataElement", "SVGMissingGlyphElement", "SVGNumber", "SVGNumberList", "SVGPaint", "SVGPathElement", "SVGPathSeg", "SVGPathSegArcAbs", "SVGPathSegArcRel", "SVGPathSegClosePath", "SVGPathSegCurvetoCubicAbs", "SVGPathSegCurvetoCubicRel", "SVGPathSegCurvetoCubicSmoothAbs", "SVGPathSegCurvetoCubicSmoothRel", "SVGPathSegCurvetoQuadraticAbs", "SVGPathSegCurvetoQuadraticRel", "SVGPathSegCurvetoQuadraticSmoothAbs", "SVGPathSegCurvetoQuadraticSmoothRel", "SVGPathSegLinetoAbs", "SVGPathSegLinetoHorizontalAbs", "SVGPathSegLinetoHorizontalRel", "SVGPathSegLinetoRel", "SVGPathSegLinetoVerticalAbs", "SVGPathSegLinetoVerticalRel", "SVGPathSegList", "SVGPathSegMovetoAbs", "SVGPathSegMovetoRel", "SVGPatternElement", "SVGPoint", "SVGPointList", "SVGPolygonElement", "SVGPolylineElement", "SVGPreserveAspectRatio", "SVGRadialGradientElement", "SVGRect", "SVGRectElement", "SVGRenderingIntent", "SVGSVGElement", "SVGScriptElement", "SVGSetElement", "SVGStopElement", "SVGStringList", "SVGStyleElement", "SVGSwitchElement", "SVGSymbolElement", "SVGTRefElement", "SVGTSpanElement", "SVGTextContentElement", "SVGTextElement", "SVGTextPathElement", "SVGTextPositioningElement", "SVGTitleElement", "SVGTransform", "SVGTransformList", "SVGUnitTypes", "SVGUseElement", "SVGVKernElement", "SVGViewElement", "SVGViewSpec", "SVGZoomAndPan", "SVGZoomEvent", "SVG_ANGLETYPE_DEG", "SVG_ANGLETYPE_GRAD", "SVG_ANGLETYPE_RAD", "SVG_ANGLETYPE_UNKNOWN", "SVG_ANGLETYPE_UNSPECIFIED", "SVG_CHANNEL_A", "SVG_CHANNEL_B", "SVG_CHANNEL_G", "SVG_CHANNEL_R", "SVG_CHANNEL_UNKNOWN", "SVG_COLORTYPE_CURRENTCOLOR", "SVG_COLORTYPE_RGBCOLOR", "SVG_COLORTYPE_RGBCOLOR_ICCCOLOR", "SVG_COLORTYPE_UNKNOWN", "SVG_EDGEMODE_DUPLICATE", "SVG_EDGEMODE_NONE", "SVG_EDGEMODE_UNKNOWN", "SVG_EDGEMODE_WRAP", "SVG_FEBLEND_MODE_COLOR", "SVG_FEBLEND_MODE_COLOR_BURN", "SVG_FEBLEND_MODE_COLOR_DODGE", "SVG_FEBLEND_MODE_DARKEN", "SVG_FEBLEND_MODE_DIFFERENCE", "SVG_FEBLEND_MODE_EXCLUSION", "SVG_FEBLEND_MODE_HARD_LIGHT", "SVG_FEBLEND_MODE_HUE", "SVG_FEBLEND_MODE_LIGHTEN", "SVG_FEBLEND_MODE_LUMINOSITY", "SVG_FEBLEND_MODE_MULTIPLY", "SVG_FEBLEND_MODE_NORMAL", "SVG_FEBLEND_MODE_OVERLAY", "SVG_FEBLEND_MODE_SATURATION", "SVG_FEBLEND_MODE_SCREEN", "SVG_FEBLEND_MODE_SOFT_LIGHT", "SVG_FEBLEND_MODE_UNKNOWN", "SVG_FECOLORMATRIX_TYPE_HUEROTATE", "SVG_FECOLORMATRIX_TYPE_LUMINANCETOALPHA", "SVG_FECOLORMATRIX_TYPE_MATRIX", "SVG_FECOLORMATRIX_TYPE_SATURATE", "SVG_FECOLORMATRIX_TYPE_UNKNOWN", "SVG_FECOMPONENTTRANSFER_TYPE_DISCRETE", "SVG_FECOMPONENTTRANSFER_TYPE_GAMMA", "SVG_FECOMPONENTTRANSFER_TYPE_IDENTITY", "SVG_FECOMPONENTTRANSFER_TYPE_LINEAR", "SVG_FECOMPONENTTRANSFER_TYPE_TABLE", "SVG_FECOMPONENTTRANSFER_TYPE_UNKNOWN", "SVG_FECOMPOSITE_OPERATOR_ARITHMETIC", "SVG_FECOMPOSITE_OPERATOR_ATOP", "SVG_FECOMPOSITE_OPERATOR_IN", "SVG_FECOMPOSITE_OPERATOR_OUT", "SVG_FECOMPOSITE_OPERATOR_OVER", "SVG_FECOMPOSITE_OPERATOR_UNKNOWN", "SVG_FECOMPOSITE_OPERATOR_XOR", "SVG_INVALID_VALUE_ERR", "SVG_LENGTHTYPE_CM", "SVG_LENGTHTYPE_EMS", "SVG_LENGTHTYPE_EXS", "SVG_LENGTHTYPE_IN", "SVG_LENGTHTYPE_MM", "SVG_LENGTHTYPE_NUMBER", "SVG_LENGTHTYPE_PC", "SVG_LENGTHTYPE_PERCENTAGE", "SVG_LENGTHTYPE_PT", "SVG_LENGTHTYPE_PX", "SVG_LENGTHTYPE_UNKNOWN", "SVG_MARKERUNITS_STROKEWIDTH", "SVG_MARKERUNITS_UNKNOWN", "SVG_MARKERUNITS_USERSPACEONUSE", "SVG_MARKER_ORIENT_ANGLE", "SVG_MARKER_ORIENT_AUTO", "SVG_MARKER_ORIENT_UNKNOWN", "SVG_MASKTYPE_ALPHA", "SVG_MASKTYPE_LUMINANCE", "SVG_MATRIX_NOT_INVERTABLE", "SVG_MEETORSLICE_MEET", "SVG_MEETORSLICE_SLICE", "SVG_MEETORSLICE_UNKNOWN", "SVG_MORPHOLOGY_OPERATOR_DILATE", "SVG_MORPHOLOGY_OPERATOR_ERODE", "SVG_MORPHOLOGY_OPERATOR_UNKNOWN", "SVG_PAINTTYPE_CURRENTCOLOR", "SVG_PAINTTYPE_NONE", "SVG_PAINTTYPE_RGBCOLOR", "SVG_PAINTTYPE_RGBCOLOR_ICCCOLOR", "SVG_PAINTTYPE_UNKNOWN", "SVG_PAINTTYPE_URI", "SVG_PAINTTYPE_URI_CURRENTCOLOR", "SVG_PAINTTYPE_URI_NONE", "SVG_PAINTTYPE_URI_RGBCOLOR", "SVG_PAINTTYPE_URI_RGBCOLOR_ICCCOLOR", "SVG_PRESERVEASPECTRATIO_NONE", "SVG_PRESERVEASPECTRATIO_UNKNOWN", "SVG_PRESERVEASPECTRATIO_XMAXYMAX", "SVG_PRESERVEASPECTRATIO_XMAXYMID", "SVG_PRESERVEASPECTRATIO_XMAXYMIN", "SVG_PRESERVEASPECTRATIO_XMIDYMAX", "SVG_PRESERVEASPECTRATIO_XMIDYMID", "SVG_PRESERVEASPECTRATIO_XMIDYMIN", "SVG_PRESERVEASPECTRATIO_XMINYMAX", "SVG_PRESERVEASPECTRATIO_XMINYMID", "SVG_PRESERVEASPECTRATIO_XMINYMIN", "SVG_SPREADMETHOD_PAD", "SVG_SPREADMETHOD_REFLECT", "SVG_SPREADMETHOD_REPEAT", "SVG_SPREADMETHOD_UNKNOWN", "SVG_STITCHTYPE_NOSTITCH", "SVG_STITCHTYPE_STITCH", "SVG_STITCHTYPE_UNKNOWN", "SVG_TRANSFORM_MATRIX", "SVG_TRANSFORM_ROTATE", "SVG_TRANSFORM_SCALE", "SVG_TRANSFORM_SKEWX", "SVG_TRANSFORM_SKEWY", "SVG_TRANSFORM_TRANSLATE", "SVG_TRANSFORM_UNKNOWN", "SVG_TURBULENCE_TYPE_FRACTALNOISE", "SVG_TURBULENCE_TYPE_TURBULENCE", "SVG_TURBULENCE_TYPE_UNKNOWN", "SVG_UNIT_TYPE_OBJECTBOUNDINGBOX", "SVG_UNIT_TYPE_UNKNOWN", "SVG_UNIT_TYPE_USERSPACEONUSE", "SVG_WRONG_TYPE_ERR", "SVG_ZOOMANDPAN_DISABLE", "SVG_ZOOMANDPAN_MAGNIFY", "SVG_ZOOMANDPAN_UNKNOWN", "SYNTAX_ERR", "SavedPages", "Screen", "ScreenOrientation", "Script", "ScriptProcessorNode", "ScrollAreaEvent", "SecurityPolicyViolationEvent", "Selection", "ServiceWorker", "ServiceWorkerContainer", "ServiceWorkerRegistration", "SessionDescription", "Set", "ShadowRoot", "SharedWorker", "SimpleGestureEvent", "SpeechSynthesisEvent", "SpeechSynthesisUtterance", "StopIteration", "Storage", "StorageEvent", "String", "StyleSheet", "StyleSheetList", "SubtleCrypto", "Symbol", "SyntaxError", "TEMPORARY", "TEXTPATH_METHODTYPE_ALIGN", "TEXTPATH_METHODTYPE_STRETCH", "TEXTPATH_METHODTYPE_UNKNOWN", "TEXTPATH_SPACINGTYPE_AUTO", "TEXTPATH_SPACINGTYPE_EXACT", "TEXTPATH_SPACINGTYPE_UNKNOWN", "TEXTURE", "TEXTURE0", "TEXTURE1", "TEXTURE10", "TEXTURE11", "TEXTURE12", "TEXTURE13", "TEXTURE14", "TEXTURE15", "TEXTURE16", "TEXTURE17", "TEXTURE18", "TEXTURE19", "TEXTURE2", "TEXTURE20", "TEXTURE21", "TEXTURE22", "TEXTURE23", "TEXTURE24", "TEXTURE25", "TEXTURE26", "TEXTURE27", "TEXTURE28", "TEXTURE29", "TEXTURE3", "TEXTURE30", "TEXTURE31", "TEXTURE4", "TEXTURE5", "TEXTURE6", "TEXTURE7", "TEXTURE8", "TEXTURE9", "TEXTURE_2D", "TEXTURE_BINDING_2D", "TEXTURE_BINDING_CUBE_MAP", "TEXTURE_CUBE_MAP", "TEXTURE_CUBE_MAP_NEGATIVE_X", "TEXTURE_CUBE_MAP_NEGATIVE_Y", "TEXTURE_CUBE_MAP_NEGATIVE_Z", "TEXTURE_CUBE_MAP_POSITIVE_X", "TEXTURE_CUBE_MAP_POSITIVE_Y", "TEXTURE_CUBE_MAP_POSITIVE_Z", "TEXTURE_MAG_FILTER", "TEXTURE_MAX_ANISOTROPY_EXT", "TEXTURE_MIN_FILTER", "TEXTURE_WRAP_S", "TEXTURE_WRAP_T", "TEXT_NODE", "TIMEOUT", "TIMEOUT_ERR", "TOO_LARGE_ERR", "TRANSACTION_INACTIVE_ERR", "TRIANGLE", "TRIANGLES", "TRIANGLE_FAN", "TRIANGLE_STRIP", "TYPE_BACK_FORWARD", "TYPE_ERR", "TYPE_MISMATCH_ERR", "TYPE_NAVIGATE", "TYPE_RELOAD", "TYPE_RESERVED", "Text", "TextDecoder", "TextEncoder", "TextEvent", "TextMetrics", "TextTrack", "TextTrackCue", "TextTrackCueList", "TextTrackList", "TimeEvent", "TimeRanges", "Touch", "TouchEvent", "TouchList", "TrackEvent", "TransitionEvent", "TreeWalker", "TypeError", "UIEvent", "UNCACHED", "UNKNOWN_ERR", "UNKNOWN_RULE", "UNMASKED_RENDERER_WEBGL", "UNMASKED_VENDOR_WEBGL", "UNORDERED_NODE_ITERATOR_TYPE", "UNORDERED_NODE_SNAPSHOT_TYPE", "UNPACK_ALIGNMENT", "UNPACK_COLORSPACE_CONVERSION_WEBGL", "UNPACK_FLIP_Y_WEBGL", "UNPACK_PREMULTIPLY_ALPHA_WEBGL", "UNSCHEDULED_STATE", "UNSENT", "UNSIGNED_BYTE", "UNSIGNED_INT", "UNSIGNED_SHORT", "UNSIGNED_SHORT_4_4_4_4", "UNSIGNED_SHORT_5_5_5_1", "UNSIGNED_SHORT_5_6_5", "UNSPECIFIED_EVENT_TYPE_ERR", "UPDATEREADY", "URIError", "URL", "URLSearchParams", "URLUnencoded", "URL_MISMATCH_ERR", "UTC", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray", "UserMessageHandler", "UserMessageHandlersNamespace", "UserProximityEvent", "VALIDATE_STATUS", "VALIDATION_ERR", "VARIABLES_RULE", "VENDOR", "VERSION", "VERSION_CHANGE", "VERSION_ERR", "VERTEX_ATTRIB_ARRAY_BUFFER_BINDING", "VERTEX_ATTRIB_ARRAY_DIVISOR_ANGLE", "VERTEX_ATTRIB_ARRAY_ENABLED", "VERTEX_ATTRIB_ARRAY_NORMALIZED", "VERTEX_ATTRIB_ARRAY_POINTER", "VERTEX_ATTRIB_ARRAY_SIZE", "VERTEX_ATTRIB_ARRAY_STRIDE", "VERTEX_ATTRIB_ARRAY_TYPE", "VERTEX_SHADER", "VERTICAL", "VERTICAL_AXIS", "VER_ERR", "VIEWPORT", "VIEWPORT_RULE", "VTTCue", "VTTRegion", "ValidityState", "VideoStreamTrack", "WEBKIT_FILTER_RULE", "WEBKIT_KEYFRAMES_RULE", "WEBKIT_KEYFRAME_RULE", "WEBKIT_REGION_RULE", "WRONG_DOCUMENT_ERR", "WaveShaperNode", "WeakMap", "WeakSet", "WebGLActiveInfo", "WebGLBuffer", "WebGLContextEvent", "WebGLFramebuffer", "WebGLProgram", "WebGLRenderbuffer", "WebGLRenderingContext", "WebGLShader", "WebGLShaderPrecisionFormat", "WebGLTexture", "WebGLUniformLocation", "WebGLVertexArray", "WebKitAnimationEvent", "WebKitBlobBuilder", "WebKitCSSFilterRule", "WebKitCSSFilterValue", "WebKitCSSKeyframeRule", "WebKitCSSKeyframesRule", "WebKitCSSMatrix", "WebKitCSSRegionRule", "WebKitCSSTransformValue", "WebKitDataCue", "WebKitGamepad", "WebKitMediaKeyError", "WebKitMediaKeyMessageEvent", "WebKitMediaKeySession", "WebKitMediaKeys", "WebKitMediaSource", "WebKitMutationObserver", "WebKitNamespace", "WebKitPlaybackTargetAvailabilityEvent", "WebKitPoint", "WebKitShadowRoot", "WebKitSourceBuffer", "WebKitSourceBufferList", "WebKitTransitionEvent", "WebSocket", "WheelEvent", "Window", "Worker", "XMLDocument", "XMLHttpRequest", "XMLHttpRequestEventTarget", "XMLHttpRequestException", "XMLHttpRequestProgressEvent", "XMLHttpRequestUpload", "XMLSerializer", "XMLStylesheetProcessingInstruction", "XPathEvaluator", "XPathException", "XPathExpression", "XPathNSResolver", "XPathResult", "XSLTProcessor", "ZERO", "_XD0M_", "_YD0M_", "__defineGetter__", "__defineSetter__", "__lookupGetter__", "__lookupSetter__", "__opera", "__proto__", "_browserjsran", "a", "aLink", "abbr", "abort", "abs", "absolute", "acceleration", "accelerationIncludingGravity", "accelerator", "accept", "acceptCharset", "acceptNode", "accessKey", "accessKeyLabel", "accuracy", "acos", "acosh", "action", "actionURL", "active", "activeCues", "activeElement", "activeSourceBuffers", "activeSourceCount", "activeTexture", "add", "addBehavior", "addCandidate", "addColorStop", "addCue", "addElement", "addEventListener", "addFilter", "addFromString", "addFromUri", "addIceCandidate", "addImport", "addListener", "addNamed", "addPageRule", "addPath", "addPointer", "addRange", "addRegion", "addRule", "addSearchEngine", "addSourceBuffer", "addStream", "addTextTrack", "addTrack", "addWakeLockListener", "addedNodes", "additionalName", "additiveSymbols", "addons", "adoptNode", "adr", "advance", "alert", "algorithm", "align", "align-content", "align-items", "align-self", "alignContent", "alignItems", "alignSelf", "alignmentBaseline", "alinkColor", "all", "allSettled", "allowFullscreen", "allowedDirections", "alpha", "alt", "altGraphKey", "altHtml", "altKey", "altLeft", "altitude", "altitudeAccuracy", "amplitude", "ancestorOrigins", "anchor", "anchorNode", "anchorOffset", "anchors", "angle", "animVal", "animate", "animatedInstanceRoot", "animatedNormalizedPathSegList", "animatedPathSegList", "animatedPoints", "animation", "animation-delay", "animation-direction", "animation-duration", "animation-fill-mode", "animation-iteration-count", "animation-name", "animation-play-state", "animation-timing-function", "animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationStartTime", "animationTimingFunction", "animationsPaused", "anniversary", "any", "app", "appCodeName", "appMinorVersion", "appName", "appNotifications", "appVersion", "append", "appendBuffer", "appendChild", "appendData", "appendItem", "appendMedium", "appendNamed", "appendRule", "appendStream", "appendWindowEnd", "appendWindowStart", "applets", "applicationCache", "apply", "applyElement", "arc", "arcTo", "archive", "areas", "arguments", "arrayBuffer", "asin", "asinh", "assert", "assign", "async", "atEnd", "atan", "atan2", "atanh", "atob", "attachEvent", "attachShader", "attachShadow", "attachments", "attack", "attrChange", "attrName", "attributeFilter", "attributeName", "attributeNamespace", "attributeOldValue", "attributes", "audioTracks", "autoIncrement", "autobuffer", "autocapitalize", "autocomplete", "autocorrect", "autofocus", "autoplay", "availHeight", "availLeft", "availTop", "availWidth", "availability", "available", "aversion", "axes", "axis", "azimuth", "b", "back", "backface-visibility", "backfaceVisibility", "background", "background-attachment", "background-blend-mode", "background-clip", "background-color", "background-image", "background-origin", "background-position", "background-repeat", "background-size", "backgroundAttachment", "backgroundBlendMode", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPosition", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize", "badInput", "balance", "baseFrequencyX", "baseFrequencyY", "baseNode", "baseOffset", "baseURI", "baseVal", "baselineShift", "battery", "bday", "beginElement", "beginElementAt", "beginPath", "behavior", "behaviorCookie", "behaviorPart", "behaviorUrns", "beta", "bezierCurveTo", "bgColor", "bgProperties", "bias", "big", "binaryType", "bind", "bindAttribLocation", "bindBuffer", "bindFramebuffer", "bindRenderbuffer", "bindTexture", "blendColor", "blendEquation", "blendEquationSeparate", "blendFunc", "blendFuncSeparate", "blink", "blob", "blockDirection", "blue", "blur", "body", "bodyUsed", "bold", "bookmarks", "booleanValue", "border", "border-bottom", "border-bottom-color", "border-bottom-left-radius", "border-bottom-right-radius", "border-bottom-style", "border-bottom-width", "border-collapse", "border-color", "border-image", "border-image-outset", "border-image-repeat", "border-image-slice", "border-image-source", "border-image-width", "border-left", "border-left-color", "border-left-style", "border-left-width", "border-radius", "border-right", "border-right-color", "border-right-style", "border-right-width", "border-spacing", "border-style", "border-top", "border-top-color", "border-top-left-radius", "border-top-right-radius", "border-top-style", "border-top-width", "border-width", "borderBottom", "borderBottomColor", "borderBottomLeftRadius", "borderBottomRightRadius", "borderBottomStyle", "borderBottomWidth", "borderCollapse", "borderColor", "borderColorDark", "borderColorLight", "borderImage", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeft", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRadius", "borderRight", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderSpacing", "borderStyle", "borderTop", "borderTopColor", "borderTopLeftRadius", "borderTopRightRadius", "borderTopStyle", "borderTopWidth", "borderWidth", "bottom", "bottomMargin", "bound", "boundElements", "boundingClientRect", "boundingHeight", "boundingLeft", "boundingTop", "boundingWidth", "bounds", "box-decoration-break", "box-shadow", "box-sizing", "boxDecorationBreak", "boxShadow", "boxSizing", "breakAfter", "breakBefore", "breakInside", "browserLanguage", "btoa", "bubbles", "buffer", "bufferData", "bufferDepth", "bufferSize", "bufferSubData", "buffered", "bufferedAmount", "buildID", "buildNumber", "button", "buttonID", "buttons", "byteLength", "byteOffset", "c", "call", "caller", "canBeFormatted", "canBeMounted", "canBeShared", "canHaveChildren", "canHaveHTML", "canPlayType", "cancel", "cancelAnimationFrame", "cancelBubble", "cancelScheduledValues", "cancelable", "candidate", "canvas", "caption", "caption-side", "captionSide", "capture", "captureEvents", "captureStackTrace", "caretPositionFromPoint", "caretRangeFromPoint", "cast", "catch", "category", "cbrt", "cd", "ceil", "cellIndex", "cellPadding", "cellSpacing", "cells", "ch", "chOff", "chain", "challenge", "changedTouches", "channel", "channelCount", "channelCountMode", "channelInterpretation", "char", "charAt", "charCode", "charCodeAt", "charIndex", "characterSet", "characterData", "characterDataOldValue", "charging", "chargingTime", "charset", "checkEnclosure", "checkFramebufferStatus", "checkIntersection", "checkValidity", "checked", "childElementCount", "childList", "childNodes", "children", "chrome", "ciphertext", "cite", "classList", "className", "classid", "clear", "clearAttributes", "clearColor", "clearData", "clearDepth", "clearImmediate", "clearInterval", "clearMarks", "clearMeasures", "clearParameters", "clearRect", "clearResourceTimings", "clearShadow", "clearStencil", "clearTimeout", "clearWatch", "click", "clickCount", "clientHeight", "clientInformation", "clientLeft", "clientRect", "clientRects", "clientTop", "clientWidth", "clientX", "clientY", "clip", "clip-path", "clip-rule", "clipBottom", "clipLeft", "clipPath", "clipPathUnits", "clipRight", "clipRule", "clipTop", "clipboardData", "clone", "cloneContents", "cloneNode", "cloneRange", "close", "closePath", "closed", "closest", "clz", "clz32", "cmp", "code", "codeBase", "codePointAt", "codeType", "colSpan", "collapse", "collapseToEnd", "collapseToStart", "collapsed", "collect", "colno", "color", "color-interpolation", "color-interpolation-filters", "colorDepth", "colorInterpolation", "colorInterpolationFilters", "colorMask", "colorType", "cols", "columnCount", "columnFill", "columnGap", "columnNumber", "columnRule", "columnRuleColor", "columnRuleStyle", "columnRuleWidth", "columnSpan", "columnWidth", "columns", "command", "commitPreferences", "commonAncestorContainer", "compact", "compareBoundaryPoints", "compareDocumentPosition", "compareEndPoints", "compareNode", "comparePoint", "compatMode", "compatible", "compile", "compileShader", "complete", "componentFromPoint", "compositionEndOffset", "compositionStartOffset", "compressedTexImage2D", "compressedTexSubImage2D", "concat", "conditionText", "coneInnerAngle", "coneOuterAngle", "coneOuterGain", "confirm", "confirmComposition", "confirmSiteSpecificTrackingException", "confirmWebWideTrackingException", "connect", "connectEnd", "connectStart", "connected", "connection", "connectionSpeed", "console", "consolidate", "constrictionActive", "constructor", "contactID", "contains", "containsNode", "content", "contentDocument", "contentEditable", "contentOverflow", "contentScriptType", "contentStyleType", "contentType", "contentWindow", "context", "contextMenu", "contextmenu", "continue", "continuous", "control", "controller", "controls", "convertToSpecifiedUnits", "cookie", "cookieEnabled", "coords", "copyFromChannel", "copyTexImage2D", "copyTexSubImage2D", "copyToChannel", "copyWithin", "correspondingElement", "correspondingUseElement", "cos", "cosh", "count", "counter-increment", "counter-reset", "counterIncrement", "counterReset", "cpuClass", "cpuSleepAllowed", "create", "createAnalyser", "createAnswer", "createAttribute", "createAttributeNS", "createBiquadFilter", "createBuffer", "createBufferSource", "createCDATASection", "createCSSStyleSheet", "createCaption", "createChannelMerger", "createChannelSplitter", "createComment", "createContextualFragment", "createControlRange", "createConvolver", "createDTMFSender", "createDataChannel", "createDelay", "createDelayNode", "createDocument", "createDocumentFragment", "createDocumentType", "createDynamicsCompressor", "createElement", "createElementNS", "createEntityReference", "createEvent", "createEventObject", "createExpression", "createFramebuffer", "createFunction", "createGain", "createGainNode", "createHTMLDocument", "createImageBitmap", "createImageData", "createIndex", "createJavaScriptNode", "createLinearGradient", "createMediaElementSource", "createMediaKeys", "createMediaStreamDestination", "createMediaStreamSource", "createMutableFile", "createNSResolver", "createNodeIterator", "createNotification", "createObjectStore", "createObjectURL", "createOffer", "createOscillator", "createPanner", "createPattern", "createPeriodicWave", "createPopup", "createProcessingInstruction", "createProgram", "createRadialGradient", "createRange", "createRangeCollection", "createRenderbuffer", "createSVGAngle", "createSVGLength", "createSVGMatrix", "createSVGNumber", "createSVGPathSegArcAbs", "createSVGPathSegArcRel", "createSVGPathSegClosePath", "createSVGPathSegCurvetoCubicAbs", "createSVGPathSegCurvetoCubicRel", "createSVGPathSegCurvetoCubicSmoothAbs", "createSVGPathSegCurvetoCubicSmoothRel", "createSVGPathSegCurvetoQuadraticAbs", "createSVGPathSegCurvetoQuadraticRel", "createSVGPathSegCurvetoQuadraticSmoothAbs", "createSVGPathSegCurvetoQuadraticSmoothRel", "createSVGPathSegLinetoAbs", "createSVGPathSegLinetoHorizontalAbs", "createSVGPathSegLinetoHorizontalRel", "createSVGPathSegLinetoRel", "createSVGPathSegLinetoVerticalAbs", "createSVGPathSegLinetoVerticalRel", "createSVGPathSegMovetoAbs", "createSVGPathSegMovetoRel", "createSVGPoint", "createSVGRect", "createSVGTransform", "createSVGTransformFromMatrix", "createScriptProcessor", "createSession", "createShader", "createShadowRoot", "createStereoPanner", "createStyleSheet", "createTBody", "createTFoot", "createTHead", "createTextNode", "createTextRange", "createTexture", "createTouch", "createTouchList", "createTreeWalker", "createWaveShaper", "creationTime", "crossOrigin", "crypto", "csi", "cssFloat", "cssRules", "cssText", "cssValueType", "ctrlKey", "ctrlLeft", "cues", "cullFace", "currentNode", "currentPage", "currentScale", "currentScript", "currentSrc", "currentState", "currentStyle", "currentTarget", "currentTime", "currentTranslate", "currentView", "cursor", "curve", "customError", "cx", "cy", "d", "data", "dataFld", "dataFormatAs", "dataPageSize", "dataSrc", "dataTransfer", "database", "dataset", "dateTime", "db", "debug", "debuggerEnabled", "declare", "decode", "decodeAudioData", "decodingInfo", "decodeURI", "decodeURIComponent", "decrypt", "default", "defaultCharset", "defaultChecked", "defaultMuted", "defaultPlaybackRate", "defaultPrevented", "defaultSelected", "defaultStatus", "defaultURL", "defaultValue", "defaultView", "defaultstatus", "defer", "defineMagicFunction", "defineMagicVariable", "defineProperties", "defineProperty", "delayTime", "delete", "deleteBuffer", "deleteCaption", "deleteCell", "deleteContents", "deleteData", "deleteDatabase", "deleteFramebuffer", "deleteFromDocument", "deleteIndex", "deleteMedium", "deleteObjectStore", "deleteProgram", "deleteRenderbuffer", "deleteRow", "deleteRule", "deleteShader", "deleteTFoot", "deleteTHead", "deleteTexture", "deliverChangeRecords", "delivery", "deliveryInfo", "deliveryStatus", "deliveryTimestamp", "delta", "deltaMode", "deltaX", "deltaY", "deltaZ", "depthFunc", "depthMask", "depthRange", "deriveBits", "deriveKey", "description", "deselectAll", "designMode", "destination", "destinationURL", "detach", "detachEvent", "detachShader", "detail", "detune", "devicePixelRatio", "deviceXDPI", "deviceYDPI", "diffuseConstant", "digest", "dimensions", "dir", "dirName", "direction", "dirxml", "disable", "disableVertexAttribArray", "disabled", "dischargingTime", "disconnect", "dispatchEvent", "display", "distanceModel", "divisor", "djsapi", "djsproxy", "doImport", "doNotTrack", "doScroll", "doctype", "document", "documentElement", "documentMode", "documentURI", "dolphin", "dolphinGameCenter", "dolphininfo", "dolphinmeta", "domComplete", "domContentLoadedEventEnd", "domContentLoadedEventStart", "domInteractive", "domLoading", "domain", "domainLookupEnd", "domainLookupStart", "dominant-baseline", "dominantBaseline", "done", "dopplerFactor", "download", "dragDrop", "draggable", "drawArrays", "drawArraysInstancedANGLE", "drawCustomFocusRing", "drawElements", "drawElementsInstancedANGLE", "drawFocusIfNeeded", "drawImage", "drawImageFromRect", "drawSystemFocusRing", "drawingBufferHeight", "drawingBufferWidth", "dropEffect", "droppedVideoFrames", "dropzone", "dump", "duplicate", "duration", "dvname", "dvnum", "dx", "dy", "dynsrc", "e", "edgeMode", "effectAllowed", "elapsedTime", "elementFromPoint", "elements", "elevation", "ellipse", "email", "embeds", "empty", "empty-cells", "emptyCells", "enable", "enableBackground", "enableStyleSheetsForSet", "enableVertexAttribArray", "enabled", "enabledPlugin", "encode", "encodeURI", "encodeURIComponent", "encoding", "encrypt", "enctype", "end", "endContainer", "endElement", "endElementAt", "endOfStream", "endOffset", "endTime", "ended", "endsWith", "entities", "entries", "entryType", "enumerate", "enumerateEditable", "error", "errorCode", "escape", "eval", "evaluate", "event", "eventPhase", "every", "exception", "exec", "execCommand", "execCommandShowHelp", "execScript", "exitFullscreen", "exitPointerLock", "exp", "expand", "expandEntityReferences", "expando", "expansion", "expiryDate", "explicitOriginalTarget", "expm1", "exponent", "exponentialRampToValueAtTime", "exportKey", "extend", "extensions", "extentNode", "extentOffset", "external", "externalResourcesRequired", "extractContents", "extractable", "f", "face", "factoryReset", "fallback", "familyName", "farthestViewportElement", "fastSeek", "fatal", "fetch", "fetchStart", "fftSize", "fgColor", "fileCreatedDate", "fileHandle", "fileModifiedDate", "fileName", "fileSize", "fileUpdatedDate", "filename", "files", "fill", "fill-opacity", "fill-rule", "fillOpacity", "fillRect", "fillRule", "fillStyle", "fillText", "filter", "filterResX", "filterResY", "filterUnits", "filters", "finally", "find", "findIndex", "findRule", "findText", "finish", "fireEvent", "firstChild", "firstElementChild", "firstPage", "fixed", "flex", "flex-basis", "flex-direction", "flex-flow", "flex-grow", "flex-shrink", "flex-wrap", "flexBasis", "flexDirection", "flexFlow", "flexGrow", "flexShrink", "flexWrap", "flipX", "flipY", "float", "flood-color", "flood-opacity", "floodColor", "floodOpacity", "floor", "flush", "focus", "focusNode", "focusOffset", "font", "font-family", "font-feature-settings", "font-kerning", "font-language-override", "font-size", "font-size-adjust", "font-stretch", "font-style", "font-synthesis", "font-variant", "font-variant-alternates", "font-variant-caps", "font-variant-east-asian", "font-variant-ligatures", "font-variant-numeric", "font-variant-position", "font-weight", "fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontSmoothingEnabled", "fontStretch", "fontStyle", "fontSynthesis", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "fontcolor", "fonts", "fontsize", "for", "forEach", "forceRedraw", "form", "formAction", "formEnctype", "formMethod", "formNoValidate", "formTarget", "format", "formatToParts", "forms", "forward", "fr", "frame", "frameBorder", "frameElement", "frameSpacing", "framebufferRenderbuffer", "framebufferTexture2D", "frames", "freeSpace", "freeze", "frequency", "frequencyBinCount", "from", "fromCharCode", "fromCodePoint", "fromElement", "frontFace", "fround", "fullScreen", "fullscreenElement", "fullscreenEnabled", "fx", "fy", "gain", "gamepad", "gamma", "genderIdentity", "generateKey", "generateMipmap", "generateRequest", "geolocation", "gestureObject", "get", "getActiveAttrib", "getActiveUniform", "getAdjacentText", "getAll", "getAllResponseHeaders", "getAsFile", "getAsString", "getAttachedShaders", "getAttribLocation", "getAttribute", "getAttributeNS", "getAttributeNode", "getAttributeNodeNS", "getAudioTracks", "getBBox", "getBattery", "getBlob", "getBookmark", "getBoundingClientRect", "getBufferParameter", "getByteFrequencyData", "getByteTimeDomainData", "getCSSCanvasContext", "getCTM", "getCandidateWindowClientRect", "getChannelData", "getCharNumAtPosition", "getClientRect", "getClientRects", "getCompositionAlternatives", "getComputedStyle", "getComputedTextLength", "getConfiguration", "getContext", "getContextAttributes", "getCounterValue", "getCueAsHTML", "getCueById", "getCurrentPosition", "getCurrentTime", "getData", "getDatabaseNames", "getDate", "getDay", "getDefaultComputedStyle", "getDestinationInsertionPoints", "getDistributedNodes", "getEditable", "getElementById", "getElementsByClassName", "getElementsByName", "getElementsByTagName", "getElementsByTagNameNS", "getEnclosureList", "getEndPositionOfChar", "getEntries", "getEntriesByName", "getEntriesByType", "getError", "getExtension", "getExtentOfChar", "getFeature", "getFile", "getFloat32", "getFloat64", "getFloatFrequencyData", "getFloatTimeDomainData", "getFloatValue", "getFramebufferAttachmentParameter", "getFrequencyResponse", "getFullYear", "getGamepads", "getHours", "getImageData", "getInt16", "getInt32", "getInt8", "getIntersectionList", "getItem", "getItems", "getKey", "getLineDash", "getLocalStreams", "getMarks", "getMatchedCSSRules", "getMeasures", "getMetadata", "getMilliseconds", "getMinutes", "getModifierState", "getMonth", "getNamedItem", "getNamedItemNS", "getNotifier", "getNumberOfChars", "getOverrideHistoryNavigationMode", "getOverrideStyle", "getOwnPropertyDescriptor", "getOwnPropertyNames", "getOwnPropertySymbols", "getParameter", "getPathSegAtLength", "getPointAtLength", "getPreference", "getPreferenceDefault", "getPresentationAttribute", "getPreventDefault", "getProgramInfoLog", "getProgramParameter", "getPropertyCSSValue", "getPropertyPriority", "getPropertyShorthand", "getPropertyValue", "getPrototypeOf", "getRGBColorValue", "getRandomValues", "getRangeAt", "getReceivers", "getRectValue", "getRegistration", "getRemoteStreams", "getRenderbufferParameter", "getResponseHeader", "getRoot", "getRotationOfChar", "getSVGDocument", "getScreenCTM", "getSeconds", "getSelection", "getSenders", "getShaderInfoLog", "getShaderParameter", "getShaderPrecisionFormat", "getShaderSource", "getSimpleDuration", "getSiteIcons", "getSources", "getSpeculativeParserUrls", "getStartPositionOfChar", "getStartTime", "getStats", "getStorageUpdates", "getStreamById", "getStringValue", "getSubStringLength", "getSubscription", "getSupportedExtensions", "getTexParameter", "getTime", "getTimezoneOffset", "getTotalLength", "getTrackById", "getTracks", "getTransformToElement", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getUint16", "getUint32", "getUint8", "getUniform", "getUniformLocation", "getUserMedia", "getValues", "getVarDate", "getVariableValue", "getVertexAttrib", "getVertexAttribOffset", "getVideoPlaybackQuality", "getVideoTracks", "getWakeLockState", "getYear", "givenName", "global", "globalAlpha", "globalCompositeOperation", "glyphOrientationHorizontal", "glyphOrientationVertical", "glyphRef", "go", "gradientTransform", "gradientUnits", "grammars", "green", "group", "groupCollapsed", "groupEnd", "hardwareConcurrency", "has", "hasAttribute", "hasAttributeNS", "hasAttributes", "hasChildNodes", "hasComposition", "hasExtension", "hasFeature", "hasFocus", "hasLayout", "hasOwnProperty", "hash", "head", "headers", "heading", "height", "hidden", "hide", "hideFocus", "high", "hint", "history", "honorificPrefix", "honorificSuffix", "horizontalOverflow", "host", "hostname", "href", "hreflang", "hspace", "html5TagCheckInerface", "htmlFor", "htmlText", "httpEquiv", "hwTimestamp", "hypot", "iccId", "iceConnectionState", "iceGatheringState", "icon", "id", "identifier", "identity", "ignoreBOM", "ignoreCase", "image-orientation", "image-rendering", "imageOrientation", "imageRendering", "images", "ime-mode", "imeMode", "implementation", "importKey", "importNode", "importStylesheet", "imports", "impp", "imul", "in1", "in2", "inBandMetadataTrackDispatchType", "inRange", "includes", "incremental", "indeterminate", "index", "indexNames", "indexOf", "indexedDB", "inertiaDestinationX", "inertiaDestinationY", "info", "init", "initAnimationEvent", "initBeforeLoadEvent", "initClipboardEvent", "initCloseEvent", "initCommandEvent", "initCompositionEvent", "initCustomEvent", "initData", "initDeviceMotionEvent", "initDeviceOrientationEvent", "initDragEvent", "initErrorEvent", "initEvent", "initFocusEvent", "initGestureEvent", "initHashChangeEvent", "initKeyEvent", "initKeyboardEvent", "initMSManipulationEvent", "initMessageEvent", "initMouseEvent", "initMouseScrollEvent", "initMouseWheelEvent", "initMutationEvent", "initNSMouseEvent", "initOverflowEvent", "initPageEvent", "initPageTransitionEvent", "initPointerEvent", "initPopStateEvent", "initProgressEvent", "initScrollAreaEvent", "initSimpleGestureEvent", "initStorageEvent", "initTextEvent", "initTimeEvent", "initTouchEvent", "initTransitionEvent", "initUIEvent", "initWebKitAnimationEvent", "initWebKitTransitionEvent", "initWebKitWheelEvent", "initWheelEvent", "initialTime", "initialize", "initiatorType", "inner", "innerHTML", "innerHeight", "innerText", "innerWidth", "input", "inputBuffer", "inputEncoding", "inputMethod", "insertAdjacentElement", "insertAdjacentHTML", "insertAdjacentText", "insertBefore", "insertCell", "insertData", "insertItemBefore", "insertNode", "insertRow", "insertRule", "instanceRoot", "intercept", "interimResults", "internalSubset", "intersectsNode", "interval", "invalidIteratorState", "inverse", "invertSelf", "is", "is2D", "isAlternate", "isArray", "isBingCurrentSearchDefault", "isBuffer", "isCandidateWindowVisible", "isChar", "isCollapsed", "isComposing", "isContentEditable", "isContentHandlerRegistered", "isContextLost", "isDefaultNamespace", "isDisabled", "isEnabled", "isEqual", "isEqualNode", "isExtensible", "isFinite", "isFramebuffer", "isFrozen", "isGenerator", "isId", "isInjected", "isInteger", "isMap", "isMultiLine", "isNaN", "isOpen", "isPointInFill", "isPointInPath", "isPointInRange", "isPointInStroke", "isPrefAlternate", "isPrimary", "isProgram", "isPropertyImplicit", "isProtocolHandlerRegistered", "isPrototypeOf", "isRenderbuffer", "isSafeInteger", "isSameNode", "isSealed", "isShader", "isSupported", "isTextEdit", "isTexture", "isTrusted", "isTypeSupported", "isView", "isolation", "italics", "item", "itemId", "itemProp", "itemRef", "itemScope", "itemType", "itemValue", "iterateNext", "iterator", "javaEnabled", "jobTitle", "join", "json", "justify-content", "justifyContent", "k1", "k2", "k3", "k4", "kernelMatrix", "kernelUnitLengthX", "kernelUnitLengthY", "kerning", "key", "keyCode", "keyFor", "keyIdentifier", "keyLightEnabled", "keyLocation", "keyPath", "keySystem", "keyText", "keyUsage", "keys", "keytype", "kind", "knee", "label", "labels", "lang", "language", "languages", "largeArcFlag", "lastChild", "lastElementChild", "lastEventId", "lastIndex", "lastIndexOf", "lastMatch", "lastMessageSubject", "lastMessageType", "lastModified", "lastModifiedDate", "lastPage", "lastParen", "lastState", "lastStyleSheetSet", "latitude", "layerX", "layerY", "layoutFlow", "layoutGrid", "layoutGridChar", "layoutGridLine", "layoutGridMode", "layoutGridType", "lbound", "left", "leftContext", "leftMargin", "length", "lengthAdjust", "lengthComputable", "letter-spacing", "letterSpacing", "level", "lighting-color", "lightingColor", "limitingConeAngle", "line", "line-height", "lineAlign", "lineBreak", "lineCap", "lineDashOffset", "lineHeight", "lineJoin", "lineNumber", "lineTo", "lineWidth", "linearRampToValueAtTime", "lineno", "link", "linkColor", "linkProgram", "links", "list", "list-style", "list-style-image", "list-style-position", "list-style-type", "listStyle", "listStyleImage", "listStylePosition", "listStyleType", "listener", "load", "loadEventEnd", "loadEventStart", "loadTimes", "loaded", "localDescription", "localName", "localStorage", "locale", "localeCompare", "location", "locationbar", "lock", "lockedFile", "log", "log10", "log1p", "log2", "logicalXDPI", "logicalYDPI", "longDesc", "longitude", "lookupNamespaceURI", "lookupPrefix", "loop", "loopEnd", "loopStart", "looping", "low", "lower", "lowerBound", "lowerOpen", "lowsrc", "m11", "m12", "m13", "m14", "m21", "m22", "m23", "m24", "m31", "m32", "m33", "m34", "m41", "m42", "m43", "m44", "manifest", "map", "mapping", "margin", "margin-bottom", "margin-left", "margin-right", "margin-top", "marginBottom", "marginHeight", "marginLeft", "marginRight", "marginTop", "marginWidth", "mark", "marker", "marker-end", "marker-mid", "marker-offset", "marker-start", "markerEnd", "markerHeight", "markerMid", "markerOffset", "markerStart", "markerUnits", "markerWidth", "marks", "mask", "mask-type", "maskContentUnits", "maskType", "maskUnits", "match", "matchMedia", "matchMedium", "matches", "matrix", "matrixTransform", "max", "max-height", "max-width", "maxAlternatives", "maxChannelCount", "maxConnectionsPerServer", "maxDecibels", "maxDistance", "maxHeight", "maxLength", "maxTouchPoints", "maxValue", "maxWidth", "measure", "measureText", "media", "mediaCapabilities", "mediaDevices", "mediaElement", "mediaGroup", "mediaKeys", "mediaText", "meetOrSlice", "memory", "menubar", "mergeAttributes", "message", "messageClass", "messageHandlers", "metaKey", "method", "mimeType", "mimeTypes", "min", "min-height", "min-width", "minDecibels", "minHeight", "minValue", "minWidth", "miterLimit", "mix-blend-mode", "mixBlendMode", "mode", "modify", "mount", "move", "moveBy", "moveEnd", "moveFirst", "moveFocusDown", "moveFocusLeft", "moveFocusRight", "moveFocusUp", "moveNext", "moveRow", "moveStart", "moveTo", "moveToBookmark", "moveToElementText", "moveToPoint", "mozAdd", "mozAnimationStartTime", "mozAnon", "mozApps", "mozAudioCaptured", "mozAudioChannelType", "mozAutoplayEnabled", "mozCancelAnimationFrame", "mozCancelFullScreen", "mozCancelRequestAnimationFrame", "mozCaptureStream", "mozCaptureStreamUntilEnded", "mozClearDataAt", "mozContact", "mozContacts", "mozCreateFileHandle", "mozCurrentTransform", "mozCurrentTransformInverse", "mozCursor", "mozDash", "mozDashOffset", "mozDecodedFrames", "mozExitPointerLock", "mozFillRule", "mozFragmentEnd", "mozFrameDelay", "mozFullScreen", "mozFullScreenElement", "mozFullScreenEnabled", "mozGetAll", "mozGetAllKeys", "mozGetAsFile", "mozGetDataAt", "mozGetMetadata", "mozGetUserMedia", "mozHasAudio", "mozHasItem", "mozHidden", "mozImageSmoothingEnabled", "mozIndexedDB", "mozInnerScreenX", "mozInnerScreenY", "mozInputSource", "mozIsTextField", "mozItem", "mozItemCount", "mozItems", "mozLength", "mozLockOrientation", "mozMatchesSelector", "mozMovementX", "mozMovementY", "mozOpaque", "mozOrientation", "mozPaintCount", "mozPaintedFrames", "mozParsedFrames", "mozPay", "mozPointerLockElement", "mozPresentedFrames", "mozPreservesPitch", "mozPressure", "mozPrintCallback", "mozRTCIceCandidate", "mozRTCPeerConnection", "mozRTCSessionDescription", "mozRemove", "mozRequestAnimationFrame", "mozRequestFullScreen", "mozRequestPointerLock", "mozSetDataAt", "mozSetImageElement", "mozSourceNode", "mozSrcObject", "mozSystem", "mozTCPSocket", "mozTextStyle", "mozTypesAt", "mozUnlockOrientation", "mozUserCancelled", "mozVisibilityState", "msAnimation", "msAnimationDelay", "msAnimationDirection", "msAnimationDuration", "msAnimationFillMode", "msAnimationIterationCount", "msAnimationName", "msAnimationPlayState", "msAnimationStartTime", "msAnimationTimingFunction", "msBackfaceVisibility", "msBlockProgression", "msCSSOMElementFloatMetrics", "msCaching", "msCachingEnabled", "msCancelRequestAnimationFrame", "msCapsLockWarningOff", "msClearImmediate", "msClose", "msContentZoomChaining", "msContentZoomFactor", "msContentZoomLimit", "msContentZoomLimitMax", "msContentZoomLimitMin", "msContentZoomSnap", "msContentZoomSnapPoints", "msContentZoomSnapType", "msContentZooming", "msConvertURL", "msCrypto", "msDoNotTrack", "msElementsFromPoint", "msElementsFromRect", "msExitFullscreen", "msExtendedCode", "msFillRule", "msFirstPaint", "msFlex", "msFlexAlign", "msFlexDirection", "msFlexFlow", "msFlexItemAlign", "msFlexLinePack", "msFlexNegative", "msFlexOrder", "msFlexPack", "msFlexPositive", "msFlexPreferredSize", "msFlexWrap", "msFlowFrom", "msFlowInto", "msFontFeatureSettings", "msFullscreenElement", "msFullscreenEnabled", "msGetInputContext", "msGetRegionContent", "msGetUntransformedBounds", "msGraphicsTrustStatus", "msGridColumn", "msGridColumnAlign", "msGridColumnSpan", "msGridColumns", "msGridRow", "msGridRowAlign", "msGridRowSpan", "msGridRows", "msHidden", "msHighContrastAdjust", "msHyphenateLimitChars", "msHyphenateLimitLines", "msHyphenateLimitZone", "msHyphens", "msImageSmoothingEnabled", "msImeAlign", "msIndexedDB", "msInterpolationMode", "msIsStaticHTML", "msKeySystem", "msKeys", "msLaunchUri", "msLockOrientation", "msManipulationViewsEnabled", "msMatchMedia", "msMatchesSelector", "msMaxTouchPoints", "msOrientation", "msOverflowStyle", "msPerspective", "msPerspectiveOrigin", "msPlayToDisabled", "msPlayToPreferredSourceUri", "msPlayToPrimary", "msPointerEnabled", "msRegionOverflow", "msReleasePointerCapture", "msRequestAnimationFrame", "msRequestFullscreen", "msSaveBlob", "msSaveOrOpenBlob", "msScrollChaining", "msScrollLimit", "msScrollLimitXMax", "msScrollLimitXMin", "msScrollLimitYMax", "msScrollLimitYMin", "msScrollRails", "msScrollSnapPointsX", "msScrollSnapPointsY", "msScrollSnapType", "msScrollSnapX", "msScrollSnapY", "msScrollTranslation", "msSetImmediate", "msSetMediaKeys", "msSetPointerCapture", "msTextCombineHorizontal", "msTextSizeAdjust", "msToBlob", "msTouchAction", "msTouchSelect", "msTraceAsyncCallbackCompleted", "msTraceAsyncCallbackStarting", "msTraceAsyncOperationCompleted", "msTraceAsyncOperationStarting", "msTransform", "msTransformOrigin", "msTransformStyle", "msTransition", "msTransitionDelay", "msTransitionDuration", "msTransitionProperty", "msTransitionTimingFunction", "msUnlockOrientation", "msUpdateAsyncCallbackRelation", "msUserSelect", "msVisibilityState", "msWrapFlow", "msWrapMargin", "msWrapThrough", "msWriteProfilerMark", "msZoom", "msZoomTo", "mt", "multiEntry", "multiSelectionObj", "multiline", "multiple", "multiply", "multiplySelf", "mutableFile", "muted", "n", "name", "nameProp", "namedItem", "namedRecordset", "names", "namespaceURI", "namespaces", "naturalHeight", "naturalWidth", "navigate", "navigation", "navigationMode", "navigationStart", "navigator", "near", "nearestViewportElement", "negative", "netscape", "networkState", "newScale", "newTranslate", "newURL", "newValue", "newValueSpecifiedUnits", "newVersion", "newhome", "next", "nextElementSibling", "nextNode", "nextPage", "nextSibling", "nickname", "noHref", "noResize", "noShade", "noValidate", "noWrap", "nodeName", "nodeType", "nodeValue", "normalize", "normalizedPathSegList", "notationName", "notations", "note", "noteGrainOn", "noteOff", "noteOn", "now", "numOctaves", "number", "numberOfChannels", "numberOfInputs", "numberOfItems", "numberOfOutputs", "numberValue", "oMatchesSelector", "object", "object-fit", "object-position", "objectFit", "objectPosition", "objectStore", "objectStoreNames", "observe", "of", "offscreenBuffering", "offset", "offsetHeight", "offsetLeft", "offsetNode", "offsetParent", "offsetTop", "offsetWidth", "offsetX", "offsetY", "ok", "oldURL", "oldValue", "oldVersion", "olderShadowRoot", "onLine", "onabort", "onactivate", "onactive", "onaddstream", "onaddtrack", "onafterprint", "onafterscriptexecute", "onafterupdate", "onaudioend", "onaudioprocess", "onaudiostart", "onautocomplete", "onautocompleteerror", "onbeforeactivate", "onbeforecopy", "onbeforecut", "onbeforedeactivate", "onbeforeeditfocus", "onbeforepaste", "onbeforeprint", "onbeforescriptexecute", "onbeforeunload", "onbeforeupdate", "onblocked", "onblur", "onbounce", "onboundary", "oncached", "oncancel", "oncandidatewindowhide", "oncandidatewindowshow", "oncandidatewindowupdate", "oncanplay", "oncanplaythrough", "once", "oncellchange", "onchange", "onchargingchange", "onchargingtimechange", "onchecking", "onclick", "onclose", "oncompassneedscalibration", "oncomplete", "oncontextmenu", "oncontrolselect", "oncopy", "oncuechange", "oncut", "ondataavailable", "ondatachannel", "ondatasetchanged", "ondatasetcomplete", "ondblclick", "ondeactivate", "ondevicelight", "ondevicemotion", "ondeviceorientation", "ondeviceproximity", "ondischargingtimechange", "ondisplay", "ondownloading", "ondrag", "ondragend", "ondragenter", "ondragleave", "ondragover", "ondragstart", "ondrop", "ondurationchange", "onemptied", "onencrypted", "onend", "onended", "onenter", "onerror", "onerrorupdate", "onexit", "onfilterchange", "onfinish", "onfocus", "onfocusin", "onfocusout", "onfullscreenchange", "onfullscreenerror", "ongesturechange", "ongestureend", "ongesturestart", "ongotpointercapture", "onhashchange", "onhelp", "onicecandidate", "oniceconnectionstatechange", "oninactive", "oninput", "oninvalid", "onkeydown", "onkeypress", "onkeyup", "onlanguagechange", "onlayoutcomplete", "onlevelchange", "onload", "onloadeddata", "onloadedmetadata", "onloadend", "onloadstart", "onlosecapture", "onlostpointercapture", "only", "onmark", "onmessage", "onmousedown", "onmouseenter", "onmouseleave", "onmousemove", "onmouseout", "onmouseover", "onmouseup", "onmousewheel", "onmove", "onmoveend", "onmovestart", "onmozfullscreenchange", "onmozfullscreenerror", "onmozorientationchange", "onmozpointerlockchange", "onmozpointerlockerror", "onmscontentzoom", "onmsfullscreenchange", "onmsfullscreenerror", "onmsgesturechange", "onmsgesturedoubletap", "onmsgestureend", "onmsgesturehold", "onmsgesturestart", "onmsgesturetap", "onmsgotpointercapture", "onmsinertiastart", "onmslostpointercapture", "onmsmanipulationstatechanged", "onmsneedkey", "onmsorientationchange", "onmspointercancel", "onmspointerdown", "onmspointerenter", "onmspointerhover", "onmspointerleave", "onmspointermove", "onmspointerout", "onmspointerover", "onmspointerup", "onmssitemodejumplistitemremoved", "onmsthumbnailclick", "onnegotiationneeded", "onnomatch", "onnoupdate", "onobsolete", "onoffline", "ononline", "onopen", "onorientationchange", "onpagechange", "onpagehide", "onpageshow", "onpaste", "onpause", "onplay", "onplaying", "onpluginstreamstart", "onpointercancel", "onpointerdown", "onpointerenter", "onpointerleave", "onpointerlockchange", "onpointerlockerror", "onpointermove", "onpointerout", "onpointerover", "onpointerup", "onpopstate", "onprogress", "onpropertychange", "onratechange", "onreadystatechange", "onremovestream", "onremovetrack", "onreset", "onresize", "onresizeend", "onresizestart", "onresourcetimingbufferfull", "onresult", "onresume", "onrowenter", "onrowexit", "onrowsdelete", "onrowsinserted", "onscroll", "onsearch", "onseeked", "onseeking", "onselect", "onselectionchange", "onselectstart", "onshow", "onsignalingstatechange", "onsoundend", "onsoundstart", "onspeechend", "onspeechstart", "onstalled", "onstart", "onstatechange", "onstop", "onstorage", "onstoragecommit", "onsubmit", "onsuccess", "onsuspend", "ontextinput", "ontimeout", "ontimeupdate", "ontoggle", "ontouchcancel", "ontouchend", "ontouchmove", "ontouchstart", "ontransitionend", "onunload", "onupdateready", "onupgradeneeded", "onuserproximity", "onversionchange", "onvoiceschanged", "onvolumechange", "onwaiting", "onwarning", "onwebkitanimationend", "onwebkitanimationiteration", "onwebkitanimationstart", "onwebkitcurrentplaybacktargetiswirelesschanged", "onwebkitfullscreenchange", "onwebkitfullscreenerror", "onwebkitkeyadded", "onwebkitkeyerror", "onwebkitkeymessage", "onwebkitneedkey", "onwebkitorientationchange", "onwebkitplaybacktargetavailabilitychanged", "onwebkitpointerlockchange", "onwebkitpointerlockerror", "onwebkitresourcetimingbufferfull", "onwebkittransitionend", "onwheel", "onzoom", "opacity", "open", "openCursor", "openDatabase", "openKeyCursor", "opener", "opera", "operationType", "operator", "opr", "optimum", "options", "order", "orderX", "orderY", "ordered", "org", "orient", "orientAngle", "orientType", "orientation", "origin", "originalTarget", "orphans", "oscpu", "outerHTML", "outerHeight", "outerText", "outerWidth", "outline", "outline-color", "outline-offset", "outline-style", "outline-width", "outlineColor", "outlineOffset", "outlineStyle", "outlineWidth", "outputBuffer", "overflow", "overflow-x", "overflow-y", "overflowX", "overflowY", "overrideMimeType", "oversample", "ownerDocument", "ownerElement", "ownerNode", "ownerRule", "ownerSVGElement", "owningElement", "p1", "p2", "p3", "p4", "pad", "padding", "padding-bottom", "padding-left", "padding-right", "padding-top", "paddingBottom", "paddingLeft", "paddingRight", "paddingTop", "page", "page-break-after", "page-break-before", "page-break-inside", "pageBreakAfter", "pageBreakBefore", "pageBreakInside", "pageCount", "pageX", "pageXOffset", "pageY", "pageYOffset", "pages", "paint-order", "paintOrder", "paintRequests", "paintType", "palette", "panningModel", "parent", "parentElement", "parentNode", "parentRule", "parentStyleSheet", "parentTextEdit", "parentWindow", "parse", "parseFloat", "parseFromString", "parseInt", "participants", "passive", "password", "pasteHTML", "path", "pathLength", "pathSegList", "pathSegType", "pathSegTypeAsLetter", "pathname", "pattern", "patternContentUnits", "patternMismatch", "patternTransform", "patternUnits", "pause", "pauseAnimations", "pauseOnExit", "paused", "pending", "performance", "permission", "persisted", "personalbar", "perspective", "perspective-origin", "perspectiveOrigin", "phoneticFamilyName", "phoneticGivenName", "photo", "ping", "pitch", "pixelBottom", "pixelDepth", "pixelHeight", "pixelLeft", "pixelRight", "pixelStorei", "pixelTop", "pixelUnitToMillimeterX", "pixelUnitToMillimeterY", "pixelWidth", "placeholder", "platform", "play", "playbackRate", "playbackState", "playbackTime", "played", "plugins", "pluginspage", "pname", "pointer-events", "pointerBeforeReferenceNode", "pointerEnabled", "pointerEvents", "pointerId", "pointerLockElement", "pointerType", "points", "pointsAtX", "pointsAtY", "pointsAtZ", "polygonOffset", "pop", "popupWindowFeatures", "popupWindowName", "popupWindowURI", "port", "port1", "port2", "ports", "posBottom", "posHeight", "posLeft", "posRight", "posTop", "posWidth", "position", "positionAlign", "postError", "postMessage", "poster", "pow", "powerOff", "preMultiplySelf", "precision", "preferredStyleSheetSet", "preferredStylesheetSet", "prefix", "preload", "prepend", "preserveAlpha", "preserveAspectRatio", "preserveAspectRatioString", "pressed", "pressure", "prevValue", "preventDefault", "preventExtensions", "previousElementSibling", "previousNode", "previousPage", "previousScale", "previousSibling", "previousTranslate", "primaryKey", "primitiveType", "primitiveUnits", "principals", "print", "privateKey", "probablySupportsContext", "process", "processIceMessage", "product", "productSub", "profile", "profileEnd", "profiles", "prompt", "properties", "propertyIsEnumerable", "propertyName", "protocol", "protocolLong", "prototype", "pseudoClass", "pseudoElement", "publicId", "publicKey", "published", "push", "pushNotification", "pushState", "put", "putImageData", "quadraticCurveTo", "qualifier", "queryCommandEnabled", "queryCommandIndeterm", "queryCommandState", "queryCommandSupported", "queryCommandText", "queryCommandValue", "querySelector", "querySelectorAll", "quote", "quotes", "r", "r1", "r2", "race", "radiogroup", "radiusX", "radiusY", "random", "range", "rangeCount", "rangeMax", "rangeMin", "rangeOffset", "rangeOverflow", "rangeParent", "rangeUnderflow", "rate", "ratio", "raw", "read", "readAsArrayBuffer", "readAsBinaryString", "readAsBlob", "readAsDataURL", "readAsText", "readOnly", "readPixels", "readReportRequested", "readyState", "reason", "reboot", "receiver", "receivers", "recordNumber", "recordset", "rect", "red", "redirectCount", "redirectEnd", "redirectStart", "reduce", "reduceRight", "reduction", "refDistance", "refX", "refY", "referenceNode", "referrer", "refresh", "region", "regionAnchorX", "regionAnchorY", "regionId", "regions", "register", "registerContentHandler", "registerElement", "registerProtocolHandler", "reject", "rel", "relList", "relatedNode", "relatedTarget", "release", "releaseCapture", "releaseEvents", "releasePointerCapture", "releaseShaderCompiler", "reliable", "reload", "remainingSpace", "remoteDescription", "remove", "removeAllRanges", "removeAttribute", "removeAttributeNS", "removeAttributeNode", "removeBehavior", "removeChild", "removeCue", "removeEventListener", "removeFilter", "removeImport", "removeItem", "removeListener", "removeNamedItem", "removeNamedItemNS", "removeNode", "removeParameter", "removeProperty", "removeRange", "removeRegion", "removeRule", "removeSiteSpecificTrackingException", "removeSourceBuffer", "removeStream", "removeTrack", "removeVariable", "removeWakeLockListener", "removeWebWideTrackingException", "removedNodes", "renderbufferStorage", "renderedBuffer", "renderingMode", "repeat", "replace", "replaceAdjacentText", "replaceChild", "replaceData", "replaceId", "replaceItem", "replaceNode", "replaceState", "replaceTrack", "replaceWholeText", "reportValidity", "requestAnimationFrame", "requestAutocomplete", "requestData", "requestFullscreen", "requestMediaKeySystemAccess", "requestPermission", "requestPointerLock", "requestStart", "requestingWindow", "required", "requiredExtensions", "requiredFeatures", "reset", "resetTransform", "resize", "resizeBy", "resizeTo", "resolve", "response", "responseBody", "responseEnd", "responseStart", "responseText", "responseType", "responseURL", "responseXML", "restore", "result", "resultType", "resume", "returnValue", "rev", "reverse", "reversed", "revocable", "revokeObjectURL", "rgbColor", "right", "rightContext", "rightMargin", "rolloffFactor", "root", "rootElement", "rotate", "rotateAxisAngle", "rotateAxisAngleSelf", "rotateFromVector", "rotateFromVectorSelf", "rotateSelf", "rotation", "rotationRate", "round", "rowIndex", "rowSpan", "rows", "rubyAlign", "rubyOverhang", "rubyPosition", "rules", "runtime", "runtimeStyle", "rx", "ry", "safari", "sampleCoverage", "sampleRate", "sandbox", "save", "scale", "scale3d", "scale3dSelf", "scaleNonUniform", "scaleNonUniformSelf", "scaleSelf", "scheme", "scissor", "scope", "scopeName", "scoped", "screen", "screenBrightness", "screenEnabled", "screenLeft", "screenPixelToMillimeterX", "screenPixelToMillimeterY", "screenTop", "screenX", "screenY", "scripts", "scroll", "scroll-behavior", "scrollAmount", "scrollBehavior", "scrollBy", "scrollByLines", "scrollByPages", "scrollDelay", "scrollHeight", "scrollIntoView", "scrollIntoViewIfNeeded", "scrollLeft", "scrollLeftMax", "scrollMaxX", "scrollMaxY", "scrollTo", "scrollTop", "scrollTopMax", "scrollWidth", "scrollX", "scrollY", "scrollbar3dLightColor", "scrollbarArrowColor", "scrollbarBaseColor", "scrollbarDarkShadowColor", "scrollbarFaceColor", "scrollbarHighlightColor", "scrollbarShadowColor", "scrollbarTrackColor", "scrollbars", "scrolling", "sdp", "sdpMLineIndex", "sdpMid", "seal", "search", "searchBox", "searchBoxJavaBridge_", "searchParams", "sectionRowIndex", "secureConnectionStart", "security", "seed", "seekable", "seeking", "select", "selectAllChildren", "selectNode", "selectNodeContents", "selectNodes", "selectSingleNode", "selectSubString", "selected", "selectedIndex", "selectedOptions", "selectedStyleSheetSet", "selectedStylesheetSet", "selection", "selectionDirection", "selectionEnd", "selectionStart", "selector", "selectorText", "self", "send", "sendAsBinary", "sendBeacon", "sender", "sentTimestamp", "separator", "serializeToString", "serviceWorker", "sessionId", "sessionStorage", "set", "setActive", "setAlpha", "setAttribute", "setAttributeNS", "setAttributeNode", "setAttributeNodeNS", "setBaseAndExtent", "setBingCurrentSearchDefault", "setCapture", "setColor", "setCompositeOperation", "setCurrentTime", "setCustomValidity", "setData", "setDate", "setDragImage", "setEnd", "setEndAfter", "setEndBefore", "setEndPoint", "setFillColor", "setFilterRes", "setFloat32", "setFloat64", "setFloatValue", "setFullYear", "setHours", "setImmediate", "setInt16", "setInt32", "setInt8", "setInterval", "setItem", "setLineCap", "setLineDash", "setLineJoin", "setLineWidth", "setLocalDescription", "setMatrix", "setMatrixValue", "setMediaKeys", "setMilliseconds", "setMinutes", "setMiterLimit", "setMonth", "setNamedItem", "setNamedItemNS", "setNonUserCodeExceptions", "setOrientToAngle", "setOrientToAuto", "setOrientation", "setOverrideHistoryNavigationMode", "setPaint", "setParameter", "setPeriodicWave", "setPointerCapture", "setPosition", "setPreference", "setProperty", "setPrototypeOf", "setRGBColor", "setRGBColorICCColor", "setRadius", "setRangeText", "setRemoteDescription", "setRequestHeader", "setResizable", "setResourceTimingBufferSize", "setRotate", "setScale", "setSeconds", "setSelectionRange", "setServerCertificate", "setShadow", "setSkewX", "setSkewY", "setStart", "setStartAfter", "setStartBefore", "setStdDeviation", "setStringValue", "setStrokeColor", "setSuggestResult", "setTargetAtTime", "setTargetValueAtTime", "setTime", "setTimeout", "setTransform", "setTranslate", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setUint16", "setUint32", "setUint8", "setUri", "setValueAtTime", "setValueCurveAtTime", "setVariable", "setVelocity", "setVersion", "setYear", "settingName", "settingValue", "sex", "shaderSource", "shadowBlur", "shadowColor", "shadowOffsetX", "shadowOffsetY", "shadowRoot", "shape", "shape-rendering", "shapeRendering", "sheet", "shift", "shiftKey", "shiftLeft", "show", "showHelp", "showModal", "showModalDialog", "showModelessDialog", "showNotification", "sidebar", "sign", "signalingState", "sin", "singleNodeValue", "sinh", "size", "sizeToContent", "sizes", "skewX", "skewXSelf", "skewY", "skewYSelf", "slice", "slope", "small", "smooth", "smil", "smoothingTimeConstant", "snapToLines", "snapshotItem", "snapshotLength", "some", "sort", "source", "sourceBuffer", "sourceBuffers", "sourceIndex", "spacing", "span", "speakAs", "speaking", "specified", "specularConstant", "specularExponent", "speechSynthesis", "speed", "speedOfSound", "spellcheck", "splice", "split", "splitText", "spreadMethod", "sqrt", "src", "srcElement", "srcFilter", "srcUrn", "srcdoc", "srclang", "srcset", "stack", "stackTraceLimit", "stacktrace", "standalone", "standby", "start", "startContainer", "startIce", "startOffset", "startRendering", "startTime", "startsWith", "state", "status", "statusMessage", "statusText", "statusbar", "stdDeviationX", "stdDeviationY", "stencilFunc", "stencilFuncSeparate", "stencilMask", "stencilMaskSeparate", "stencilOp", "stencilOpSeparate", "step", "stepDown", "stepMismatch", "stepUp", "sticky", "stitchTiles", "stop", "stop-color", "stop-opacity", "stopColor", "stopImmediatePropagation", "stopOpacity", "stopPropagation", "storageArea", "storageName", "storageStatus", "storeSiteSpecificTrackingException", "storeWebWideTrackingException", "stpVersion", "stream", "strike", "stringValue", "stringify", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "strokeDasharray", "strokeDashoffset", "strokeLinecap", "strokeLinejoin", "strokeMiterlimit", "strokeOpacity", "strokeRect", "strokeStyle", "strokeText", "strokeWidth", "style", "styleFloat", "styleMedia", "styleSheet", "styleSheetSets", "styleSheets", "sub", "subarray", "subject", "submit", "subscribe", "substr", "substring", "substringData", "subtle", "subtree", "suffix", "suffixes", "summary", "sup", "supports", "surfaceScale", "surroundContents", "suspend", "suspendRedraw", "swapCache", "swapNode", "sweepFlag", "symbols", "system", "systemCode", "systemId", "systemLanguage", "systemXDPI", "systemYDPI", "tBodies", "tFoot", "tHead", "tabIndex", "table", "table-layout", "tableLayout", "tableValues", "tag", "tagName", "tagUrn", "tags", "taintEnabled", "takeRecords", "tan", "tanh", "target", "targetElement", "targetTouches", "targetX", "targetY", "tel", "terminate", "test", "texImage2D", "texParameterf", "texParameteri", "texSubImage2D", "text", "text-align", "text-anchor", "text-decoration", "text-decoration-color", "text-decoration-line", "text-decoration-style", "text-indent", "text-overflow", "text-rendering", "text-shadow", "text-transform", "textAlign", "textAlignLast", "textAnchor", "textAutospace", "textBaseline", "textContent", "textDecoration", "textDecorationBlink", "textDecorationColor", "textDecorationLine", "textDecorationLineThrough", "textDecorationNone", "textDecorationOverline", "textDecorationStyle", "textDecorationUnderline", "textIndent", "textJustify", "textJustifyTrim", "textKashida", "textKashidaSpace", "textLength", "textOverflow", "textRendering", "textShadow", "textTracks", "textTransform", "textUnderlinePosition", "then", "threadId", "threshold", "tiltX", "tiltY", "time", "timeEnd", "timeStamp", "timeout", "timestamp", "timestampOffset", "timing", "title", "toArray", "toBlob", "toDataURL", "toDateString", "toElement", "toExponential", "toFixed", "toFloat32Array", "toFloat64Array", "toGMTString", "toISOString", "toJSON", "toLocaleDateString", "toLocaleFormat", "toLocaleLowerCase", "toLocaleString", "toLocaleTimeString", "toLocaleUpperCase", "toLowerCase", "toMethod", "toPrecision", "toSdp", "toSource", "toStaticHTML", "toString", "toStringTag", "toTimeString", "toUTCString", "toUpperCase", "toggle", "toggleLongPressEnabled", "tooLong", "toolbar", "top", "topMargin", "total", "totalFrameDelay", "totalVideoFrames", "touchAction", "touches", "trace", "track", "transaction", "transactions", "transform", "transform-origin", "transform-style", "transformOrigin", "transformPoint", "transformString", "transformStyle", "transformToDocument", "transformToFragment", "transition", "transition-delay", "transition-duration", "transition-property", "transition-timing-function", "transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction", "translate", "translateSelf", "translationX", "translationY", "trim", "trimLeft", "trimRight", "trueSpeed", "trunc", "truncate", "type", "typeDetail", "typeMismatch", "typeMustMatch", "types", "ubound", "undefined", "unescape", "uneval", "unicode-bidi", "unicodeBidi", "uniform1f", "uniform1fv", "uniform1i", "uniform1iv", "uniform2f", "uniform2fv", "uniform2i", "uniform2iv", "uniform3f", "uniform3fv", "uniform3i", "uniform3iv", "uniform4f", "uniform4fv", "uniform4i", "uniform4iv", "uniformMatrix2fv", "uniformMatrix3fv", "uniformMatrix4fv", "unique", "uniqueID", "uniqueNumber", "unitType", "units", "unloadEventEnd", "unloadEventStart", "unlock", "unmount", "unobserve", "unpause", "unpauseAnimations", "unreadCount", "unregister", "unregisterContentHandler", "unregisterProtocolHandler", "unscopables", "unselectable", "unshift", "unsubscribe", "unsuspendRedraw", "unsuspendRedrawAll", "unwatch", "unwrapKey", "update", "updateCommands", "updateIce", "updateInterval", "updateSettings", "updated", "updating", "upload", "upper", "upperBound", "upperOpen", "uri", "url", "urn", "urns", "usages", "useCurrentView", "useMap", "useProgram", "usedSpace", "userAgent", "userLanguage", "username", "v8BreakIterator", "vAlign", "vLink", "valid", "validateProgram", "validationMessage", "validity", "value", "valueAsDate", "valueAsNumber", "valueAsString", "valueInSpecifiedUnits", "valueMissing", "valueOf", "valueText", "valueType", "values", "vector-effect", "vectorEffect", "velocityAngular", "velocityExpansion", "velocityX", "velocityY", "vendor", "vendorSub", "verify", "version", "vertexAttrib1f", "vertexAttrib1fv", "vertexAttrib2f", "vertexAttrib2fv", "vertexAttrib3f", "vertexAttrib3fv", "vertexAttrib4f", "vertexAttrib4fv", "vertexAttribDivisorANGLE", "vertexAttribPointer", "vertical", "vertical-align", "verticalAlign", "verticalOverflow", "vibrate", "videoHeight", "videoTracks", "videoWidth", "view", "viewBox", "viewBoxString", "viewTarget", "viewTargetString", "viewport", "viewportAnchorX", "viewportAnchorY", "viewportElement", "visibility", "visibilityState", "visible", "vlinkColor", "voice", "volume", "vrml", "vspace", "w", "wand", "warn", "wasClean", "watch", "watchPosition", "webdriver", "webkitAddKey", "webkitAnimation", "webkitAnimationDelay", "webkitAnimationDirection", "webkitAnimationDuration", "webkitAnimationFillMode", "webkitAnimationIterationCount", "webkitAnimationName", "webkitAnimationPlayState", "webkitAnimationTimingFunction", "webkitAppearance", "webkitAudioContext", "webkitAudioDecodedByteCount", "webkitAudioPannerNode", "webkitBackfaceVisibility", "webkitBackground", "webkitBackgroundAttachment", "webkitBackgroundClip", "webkitBackgroundColor", "webkitBackgroundImage", "webkitBackgroundOrigin", "webkitBackgroundPosition", "webkitBackgroundPositionX", "webkitBackgroundPositionY", "webkitBackgroundRepeat", "webkitBackgroundSize", "webkitBackingStorePixelRatio", "webkitBorderImage", "webkitBorderImageOutset", "webkitBorderImageRepeat", "webkitBorderImageSlice", "webkitBorderImageSource", "webkitBorderImageWidth", "webkitBoxAlign", "webkitBoxDirection", "webkitBoxFlex", "webkitBoxOrdinalGroup", "webkitBoxOrient", "webkitBoxPack", "webkitBoxSizing", "webkitCancelAnimationFrame", "webkitCancelFullScreen", "webkitCancelKeyRequest", "webkitCancelRequestAnimationFrame", "webkitClearResourceTimings", "webkitClosedCaptionsVisible", "webkitConvertPointFromNodeToPage", "webkitConvertPointFromPageToNode", "webkitCreateShadowRoot", "webkitCurrentFullScreenElement", "webkitCurrentPlaybackTargetIsWireless", "webkitDirectionInvertedFromDevice", "webkitDisplayingFullscreen", "webkitEnterFullScreen", "webkitEnterFullscreen", "webkitExitFullScreen", "webkitExitFullscreen", "webkitExitPointerLock", "webkitFullScreenKeyboardInputAllowed", "webkitFullscreenElement", "webkitFullscreenEnabled", "webkitGenerateKeyRequest", "webkitGetAsEntry", "webkitGetDatabaseNames", "webkitGetEntries", "webkitGetEntriesByName", "webkitGetEntriesByType", "webkitGetFlowByName", "webkitGetGamepads", "webkitGetImageDataHD", "webkitGetNamedFlows", "webkitGetRegionFlowRanges", "webkitGetUserMedia", "webkitHasClosedCaptions", "webkitHidden", "webkitIDBCursor", "webkitIDBDatabase", "webkitIDBDatabaseError", "webkitIDBDatabaseException", "webkitIDBFactory", "webkitIDBIndex", "webkitIDBKeyRange", "webkitIDBObjectStore", "webkitIDBRequest", "webkitIDBTransaction", "webkitImageSmoothingEnabled", "webkitIndexedDB", "webkitInitMessageEvent", "webkitIsFullScreen", "webkitKeys", "webkitLineDashOffset", "webkitLockOrientation", "webkitMatchesSelector", "webkitMediaStream", "webkitNotifications", "webkitOfflineAudioContext", "webkitOrientation", "webkitPeerConnection00", "webkitPersistentStorage", "webkitPointerLockElement", "webkitPostMessage", "webkitPreservesPitch", "webkitPutImageDataHD", "webkitRTCPeerConnection", "webkitRegionOverset", "webkitRequestAnimationFrame", "webkitRequestFileSystem", "webkitRequestFullScreen", "webkitRequestFullscreen", "webkitRequestPointerLock", "webkitResolveLocalFileSystemURL", "webkitSetMediaKeys", "webkitSetResourceTimingBufferSize", "webkitShadowRoot", "webkitShowPlaybackTargetPicker", "webkitSlice", "webkitSpeechGrammar", "webkitSpeechGrammarList", "webkitSpeechRecognition", "webkitSpeechRecognitionError", "webkitSpeechRecognitionEvent", "webkitStorageInfo", "webkitSupportsFullscreen", "webkitTemporaryStorage", "webkitTextSizeAdjust", "webkitTransform", "webkitTransformOrigin", "webkitTransition", "webkitTransitionDelay", "webkitTransitionDuration", "webkitTransitionProperty", "webkitTransitionTimingFunction", "webkitURL", "webkitUnlockOrientation", "webkitUserSelect", "webkitVideoDecodedByteCount", "webkitVisibilityState", "webkitWirelessVideoPlaybackDisabled", "webkitdropzone", "webstore", "weight", "whatToShow", "wheelDelta", "wheelDeltaX", "wheelDeltaY", "which", "white-space", "whiteSpace", "wholeText", "widows", "width", "will-change", "willChange", "willValidate", "window", "withCredentials", "word-break", "word-spacing", "word-wrap", "wordBreak", "wordSpacing", "wordWrap", "wrap", "wrapKey", "write", "writeln", "writingMode", "x", "x1", "x2", "xChannelSelector", "xmlEncoding", "xmlStandalone", "xmlVersion", "xmlbase", "xmllang", "xmlspace", "y", "y1", "y2", "yChannelSelector", "yandex", "z", "z-index", "zIndex", "zoom", "zoomAndPan", "zoomRectScreen"];

  function nr(e, t) {
    function n(e) {
      p(t, e);
    }

    e.walk(new Sn(function (e) {
      e instanceof Ot && e.quote ? n(e.key) : e instanceof Ct && e.quote ? n(e.key.name) : e instanceof Et && ir(e.property, n);
    }));
  }

  function ir(e, t) {
    e.walk(new Sn(function (e) {
      return e instanceof _t ? ir(e.tail_node(), t) : e instanceof on ? t(e.value) : e instanceof At && (ir(e.consequent, t), ir(e.alternative, t)), !0;
    }));
  }

  function rr(e, t) {
    var n = (t = o(t, {
      builtins: !1,
      cache: null,
      debug: !1,
      keep_quoted: !1,
      only_cache: !1,
      regex: null,
      reserved: null,
      undeclared: !1
    }, !0)).reserved;
    Array.isArray(n) || (n = [n]);
    var i = new Set(n);
    t.builtins || function (e) {
      tr.forEach(i);
      var t = {},
          n = "object" == (typeof global === "undefined" ? "undefined" : _typeof(global)) ? global : self;

      function i(t) {
        e.add(t);
      }

      ["Symbol", "Map", "Promise", "Proxy", "Reflect", "Set", "WeakMap", "WeakSet"].forEach(function (e) {
        t[e] = n[e] || new Function();
      }), ["null", "true", "false", "Infinity", "-Infinity", "undefined"].forEach(i), [Object, Array, Function, Number, String, Boolean, Error, Math, Date, RegExp, t.Symbol, ArrayBuffer, DataView, decodeURI, decodeURIComponent, encodeURI, encodeURIComponent, eval, EvalError, Float32Array, Float64Array, Int8Array, Int16Array, Int32Array, isFinite, isNaN, JSON, t.Map, parseFloat, parseInt, t.Promise, t.Proxy, RangeError, ReferenceError, t.Reflect, t.Set, SyntaxError, TypeError, Uint8Array, Uint8ClampedArray, Uint16Array, Uint32Array, URIError, t.WeakMap, t.WeakSet].forEach(function (e) {
        Object.getOwnPropertyNames(e).map(i), e.prototype && Object.getOwnPropertyNames(e.prototype).map(i);
      });
    }(i);
    var r,
        a = -1;
    t.cache ? (r = t.cache.props).forEach(function (e) {
      i.add(e);
    }) : r = new Map();
    var s,
        u = t.regex && new RegExp(t.regex),
        c = !1 !== t.debug;
    c && (s = !0 === t.debug ? "" : t.debug);
    var l = new Set(),
        f = new Set(),
        p = "strict" === t.keep_quoted;
    return e.walk(new Sn(function (e) {
      if (e instanceof Ot) "string" != typeof e.key || p && e.quote || m(e.key);else if (e instanceof Ct) p && e.key.end.quote || m(e.key.name);else if (e instanceof mt) {
        var n = !!t.undeclared;

        if (!n) {
          for (var i = e; i.expression;) {
            i = i.expression;
          }

          n = !(i.thedef && i.thedef.undeclared);
        }

        !n || p && e.quote || m(e.property);
      } else e instanceof Et ? p || ir(e.property, m) : e instanceof ft && "Object.defineProperty" == e.expression.print_to_string() && ir(e.args[1], m);
    })), e.transform(new An(function (e) {
      e instanceof Ot ? "string" != typeof e.key || p && e.quote || (e.key = E(e.key)) : e instanceof Ct ? p && e.key.end.quote || (e.key.name = E(e.key.name)) : e instanceof mt ? p && e.quote || (e.property = E(e.property)) : !t.keep_quoted && e instanceof Et ? e.property = h(e.property) : e instanceof ft && "Object.defineProperty" == e.expression.print_to_string() && (e.args[1] = h(e.args[1]));
    }));

    function _(e) {
      return !f.has(e) && !i.has(e) && (t.only_cache ? r.has(e) : !/^-?[0-9]+(\.[0-9]+)?(e[+-][0-9]+)?$/.test(e));
    }

    function d(e) {
      return !(u && !u.test(e)) && !i.has(e) && (r.has(e) || l.has(e));
    }

    function m(e) {
      _(e) && l.add(e), d(e) || f.add(e);
    }

    function E(e) {
      if (!d(e)) return e;
      var t = r.get(e);

      if (!t) {
        if (c) {
          var n = "_$" + e + "$" + s + "_";
          _(n) && (t = n);
        }

        if (!t) do {
          t = Un(++a);
        } while (!_(t));
        r.set(e, t);
      }

      return t;
    }

    function h(e) {
      return e.transform(new An(function (e) {
        if (e instanceof _t) {
          var t = e.expressions.length - 1;
          e.expressions[t] = h(e.expressions[t]);
        } else e instanceof on ? e.value = E(e.value) : e instanceof At && (e.consequent = h(e.consequent), e.alternative = h(e.alternative));

        return e;
      }));
    }
  }

  var or = "undefined" == typeof atob ? function (e) {
    return Buffer.from(e, "base64").toString();
  } : atob,
      ar = "undefined" == typeof btoa ? function (e) {
    return Buffer.from(e).toString("base64");
  } : btoa;

  function sr(e, t, n) {
    t[e] && n.forEach(function (n) {
      t[n] && ("object" != _typeof(t[n]) && (t[n] = {}), e in t[n] || (t[n][e] = t[e]));
    });
  }

  function ur(e) {
    e && ("props" in e ? e.props instanceof Map || (e.props = function (e) {
      var t = new Map();

      for (var n in e) {
        D(e, n) && "$" === n.charAt(0) && t.set(n.substr(1), e[n]);
      }

      return t;
    }(e.props)) : e.props = new Map());
  }

  function cr(e) {
    return {
      props: (t = e.props, n = Object.create(null), t.forEach(function (e, t) {
        n["$" + t] = e;
      }), n)
    };
    var t, n;
  }

  function lr(e, n) {
    var i,
        r,
        a = le.warn_function;

    try {
      var s,
          u = (n = o(n, {
        compress: {},
        ecma: void 0,
        enclose: !1,
        ie8: !1,
        keep_classnames: void 0,
        keep_fnames: !1,
        mangle: {},
        module: !1,
        nameCache: null,
        output: {},
        parse: {},
        rename: void 0,
        safari10: !1,
        sourceMap: !1,
        timings: !1,
        toplevel: !1,
        warnings: !1,
        wrap: !1
      }, !0)).timings && {
        start: Date.now()
      };
      void 0 === n.keep_classnames && (n.keep_classnames = n.keep_fnames), void 0 === n.rename && (n.rename = n.compress && n.mangle), sr("ecma", n, ["parse", "compress", "output"]), sr("ie8", n, ["compress", "mangle", "output"]), sr("keep_classnames", n, ["compress", "mangle"]), sr("keep_fnames", n, ["compress", "mangle"]), sr("module", n, ["parse", "compress", "mangle"]), sr("safari10", n, ["mangle", "output"]), sr("toplevel", n, ["compress", "mangle"]), sr("warnings", n, ["compress"]), n.mangle && (n.mangle = o(n.mangle, {
        cache: n.nameCache && (n.nameCache.vars || {}),
        eval: !1,
        ie8: !1,
        keep_classnames: !1,
        keep_fnames: !1,
        module: !1,
        properties: !1,
        reserved: [],
        safari10: !1,
        toplevel: !1
      }, !0), n.mangle.properties && ("object" != _typeof(n.mangle.properties) && (n.mangle.properties = {}), n.mangle.properties.keep_quoted && (s = n.mangle.properties.reserved, Array.isArray(s) || (s = []), n.mangle.properties.reserved = s), !n.nameCache || "cache" in n.mangle.properties || (n.mangle.properties.cache = n.nameCache.props || {})), ur(n.mangle.cache), ur(n.mangle.properties.cache)), n.sourceMap && (n.sourceMap = o(n.sourceMap, {
        asObject: !1,
        content: null,
        filename: null,
        includeSources: !1,
        root: null,
        url: null
      }, !0));
      var c,
          l = [];
      if (n.warnings && !le.warn_function && (le.warn_function = function (e) {
        l.push(e);
      }), u && (u.parse = Date.now()), e instanceof we) c = e;else {
        for (var f in "string" == typeof e && (e = [e]), n.parse = n.parse || {}, n.parse.toplevel = null, e) {
          if (D(e, f) && (n.parse.filename = f, n.parse.toplevel = se(e[f], n.parse), n.sourceMap && "inline" == n.sourceMap.content)) {
            if (Object.keys(e).length > 1) throw new Error("inline source map only works with singular input");
            n.sourceMap.content = (i = e[f], r = void 0, (r = /(?:^|[^.])\/\/# sourceMappingURL=data:application\/json(;[\w=-]*)?;base64,([+/0-9A-Za-z]*=*)\s*$/.exec(i)) ? or(r[2]) : (le.warn("inline source map not found"), null));
          }
        }

        c = n.parse.toplevel;
      }
      s && "strict" !== n.mangle.properties.keep_quoted && nr(c, s), n.wrap && (c = c.wrap_commonjs(n.wrap)), n.enclose && (c = c.wrap_enclose(n.enclose)), u && (u.rename = Date.now()), u && (u.compress = Date.now()), n.compress && (c = new Qn(n.compress).compress(c)), u && (u.scope = Date.now()), n.mangle && c.figure_out_scope(n.mangle), u && (u.mangle = Date.now()), n.mangle && (Un.reset(), c.compute_char_frequency(n.mangle), c.mangle_names(n.mangle)), u && (u.properties = Date.now()), n.mangle && n.mangle.properties && (c = rr(c, n.mangle.properties)), u && (u.output = Date.now());
      var p = {};

      if (n.output.ast && (p.ast = c), !D(n.output, "code") || n.output.code) {
        if (n.sourceMap && ("string" == typeof n.sourceMap.content && (n.sourceMap.content = JSON.parse(n.sourceMap.content)), n.output.source_map = function (e) {
          e = o(e, {
            file: null,
            root: null,
            orig: null,
            orig_line_diff: 0,
            dest_line_diff: 0
          });
          var n = new t.SourceMapGenerator({
            file: e.file,
            sourceRoot: e.root
          }),
              i = e.orig && new t.SourceMapConsumer(e.orig);
          return i && i.sources.forEach(function (e) {
            var t = i.sourceContentFor(e, !0);
            t && n.setSourceContent(e, t);
          }), {
            add: function add(t, r, o, a, s, u) {
              if (i) {
                var c = i.originalPositionFor({
                  line: a,
                  column: s
                });
                if (null === c.source) return;
                t = c.source, a = c.line, s = c.column, u = c.name || u;
              }

              n.addMapping({
                generated: {
                  line: r + e.dest_line_diff,
                  column: o
                },
                original: {
                  line: a + e.orig_line_diff,
                  column: s
                },
                source: t,
                name: u
              });
            },
            get: function get() {
              return n;
            },
            toString: function toString() {
              return JSON.stringify(n.toJSON());
            }
          };
        }({
          file: n.sourceMap.filename,
          orig: n.sourceMap.content,
          root: n.sourceMap.root
        }), n.sourceMap.includeSources)) {
          if (e instanceof we) throw new Error("original source content unavailable");

          for (var f in e) {
            D(e, f) && n.output.source_map.get().setSourceContent(f, e[f]);
          }
        }

        delete n.output.ast, delete n.output.code;

        var _ = kn(n.output);

        if (c.print(_), p.code = _.get(), n.sourceMap) if (n.sourceMap.asObject ? p.map = n.output.source_map.get().toJSON() : p.map = n.output.source_map.toString(), "inline" == n.sourceMap.url) {
          var d = "object" == _typeof(p.map) ? JSON.stringify(p.map) : p.map;
          p.code += "\n//# sourceMappingURL=data:application/json;charset=utf-8;base64," + ar(d);
        } else n.sourceMap.url && (p.code += "\n//# sourceMappingURL=" + n.sourceMap.url);
      }

      return n.nameCache && n.mangle && (n.mangle.cache && (n.nameCache.vars = cr(n.mangle.cache)), n.mangle.properties && n.mangle.properties.cache && (n.nameCache.props = cr(n.mangle.properties.cache))), u && (u.end = Date.now(), p.timings = {
        parse: .001 * (u.rename - u.parse),
        rename: .001 * (u.compress - u.rename),
        compress: .001 * (u.scope - u.compress),
        scope: .001 * (u.mangle - u.scope),
        mangle: .001 * (u.properties - u.mangle),
        properties: .001 * (u.output - u.properties),
        output: .001 * (u.end - u.output),
        total: .001 * (u.end - u.start)
      }), l.length && (p.warnings = l), p;
    } catch (e) {
      return {
        error: e
      };
    } finally {
      le.warn_function = a;
    }
  }

  function fr(e) {
    var t = lr("", e);
    return t.error && t.error.defs;
  }

  !function () {
    var e = function e(_e17) {
      for (var t = !0, n = 0; n < _e17.length; n++) {
        t && _e17[n] instanceof fe && _e17[n].body instanceof on ? _e17[n] = new _e({
          start: _e17[n].start,
          end: _e17[n].end,
          value: _e17[n].body.value
        }) : !t || _e17[n] instanceof fe && _e17[n].body instanceof on || (t = !1);
      }

      return _e17;
    },
        t = {
      Program: function Program(t) {
        return new we({
          start: i(t),
          end: r(t),
          body: e(t.body.map(s))
        });
      },
      ArrayPattern: function ArrayPattern(e) {
        return new Pe({
          start: i(e),
          end: r(e),
          names: e.elements.map(function (e) {
            return null === e ? new _n() : s(e);
          }),
          is_array: !0
        });
      },
      ObjectPattern: function ObjectPattern(e) {
        return new Pe({
          start: i(e),
          end: r(e),
          names: e.properties.map(s),
          is_array: !1
        });
      },
      AssignmentPattern: function AssignmentPattern(e) {
        var t = St;

        if (a.length > 2) {
          var n = a[a.length - 2];
          "FunctionDeclaration" !== n.type && "FunctionExpression" !== n.type && "ArrowFunctionExpression" !== n.type || (t = Tt);
        }

        return new t({
          start: i(e),
          end: r(e),
          left: s(e.left),
          operator: "=",
          right: s(e.right)
        });
      },
      SpreadElement: function SpreadElement(e) {
        return new Ne({
          start: i(e),
          end: r(e),
          expression: s(e.argument)
        });
      },
      RestElement: function RestElement(e) {
        return new Ne({
          start: i(e),
          end: r(e),
          expression: s(e.argument)
        });
      },
      TemplateElement: function TemplateElement(e) {
        return new Ue({
          start: i(e),
          end: r(e),
          value: e.value.cooked,
          raw: e.value.raw
        });
      },
      TemplateLiteral: function TemplateLiteral(e) {
        for (var t = [], n = 0; n < e.quasis.length; n++) {
          t.push(s(e.quasis[n])), e.expressions[n] && t.push(s(e.expressions[n]));
        }

        return new Ke({
          start: i(e),
          end: r(e),
          segments: t
        });
      },
      TaggedTemplateExpression: function TaggedTemplateExpression(e) {
        return new Be({
          start: i(e),
          end: r(e),
          template_string: s(e.quasi),
          prefix: s(e.tag)
        });
      },
      FunctionDeclaration: function FunctionDeclaration(t) {
        return new Ve({
          start: i(t),
          end: r(t),
          name: s(t.id),
          argnames: t.params.map(s),
          is_generator: t.generator,
          async: t.async,
          body: e(s(t.body).body)
        });
      },
      FunctionExpression: function FunctionExpression(t) {
        return new Ie({
          start: i(t),
          end: r(t),
          name: s(t.id),
          argnames: t.params.map(s),
          is_generator: t.generator,
          async: t.async,
          body: e(s(t.body).body)
        });
      },
      ArrowFunctionExpression: function ArrowFunctionExpression(e) {
        return new Le({
          start: i(e),
          end: r(e),
          argnames: e.params.map(s),
          body: s(e.body),
          async: e.async
        });
      },
      ExpressionStatement: function ExpressionStatement(e) {
        return new de({
          start: i(e),
          end: r(e),
          body: s(e.expression)
        });
      },
      TryStatement: function TryStatement(e) {
        var t = e.handlers || [e.handler];
        if (t.length > 1 || e.guardedHandlers && e.guardedHandlers.length) throw new Error("Multiple catch clauses are not supported.");
        return new et({
          start: i(e),
          end: r(e),
          body: s(e.block).body,
          bcatch: s(t[0]),
          bfinally: e.finalizer ? new nt(s(e.finalizer)) : null
        });
      },
      Property: function Property(e) {
        var t = e.key,
            n = {
          start: i(t || e.value),
          end: r(e.value),
          key: "Identifier" == t.type ? t.name : t.value,
          value: s(e.value)
        };
        return e.computed && (n.key = s(e.key)), e.method ? (n.is_generator = e.value.generator, n.async = e.value.async, e.computed ? n.key = s(e.key) : n.key = new Ht({
          name: n.key
        }), new Rt(n)) : "init" == e.kind ? ("Identifier" != t.type && "Literal" != t.type && (n.key = s(t)), new Ot(n)) : ("string" != typeof n.key && "number" != typeof n.key || (n.key = new Ht({
          name: n.key
        })), n.value = new ke(n.value), "get" == e.kind ? new Mt(n) : "set" == e.kind ? new Ft(n) : "method" == e.kind ? (n.async = e.value.async, n.is_generator = e.value.generator, n.quote = e.computed ? '"' : null, new Rt(n)) : void 0);
      },
      MethodDefinition: function MethodDefinition(e) {
        var t = {
          start: i(e),
          end: r(e),
          key: e.computed ? s(e.key) : new Ht({
            name: e.key.name || e.key.value
          }),
          value: s(e.value),
          static: e.static
        };
        return "get" == e.kind ? new Mt(t) : "set" == e.kind ? new Ft(t) : (t.is_generator = e.value.generator, t.async = e.value.async, new Rt(t));
      },
      ArrayExpression: function ArrayExpression(e) {
        return new bt({
          start: i(e),
          end: r(e),
          elements: e.elements.map(function (e) {
            return null === e ? new _n() : s(e);
          })
        });
      },
      ObjectExpression: function ObjectExpression(e) {
        return new yt({
          start: i(e),
          end: r(e),
          properties: e.properties.map(function (e) {
            return "SpreadElement" === e.type ? s(e) : (e.type = "Property", s(e));
          })
        });
      },
      SequenceExpression: function SequenceExpression(e) {
        return new _t({
          start: i(e),
          end: r(e),
          expressions: e.expressions.map(s)
        });
      },
      MemberExpression: function MemberExpression(e) {
        return new (e.computed ? Et : mt)({
          start: i(e),
          end: r(e),
          property: e.computed ? s(e.property) : e.property.name,
          expression: s(e.object)
        });
      },
      SwitchCase: function SwitchCase(e) {
        return new (e.test ? Qe : Je)({
          start: i(e),
          end: r(e),
          expression: s(e.test),
          body: e.consequent.map(s)
        });
      },
      VariableDeclaration: function VariableDeclaration(e) {
        return new ("const" === e.kind ? at : "let" === e.kind ? ot : rt)({
          start: i(e),
          end: r(e),
          definitions: e.declarations.map(s)
        });
      },
      ImportDeclaration: function ImportDeclaration(e) {
        var t = null,
            n = null;
        return e.specifiers.forEach(function (e) {
          "ImportSpecifier" === e.type ? (n || (n = []), n.push(new st({
            start: i(e),
            end: r(e),
            foreign_name: s(e.imported),
            name: s(e.local)
          }))) : "ImportDefaultSpecifier" === e.type ? t = s(e.local) : "ImportNamespaceSpecifier" === e.type && (n || (n = []), n.push(new st({
            start: i(e),
            end: r(e),
            foreign_name: new $t({
              name: "*"
            }),
            name: s(e.local)
          })));
        }), new ut({
          start: i(e),
          end: r(e),
          imported_name: t,
          imported_names: n,
          module_name: s(e.source)
        });
      },
      ExportAllDeclaration: function ExportAllDeclaration(e) {
        return new ct({
          start: i(e),
          end: r(e),
          exported_names: [new st({
            name: new Qt({
              name: "*"
            }),
            foreign_name: new Qt({
              name: "*"
            })
          })],
          module_name: s(e.source)
        });
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(e) {
        return new ct({
          start: i(e),
          end: r(e),
          exported_definition: s(e.declaration),
          exported_names: e.specifiers && e.specifiers.length ? e.specifiers.map(function (e) {
            return new st({
              foreign_name: s(e.exported),
              name: s(e.local)
            });
          }) : null,
          module_name: s(e.source)
        });
      },
      ExportDefaultDeclaration: function ExportDefaultDeclaration(e) {
        return new ct({
          start: i(e),
          end: r(e),
          exported_value: s(e.declaration),
          is_default: !0
        });
      },
      Literal: function Literal(e) {
        var t = e.value,
            n = {
          start: i(e),
          end: r(e)
        },
            o = e.regex;
        if (o && o.pattern) return n.value = {
          source: o.pattern,
          flags: o.flags
        }, new un(n);

        if (o) {
          var _i9 = e.raw || t,
              _r5 = _i9.match(/^\/(.*)\/(\w*)$/);

          if (!_r5) throw new Error("Invalid regex source " + _i9);

          var _r6 = _slicedToArray(_r5, 3),
              _o2 = _r6[0],
              _a2 = _r6[1],
              _s = _r6[2];

          return n.value = {
            source: _a2,
            flags: _s
          }, new un(n);
        }

        if (null === t) return new ln(n);

        switch (_typeof(t)) {
          case "string":
            return n.value = t, new on(n);

          case "number":
            return n.value = t, new an(n);

          case "boolean":
            return new (t ? hn : En)(n);
        }
      },
      MetaProperty: function MetaProperty(e) {
        if ("new" === e.meta.name && "target" === e.property.name) return new It({
          start: i(e),
          end: r(e)
        });
      },
      Identifier: function Identifier(e) {
        var t = a[a.length - 2];
        return new ("LabeledStatement" == t.type ? jt : "VariableDeclarator" == t.type && t.id === e ? "const" == t.kind ? Bt : "let" == t.kind ? Kt : Vt : /Import.*Specifier/.test(t.type) ? t.local === e ? qt : $t : "ExportSpecifier" == t.type ? t.local === e ? Jt : Qt : "FunctionExpression" == t.type ? t.id === e ? Xt : Ut : "FunctionDeclaration" == t.type ? t.id === e ? Gt : Ut : "ArrowFunctionExpression" == t.type ? t.params.includes(e) ? Ut : Zt : "ClassExpression" == t.type ? t.id === e ? Wt : Zt : "Property" == t.type ? t.key === e && t.computed || t.value === e ? Zt : Ht : "ClassDeclaration" == t.type ? t.id === e ? zt : Zt : "MethodDefinition" == t.type ? t.computed ? Zt : Ht : "CatchClause" == t.type ? Yt : "BreakStatement" == t.type || "ContinueStatement" == t.type ? en : Zt)({
          start: i(e),
          end: r(e),
          name: e.name
        });
      },
      BigIntLiteral: function BigIntLiteral(e) {
        return new sn({
          start: i(e),
          end: r(e),
          value: e.value
        });
      }
    };

    function n(e) {
      if ("Literal" == e.type) return null != e.raw ? e.raw : e.value + "";
    }

    function i(e) {
      var t = e.loc,
          i = t && t.start,
          r = e.range;
      return new ce({
        file: t && t.source,
        line: i && i.line,
        col: i && i.column,
        pos: r ? r[0] : e.start,
        endline: i && i.line,
        endcol: i && i.column,
        endpos: r ? r[0] : e.start,
        raw: n(e)
      });
    }

    function r(e) {
      var t = e.loc,
          i = t && t.end,
          r = e.range;
      return new ce({
        file: t && t.source,
        line: i && i.line,
        col: i && i.column,
        pos: r ? r[1] : e.end,
        endline: i && i.line,
        endcol: i && i.column,
        endpos: r ? r[1] : e.end,
        raw: n(e)
      });
    }

    function o(e, n, o) {
      var a = "function From_Moz_" + e + "(M){\n";
      a += "return new U2." + n.name + "({\nstart: my_start_token(M),\nend: my_end_token(M)";
      var c = "function To_Moz_" + e + "(M){\n";
      c += "return {\ntype: " + JSON.stringify(e), o && o.split(/\s*,\s*/).forEach(function (e) {
        var t = /([a-z0-9$_]+)([=@>%])([a-z0-9$_]+)/i.exec(e);
        if (!t) throw new Error("Can't understand property map: " + e);
        var n = t[1],
            i = t[2],
            r = t[3];

        switch (a += ",\n" + r + ": ", c += ",\n" + n + ": ", i) {
          case "@":
            a += "M." + n + ".map(from_moz)", c += "M." + r + ".map(to_moz)";
            break;

          case ">":
            a += "from_moz(M." + n + ")", c += "to_moz(M." + r + ")";
            break;

          case "=":
            a += "M." + n, c += "M." + r;
            break;

          case "%":
            a += "from_moz(M." + n + ").body", c += "to_moz_block(M)";
            break;

          default:
            throw new Error("Can't understand operator in propmap: " + e);
        }
      }), a += "\n})\n}", c += "\n}\n}", a = new Function("U2", "my_start_token", "my_end_token", "from_moz", "return(" + a + ")")(yn, i, r, s), c = new Function("to_moz", "to_moz_block", "to_moz_scope", "return(" + c + ")")(l, p, _), t[e] = a, u(n, c);
    }

    t.UpdateExpression = t.UnaryExpression = function (e) {
      return new (("prefix" in e ? e.prefix : "UnaryExpression" == e.type) ? Dt : gt)({
        start: i(e),
        end: r(e),
        operator: e.operator,
        expression: s(e.argument)
      });
    }, t.ClassDeclaration = t.ClassExpression = function (e) {
      return new ("ClassDeclaration" === e.type ? Nt : xt)({
        start: i(e),
        end: r(e),
        name: s(e.id),
        extends: s(e.superClass),
        properties: e.body.body.map(s)
      });
    }, o("EmptyStatement", ge), o("BlockStatement", De, "body@body"), o("IfStatement", $e, "test>condition, consequent>body, alternate>alternative"), o("LabeledStatement", Ae, "label>label, body>body"), o("BreakStatement", Ye, "label>label"), o("ContinueStatement", qe, "label>label"), o("WithStatement", Me, "object>expression, body>body"), o("SwitchStatement", je, "discriminant>expression, cases@body"), o("ReturnStatement", Xe, "argument>value"), o("ThrowStatement", ze, "argument>value"), o("WhileStatement", ye, "test>condition, body>body"), o("DoWhileStatement", be, "test>condition, body>body"), o("ForStatement", Ce, "init>init, test>condition, update>step, body>body"), o("ForInStatement", Oe, "left>init, right>object, body>body"), o("ForOfStatement", Fe, "left>init, right>object, body>body, await=await"), o("AwaitExpression", Dn, "argument>expression"), o("YieldExpression", gn, "argument>expression, delegate=is_star"), o("DebuggerStatement", pe), o("VariableDeclarator", lt, "id>name, init>value"), o("CatchClause", tt, "param>argname, body%body"), o("ThisExpression", tn), o("Super", nn), o("BinaryExpression", St, "operator=operator, left>left, right>right"), o("LogicalExpression", St, "operator=operator, left>left, right>right"), o("AssignmentExpression", vt, "operator=operator, left>left, right>right"), o("ConditionalExpression", At, "test>condition, consequent>consequent, alternate>alternative"), o("NewExpression", pt, "callee>expression, arguments@args"), o("CallExpression", ft, "callee>expression, arguments@args"), u(we, function (e) {
      return _("Program", e);
    }), u(Ne, function (e, t) {
      return {
        type: f() ? "RestElement" : "SpreadElement",
        argument: l(e.expression)
      };
    }), u(Be, function (e) {
      return {
        type: "TaggedTemplateExpression",
        tag: l(e.prefix),
        quasi: l(e.template_string)
      };
    }), u(Ke, function (e) {
      for (var t = [], n = [], i = 0; i < e.segments.length; i++) {
        i % 2 != 0 ? n.push(l(e.segments[i])) : t.push({
          type: "TemplateElement",
          value: {
            raw: e.segments[i].raw,
            cooked: e.segments[i].value
          },
          tail: i === e.segments.length - 1
        });
      }

      return {
        type: "TemplateLiteral",
        quasis: t,
        expressions: n
      };
    }), u(Ve, function (e) {
      return {
        type: "FunctionDeclaration",
        id: l(e.name),
        params: e.argnames.map(l),
        generator: e.is_generator,
        async: e.async,
        body: _("BlockStatement", e)
      };
    }), u(Ie, function (e, t) {
      var n = void 0 !== t.is_generator ? t.is_generator : e.is_generator;
      return {
        type: "FunctionExpression",
        id: l(e.name),
        params: e.argnames.map(l),
        generator: n,
        async: e.async,
        body: _("BlockStatement", e)
      };
    }), u(Le, function (e) {
      var t = e.body instanceof Array ? {
        type: "BlockStatement",
        body: e.body.map(l)
      } : l(e.body);
      return {
        type: "ArrowFunctionExpression",
        params: e.argnames.map(l),
        async: e.async,
        body: t
      };
    }), u(Pe, function (e) {
      return e.is_array ? {
        type: "ArrayPattern",
        elements: e.names.map(l)
      } : {
        type: "ObjectPattern",
        properties: e.names.map(l)
      };
    }), u(_e, function (e) {
      return {
        type: "ExpressionStatement",
        expression: {
          type: "Literal",
          value: e.value
        }
      };
    }), u(de, function (e) {
      return {
        type: "ExpressionStatement",
        expression: l(e.body)
      };
    }), u(Ze, function (e) {
      return {
        type: "SwitchCase",
        test: l(e.expression),
        consequent: e.body.map(l)
      };
    }), u(et, function (e) {
      return {
        type: "TryStatement",
        block: p(e),
        handler: l(e.bcatch),
        guardedHandlers: [],
        finalizer: l(e.bfinally)
      };
    }), u(tt, function (e) {
      return {
        type: "CatchClause",
        param: l(e.argname),
        guard: null,
        body: p(e)
      };
    }), u(it, function (e) {
      return {
        type: "VariableDeclaration",
        kind: e instanceof at ? "const" : e instanceof ot ? "let" : "var",
        declarations: e.definitions.map(l)
      };
    }), u(ct, function (e) {
      return e.exported_names ? "*" === e.exported_names[0].name.name ? {
        type: "ExportAllDeclaration",
        source: l(e.module_name)
      } : {
        type: "ExportNamedDeclaration",
        specifiers: e.exported_names.map(function (e) {
          return {
            type: "ExportSpecifier",
            exported: l(e.foreign_name),
            local: l(e.name)
          };
        }),
        declaration: l(e.exported_definition),
        source: l(e.module_name)
      } : {
        type: e.is_default ? "ExportDefaultDeclaration" : "ExportNamedDeclaration",
        declaration: l(e.exported_value || e.exported_definition)
      };
    }), u(ut, function (e) {
      var t = [];
      return e.imported_name && t.push({
        type: "ImportDefaultSpecifier",
        local: l(e.imported_name)
      }), e.imported_names && "*" === e.imported_names[0].foreign_name.name ? t.push({
        type: "ImportNamespaceSpecifier",
        local: l(e.imported_names[0].name)
      }) : e.imported_names && e.imported_names.forEach(function (e) {
        t.push({
          type: "ImportSpecifier",
          local: l(e.name),
          imported: l(e.foreign_name)
        });
      }), {
        type: "ImportDeclaration",
        specifiers: t,
        source: l(e.module_name)
      };
    }), u(_t, function (e) {
      return {
        type: "SequenceExpression",
        expressions: e.expressions.map(l)
      };
    }), u(dt, function (e) {
      var t = e instanceof Et;
      return {
        type: "MemberExpression",
        object: l(e.expression),
        computed: t,
        property: t ? l(e.property) : {
          type: "Identifier",
          name: e.property
        }
      };
    }), u(ht, function (e) {
      return {
        type: "++" == e.operator || "--" == e.operator ? "UpdateExpression" : "UnaryExpression",
        operator: e.operator,
        prefix: e instanceof Dt,
        argument: l(e.expression)
      };
    }), u(St, function (e) {
      return "=" == e.operator && f() ? {
        type: "AssignmentPattern",
        left: l(e.left),
        right: l(e.right)
      } : {
        type: "&&" == e.operator || "||" == e.operator ? "LogicalExpression" : "BinaryExpression",
        left: l(e.left),
        operator: e.operator,
        right: l(e.right)
      };
    }), u(bt, function (e) {
      return {
        type: "ArrayExpression",
        elements: e.elements.map(l)
      };
    }), u(yt, function (e) {
      return {
        type: "ObjectExpression",
        properties: e.properties.map(l)
      };
    }), u(Ct, function (e, t) {
      var n,
          i = e.key instanceof le ? l(e.key) : {
        type: "Identifier",
        value: e.key
      };
      "number" == typeof e.key && (i = {
        type: "Literal",
        value: Number(e.key)
      }), "string" == typeof e.key && (i = {
        type: "Identifier",
        name: e.key
      });
      var r = "string" == typeof e.key || "number" == typeof e.key,
          o = !r && (!(e.key instanceof kt) || e.key instanceof Zt);
      return e instanceof Ot ? (n = "init", o = !r) : e instanceof Mt ? n = "get" : e instanceof Ft && (n = "set"), t instanceof wt ? {
        type: "MethodDefinition",
        computed: o,
        kind: n,
        static: e.static,
        key: l(e.key),
        value: l(e.value)
      } : {
        type: "Property",
        computed: o,
        kind: n,
        key: i,
        value: l(e.value)
      };
    }), u(Rt, function (e, t) {
      return t instanceof yt ? {
        type: "Property",
        computed: !(e.key instanceof kt) || e.key instanceof Zt,
        kind: "init",
        method: !0,
        shorthand: !1,
        key: l(e.key),
        value: l(e.value)
      } : {
        type: "MethodDefinition",
        computed: !(e.key instanceof kt) || e.key instanceof Zt,
        kind: "constructor" === e.key ? "constructor" : "method",
        static: e.static,
        key: l(e.key),
        value: l(e.value)
      };
    }), u(wt, function (e) {
      return {
        type: e instanceof xt ? "ClassExpression" : "ClassDeclaration",
        superClass: l(e.extends),
        id: e.name ? l(e.name) : null,
        body: {
          type: "ClassBody",
          body: e.properties.map(l)
        }
      };
    }), u(It, function (e) {
      return {
        type: "MetaProperty",
        meta: {
          type: "Identifier",
          name: "new"
        },
        property: {
          type: "Identifier",
          name: "target"
        }
      };
    }), u(kt, function (e, t) {
      if (e instanceof Ht && t.quote) return {
        type: "Literal",
        value: e.name
      };
      var n = e.definition();
      return {
        type: "Identifier",
        name: n ? n.mangled_name || n.name : e.name
      };
    }), u(un, function (e) {
      var t = e.value.source,
          n = e.value.flags;
      return {
        type: "Literal",
        value: null,
        raw: e.print_to_string(),
        regex: {
          pattern: t,
          flags: n
        }
      };
    }), u(rn, function (e) {
      var t = e.value;
      return "number" == typeof t && (t < 0 || 0 === t && 1 / t < 0) ? {
        type: "UnaryExpression",
        operator: "-",
        prefix: !0,
        argument: {
          type: "Literal",
          value: -t,
          raw: e.start.raw
        }
      } : {
        type: "Literal",
        value: t,
        raw: e.start.raw
      };
    }), u(cn, function (e) {
      return {
        type: "Identifier",
        name: String(e.value)
      };
    }), u(sn, function (e) {
      return {
        type: "BigIntLiteral",
        value: e.value
      };
    }), mn.DEFMETHOD("to_mozilla_ast", rn.prototype.to_mozilla_ast), ln.DEFMETHOD("to_mozilla_ast", rn.prototype.to_mozilla_ast), _n.DEFMETHOD("to_mozilla_ast", function () {
      return null;
    }), he.DEFMETHOD("to_mozilla_ast", De.prototype.to_mozilla_ast), xe.DEFMETHOD("to_mozilla_ast", Ie.prototype.to_mozilla_ast);
    var a = null;

    function s(e) {
      a.push(e);
      var n = null != e ? t[e.type](e) : null;
      return a.pop(), n;
    }

    function u(e, t) {
      e.DEFMETHOD("to_mozilla_ast", function (e) {
        return n = this, i = t(this, e), r = n.start, o = n.end, r && o ? (null != r.pos && null != o.endpos && (i.range = [r.pos, o.endpos]), r.line && (i.loc = {
          start: {
            line: r.line,
            column: r.col
          },
          end: o.endline ? {
            line: o.endline,
            column: o.endcol
          } : null
        }, r.file && (i.loc.source = r.file)), i) : i;
        var n, i, r, o;
      });
    }

    le.from_mozilla_ast = function (e) {
      var t = a;
      a = [];
      var n = s(e);
      return a = t, n;
    };

    var c = null;

    function l(e) {
      null === c && (c = []), c.push(e);
      var t = null != e ? e.to_mozilla_ast(c[c.length - 2]) : null;
      return c.pop(), 0 === c.length && (c = null), t;
    }

    function f() {
      for (var e = c.length; e--;) {
        if (c[e] instanceof Pe) return !0;
      }

      return !1;
    }

    function p(e) {
      return {
        type: "BlockStatement",
        body: e.body.map(l)
      };
    }

    function _(e, t) {
      var n = t.body.map(l);
      return t.body[0] instanceof de && t.body[0].body instanceof on && n.unshift(l(new ge(t.body[0]))), {
        type: e,
        body: n
      };
    }
  }(), e.AST_Accessor = ke, e.AST_Array = bt, e.AST_Arrow = Le, e.AST_Assign = vt, e.AST_Atom = cn, e.AST_Await = Dn, e.AST_Binary = St, e.AST_Block = he, e.AST_BlockStatement = De, e.AST_Boolean = mn, e.AST_Break = Ye, e.AST_Call = ft, e.AST_Case = Qe, e.AST_Catch = tt, e.AST_Class = wt, e.AST_ClassExpression = xt, e.AST_ConciseMethod = Rt, e.AST_Conditional = At, e.AST_Const = at, e.AST_Constant = rn, e.AST_Continue = qe, e.AST_DWLoop = Te, e.AST_Debugger = pe, e.AST_DefClass = Nt, e.AST_Default = Je, e.AST_DefaultAssign = Tt, e.AST_Definitions = it, e.AST_Defun = Ve, e.AST_Destructuring = Pe, e.AST_Directive = _e, e.AST_Do = be, e.AST_Dot = mt, e.AST_EmptyStatement = ge, e.AST_Exit = He, e.AST_Expansion = Ne, e.AST_Export = ct, e.AST_False = En, e.AST_Finally = nt, e.AST_For = Ce, e.AST_ForIn = Oe, e.AST_ForOf = Fe, e.AST_Function = Ie, e.AST_Hole = _n, e.AST_If = $e, e.AST_Import = ut, e.AST_Infinity = dn, e.AST_IterationStatement = ve, e.AST_Jump = Ge, e.AST_Label = jt, e.AST_LabelRef = en, e.AST_LabeledStatement = Ae, e.AST_Lambda = xe, e.AST_Let = ot, e.AST_LoopControl = We, e.AST_NaN = fn, e.AST_NameMapping = st, e.AST_New = pt, e.AST_NewTarget = It, e.AST_Node = le, e.AST_Null = ln, e.AST_Number = an, e.AST_Object = yt, e.AST_ObjectGetter = Mt, e.AST_ObjectKeyVal = Ot, e.AST_ObjectProperty = Ct, e.AST_ObjectSetter = Ft, e.AST_PrefixedTemplateString = Be, e.AST_PropAccess = dt, e.AST_RegExp = un, e.AST_Return = Xe, e.AST_Scope = Re, e.AST_Sequence = _t, e.AST_SimpleStatement = de, e.AST_Statement = fe, e.AST_StatementWithBody = Se, e.AST_String = on, e.AST_Sub = Et, e.AST_Super = nn, e.AST_Switch = je, e.AST_SwitchBranch = Ze, e.AST_Symbol = kt, e.AST_SymbolBlockDeclaration = Pt, e.AST_SymbolCatch = Yt, e.AST_SymbolClass = Wt, e.AST_SymbolConst = Bt, e.AST_SymbolDeclaration = Lt, e.AST_SymbolDefClass = zt, e.AST_SymbolDefun = Gt, e.AST_SymbolExport = Jt, e.AST_SymbolExportForeign = Qt, e.AST_SymbolFunarg = Ut, e.AST_SymbolImport = qt, e.AST_SymbolImportForeign = $t, e.AST_SymbolLambda = Xt, e.AST_SymbolLet = Kt, e.AST_SymbolMethod = Ht, e.AST_SymbolRef = Zt, e.AST_SymbolVar = Vt, e.AST_TemplateSegment = Ue, e.AST_TemplateString = Ke, e.AST_This = tn, e.AST_Throw = ze, e.AST_Token = ce, e.AST_Toplevel = we, e.AST_True = hn, e.AST_Try = et, e.AST_Unary = ht, e.AST_UnaryPostfix = gt, e.AST_UnaryPrefix = Dt, e.AST_Undefined = pn, e.AST_Var = rt, e.AST_VarDef = lt, e.AST_While = ye, e.AST_With = Me, e.AST_Yield = gn, e.Compressor = Qn, e.OutputStream = kn, e.TreeTransformer = An, e.TreeWalker = Sn, e._INLINE = Tn, e._JS_Parse_Error = Z, e._NOINLINE = bn, e._PURE = vn, e._has_annotation = T, e._tokenizer = te, e.base54 = Un, e.default_options = function () {
    var e = {};
    return Object.keys(fr({
      0: 0
    })).forEach(function (t) {
      var n = fr(_defineProperty({}, t, {
        0: 0
      }));
      n && (e[t] = n);
    }), e;
  }, e.defaults = o, e.mangle_properties = rr, e.minify = lr, e.parse = se, e.push_uniq = p, e.reserve_quoted_keys = nr, e.string_template = _, e.to_ascii = or;
});
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ "../node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../buffer/index.js */ "../node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../node_modules/webpack/buildin/amd-options.js":
/*!******************************************************!*\
  !*** ../node_modules/webpack/buildin/amd-options.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "../node_modules/webpack/buildin/global.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/global.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

var g; // This works in non-strict mode

g = function () {
  return this;
}();

try {
  // This works if eval is allowed (see CSP)
  g = g || new Function("return this")();
} catch (e) {
  // This works if the window reference is available
  if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
} // g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}


module.exports = g;

/***/ }),

/***/ "../node_modules/webpack/buildin/module.js":
/*!*************************************************!*\
  !*** ../node_modules/webpack/buildin/module.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function (module) {
  if (!module.webpackPolyfill) {
    module.deprecate = function () {};

    module.paths = []; // module.parent = undefined by default

    if (!module.children) module.children = [];
    Object.defineProperty(module, "loaded", {
      enumerable: true,
      get: function get() {
        return module.l;
      }
    });
    Object.defineProperty(module, "id", {
      enumerable: true,
      get: function get() {
        return module.i;
      }
    });
    module.webpackPolyfill = 1;
  }

  return module;
};

/***/ }),

/***/ "../node_modules/whatwg-fetch/fetch.js":
/*!*********************************************!*\
  !*** ../node_modules/whatwg-fetch/fetch.js ***!
  \*********************************************/
/*! exports provided: Headers, Request, Response, DOMException, fetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Headers", function() { return Headers; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Request", function() { return Request; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Response", function() { return Response; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DOMException", function() { return DOMException; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetch", function() { return fetch; });
var support = {
  searchParams: 'URLSearchParams' in self,
  iterable: 'Symbol' in self && 'iterator' in Symbol,
  blob: 'FileReader' in self && 'Blob' in self && function () {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: 'FormData' in self,
  arrayBuffer: 'ArrayBuffer' in self
};

function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}

if (support.arrayBuffer) {
  var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];

  var isArrayBufferView = ArrayBuffer.isView || function (obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}

function normalizeName(name) {
  if (typeof name !== 'string') {
    name = String(name);
  }

  if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
    throw new TypeError('Invalid character in header field name');
  }

  return name.toLowerCase();
}

function normalizeValue(value) {
  if (typeof value !== 'string') {
    value = String(value);
  }

  return value;
} // Build a destructive iterator for the value list


function iteratorFor(items) {
  var iterator = {
    next: function next() {
      var value = items.shift();
      return {
        done: value === undefined,
        value: value
      };
    }
  };

  if (support.iterable) {
    iterator[Symbol.iterator] = function () {
      return iterator;
    };
  }

  return iterator;
}

function Headers(headers) {
  this.map = {};

  if (headers instanceof Headers) {
    headers.forEach(function (value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function (header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function (name) {
      this.append(name, headers[name]);
    }, this);
  }
}

Headers.prototype.append = function (name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ', ' + value : value;
};

Headers.prototype['delete'] = function (name) {
  delete this.map[normalizeName(name)];
};

Headers.prototype.get = function (name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};

Headers.prototype.has = function (name) {
  return this.map.hasOwnProperty(normalizeName(name));
};

Headers.prototype.set = function (name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};

Headers.prototype.forEach = function (callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};

Headers.prototype.keys = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};

Headers.prototype.values = function () {
  var items = [];
  this.forEach(function (value) {
    items.push(value);
  });
  return iteratorFor(items);
};

Headers.prototype.entries = function () {
  var items = [];
  this.forEach(function (value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};

if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}

function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError('Already read'));
  }

  body.bodyUsed = true;
}

function fileReaderReady(reader) {
  return new Promise(function (resolve, reject) {
    reader.onload = function () {
      resolve(reader.result);
    };

    reader.onerror = function () {
      reject(reader.error);
    };
  });
}

function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}

function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}

function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);

  for (var i = 0; i < view.length; i++) {
    chars[i] = String.fromCharCode(view[i]);
  }

  return chars.join('');
}

function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}

function Body() {
  this.bodyUsed = false;

  this._initBody = function (body) {
    this._bodyInit = body;

    if (!body) {
      this._bodyText = '';
    } else if (typeof body === 'string') {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer); // IE 10-11 can't handle a DataView body.

      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }

    if (!this.headers.get('content-type')) {
      if (typeof body === 'string') {
        this.headers.set('content-type', 'text/plain;charset=UTF-8');
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set('content-type', this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
      }
    }
  };

  if (support.blob) {
    this.blob = function () {
      var rejected = consumed(this);

      if (rejected) {
        return rejected;
      }

      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error('could not read FormData body as blob');
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };

    this.arrayBuffer = function () {
      if (this._bodyArrayBuffer) {
        return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }

  this.text = function () {
    var rejected = consumed(this);

    if (rejected) {
      return rejected;
    }

    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error('could not read FormData body as text');
    } else {
      return Promise.resolve(this._bodyText);
    }
  };

  if (support.formData) {
    this.formData = function () {
      return this.text().then(decode);
    };
  }

  this.json = function () {
    return this.text().then(JSON.parse);
  };

  return this;
} // HTTP methods whose capitalization should be normalized


var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];

function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}

function Request(input, options) {
  options = options || {};
  var body = options.body;

  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError('Already read');
    }

    this.url = input.url;
    this.credentials = input.credentials;

    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }

    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;

    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }

  this.credentials = options.credentials || this.credentials || 'same-origin';

  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }

  this.method = normalizeMethod(options.method || this.method || 'GET');
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;

  if ((this.method === 'GET' || this.method === 'HEAD') && body) {
    throw new TypeError('Body not allowed for GET or HEAD requests');
  }

  this._initBody(body);
}

Request.prototype.clone = function () {
  return new Request(this, {
    body: this._bodyInit
  });
};

function decode(body) {
  var form = new FormData();
  body.trim().split('&').forEach(function (bytes) {
    if (bytes) {
      var split = bytes.split('=');
      var name = split.shift().replace(/\+/g, ' ');
      var value = split.join('=').replace(/\+/g, ' ');
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}

function parseHeaders(rawHeaders) {
  var headers = new Headers(); // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
  // https://tools.ietf.org/html/rfc7230#section-3.2

  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
  preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
    var parts = line.split(':');
    var key = parts.shift().trim();

    if (key) {
      var value = parts.join(':').trim();
      headers.append(key, value);
    }
  });
  return headers;
}

Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!options) {
    options = {};
  }

  this.type = 'default';
  this.status = options.status === undefined ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = 'statusText' in options ? options.statusText : 'OK';
  this.headers = new Headers(options.headers);
  this.url = options.url || '';

  this._initBody(bodyInit);
}
Body.call(Response.prototype);

Response.prototype.clone = function () {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};

Response.error = function () {
  var response = new Response(null, {
    status: 0,
    statusText: ''
  });
  response.type = 'error';
  return response;
};

var redirectStatuses = [301, 302, 303, 307, 308];

Response.redirect = function (url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError('Invalid status code');
  }

  return new Response(null, {
    status: status,
    headers: {
      location: url
    }
  });
};

var DOMException = self.DOMException;

try {
  new DOMException();
} catch (err) {
  DOMException = function DOMException(message, name) {
    this.message = message;
    this.name = name;
    var error = Error(message);
    this.stack = error.stack;
  };

  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}

function fetch(input, init) {
  return new Promise(function (resolve, reject) {
    var request = new Request(input, init);

    if (request.signal && request.signal.aborted) {
      return reject(new DOMException('Aborted', 'AbortError'));
    }

    var xhr = new XMLHttpRequest();

    function abortXhr() {
      xhr.abort();
    }

    xhr.onload = function () {
      var options = {
        status: xhr.status,
        statusText: xhr.statusText,
        headers: parseHeaders(xhr.getAllResponseHeaders() || '')
      };
      options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
      var body = 'response' in xhr ? xhr.response : xhr.responseText;
      resolve(new Response(body, options));
    };

    xhr.onerror = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.ontimeout = function () {
      reject(new TypeError('Network request failed'));
    };

    xhr.onabort = function () {
      reject(new DOMException('Aborted', 'AbortError'));
    };

    xhr.open(request.method, request.url, true);

    if (request.credentials === 'include') {
      xhr.withCredentials = true;
    } else if (request.credentials === 'omit') {
      xhr.withCredentials = false;
    }

    if ('responseType' in xhr && support.blob) {
      xhr.responseType = 'blob';
    }

    request.headers.forEach(function (value, name) {
      xhr.setRequestHeader(name, value);
    });

    if (request.signal) {
      request.signal.addEventListener('abort', abortXhr);

      xhr.onreadystatechange = function () {
        // DONE (success or failure)
        if (xhr.readyState === 4) {
          request.signal.removeEventListener('abort', abortXhr);
        }
      };
    }

    xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
  });
}
fetch.polyfill = true;

if (!self.fetch) {
  self.fetch = fetch;
  self.Headers = Headers;
  self.Request = Request;
  self.Response = Response;
}

/***/ }),

/***/ "../package.json":
/*!***********************!*\
  !*** ../package.json ***!
  \***********************/
/*! exports provided: name, version, description, scripts, babel, homepage, repository, author, license, browserslist, dependencies, default */
/***/ (function(module) {

module.exports = JSON.parse("{\"name\":\"gulp-boostrap\",\"version\":\"0.0.1\",\"description\":\"gulp process to generate static pages for templates\",\"scripts\":{\"localbuild\":\"gulp --require babel-register --gulpfile ./.gb/tasks localbuild\",\"devbuild\":\"gulp --require babel-register --gulpfile ./.gb/tasks devbuild\",\"qabuild\":\"gulp --require babel-register --gulpfile ./.gb/tasks qabuild\",\"prodbuild\":\"gulp --require babel-register --gulpfile ./.gb/tasks prodbuild --production\"},\"babel\":{\"presets\":[\"env\"],\"babelrc\":false},\"homepage\":\"http://\",\"repository\":{\"type\":\"git\",\"url\":\"https://\"},\"author\":\"Rauxa\",\"license\":\"MIT\",\"browserslist\":[\"ie >= 11\",\"last 2 version\",\"> 5%\"],\"dependencies\":{\"@babel/core\":\"^7.4.5\",\"@babel/polyfill\":\"^7.4.4\",\"@babel/preset-env\":\"^7.4.5\",\"babel-core\":\"^6.26.3\",\"babel-loader\":\"^8.0.6\",\"babel-preset-env\":\"^1.7.0\",\"base-64\":\"^0.1.0\",\"browser-sync\":\"^2.26.7\",\"cssnano\":\"^4.1.10\",\"gsap\":\"^3.0.1\",\"gulp\":\"^4.0.2\",\"gulp-autoprefixer\":\"^6.1.0\",\"gulp-babel\":\"^8.0.0\",\"gulp-clean\":\"^0.4.0\",\"gulp-if\":\"^3.0.0\",\"gulp-postcss\":\"^8.0.0\",\"gulp-rename\":\"^1.4.0\",\"gulp-sass\":\"^4.0.2\",\"gulp-sass-lint\":\"^1.4.0\",\"gulp-server-livereload\":\"^1.9.2\",\"gulp-sourcemaps\":\"^2.6.5\",\"merge-stream\":\"^2.0.0\",\"normalize-scss\":\"^7.0.1\",\"postcss-discard-comments\":\"^4.0.2\",\"webpack\":\"^4.35.0\",\"webpack-stream\":\"^5.2.1\",\"whatwg-fetch\":\"^3.0.0\",\"yargs\":\"^15.0.2\"}}");

/***/ }),

/***/ "./config.js":
/*!*******************!*\
  !*** ./config.js ***!
  \*******************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*

 .----------------.  .----------------.  .----------------.   .----------------.  .----------------. 
| .--------------. || .--------------. || .--------------. | | .--------------. || .--------------. |
| |  ____  ____  | || |     _____    | || |  _______     | | | |     __       | || |    ______    | |
| | |_  _||_  _| | || |    |_   _|   | || | |_   __ \    | | | |    /  |      | || |  .' ____ '.  | |
| |   \ \  / /   | || |      | |     | || |   | |__) |   | | | |    `| |      | || |  | (____) |  | |
| |    \ \/ /    | || |      | |     | || |   |  __ /    | | | |     | |      | || |  '_.____. |  | |
| |    _|  |_    | || |     _| |_    | || |  _| |  \ \_  | | | |    _| |_     | || |  | \____| |  | |
| |   |______|   | || |    |_____|   | || | |____| |___| | | | |   |_____|    | || |   \______,'  | |
| |              | || |              | || |              | | | |              | || |              | |
| '--------------' || '--------------' || '--------------' | | '--------------' || '--------------' |
 '----------------'  '----------------'  '----------------'   '----------------'  '----------------' 

*/
var pkg = __webpack_require__(/*! ../package */ "../package.json");

var ConfigOptions = function ConfigOptions() {
  var config = this; // source directory 

  config.srcDir = '../assets/src'; // dist directory

  config.distDir = '../assets/dist'; // local development : for local testing

  config.localDir = '../app';
  /*
    Local directories
    ===================================
  */

  config.local = {
    imagesDir: "".concat(config.srcDir, "/images/**/*"),
    viewsDir: "".concat(config.srcDir, "/views/*.html"),
    appcss: "".concat(config.localDir, "/css"),
    appjs: "".concat(config.localDir, "/js"),
    appimg: "".concat(config.localDir, "/images")
  };
  /*
   Framework Scss/css directories
   ===================================
   scssDir : location of all scss files
   distDir : location of unminified css
  */

  config.css = {
    scssDir: "".concat(config.srcDir, "/scss"),
    distDir: "".concat(config.distDir, "/css")
  };
  /*
   Framework Javascript directories
   ===================================
   srcDir : source javascript
   distDir : compiled javascript
  */

  config.js = {
    srcDir: "".concat(config.srcDir, "/js"),
    // config.js.srcDir
    distDir: "".concat(config.distDir, "/js") // config.js.distDir

  };
  config.creds = {
    user: 'CSAlaskaAPI',
    pass: '@Lze1nIuDW'
  };
};

module.exports = new ConfigOptions();

/***/ })

/******/ });
//# sourceMappingURL=scripts.js.map